{
	"metadata": {
		"type": "App"
	},
	"project": {
		"vr": false,
		"cache": true,
		"editable": false,
		"debugMode": true,
		"shadows": true
	},
	"javascripts": [
		{
			"name": "watch.js",
			"source": "\"/**\\n * DEVELOPED BY\\n * GIL LOPES BUENO\\n * gilbueno.mail@gmail.com\\n *\\n * WORKS WITH:\\n * IE8*, IE 9+, FF 4+, SF 5+, WebKit, CH 7+, OP 12+, BESEN, Rhino 1.7+\\n * For IE8 (and other legacy browsers) WatchJS will use dirty checking  \\n *\\n * FORK:\\n * https://github.com/melanke/Watch.JS\\n *\\n * LICENSE: MIT\\n */\\n\\n\\\"use strict\\\";\\n(function (factory) {\\n    if (typeof exports === 'object') {\\n        // Node. Does not work with strict CommonJS, but\\n        // only CommonJS-like enviroments that support module.exports,\\n        // like Node.\\n        module.exports = factory();\\n    } else if (typeof define === 'function' && define.amd) {\\n        // AMD. Register as an anonymous module.\\n        define(factory);\\n    } else {\\n        // Browser globals\\n        window.WatchJS = factory();\\n        window.watch = window.WatchJS.watch;\\n        window.unwatch = window.WatchJS.unwatch;\\n        window.callWatchers = window.WatchJS.callWatchers;\\n    }\\n}(function () {\\n\\n    var WatchJS = {\\n        noMore: false,        // use WatchJS.suspend(obj) instead\\n        useDirtyCheck: false, // use only dirty checking to track changes.\\n        preserveExistingSetters: false\\n    },\\n    lengthsubjects = [];\\n    \\n    var dirtyChecklist = [];\\n    var pendingChanges = []; // used coalesce changes from defineProperty and __defineSetter__\\n    \\n    var supportDefineProperty = false;\\n    try {\\n        supportDefineProperty = Object.defineProperty && Object.defineProperty({},'x', {});\\n    } catch(ex) {  /* not supported */  }\\n\\n    var isFunction = function (functionToCheck) {\\n        var getType = {};\\n        return functionToCheck && getType.toString.call(functionToCheck) == '[object Function]';\\n    };\\n\\n    var isInt = function (x) {\\n        return x % 1 === 0;\\n    };\\n\\n    var isArray = function(obj) {\\n        return Object.prototype.toString.call(obj) === '[object Array]';\\n    };\\n\\n    var isObject = function(obj) {\\n        return {}.toString.apply(obj) === '[object Object]';\\n    };\\n    \\n    var getObjDiff = function(a, b){\\n        var aplus = [],\\n        bplus = [];\\n\\n        if(!(typeof a == \\\"string\\\") && !(typeof b == \\\"string\\\")){\\n\\n            if (isArray(a) && b) {\\n                for (var i=0; i<a.length; i++) {\\n                    if (b[i] === undefined) aplus.push(i);\\n                }\\n            } else {\\n                for(var i in a){\\n                    if (a.hasOwnProperty(i)) {\\n                        if(b && !b.hasOwnProperty(i)) {\\n                            aplus.push(i);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            if (isArray(b) && a) {\\n                for (var j=0; j<b.length; j++) {\\n                    if (a[j] === undefined) bplus.push(j);\\n                }\\n            } else {\\n                for(var j in b){\\n                    if (b.hasOwnProperty(j)) {\\n                        if(a && !a.hasOwnProperty(j)) {\\n                            bplus.push(j);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return {\\n            added: aplus,\\n            removed: bplus\\n        }\\n    };\\n\\n    var clone = function(obj){\\n\\n        if (null == obj || \\\"object\\\" != typeof obj) {\\n            return obj;\\n        }\\n\\n        var copy = obj.constructor();\\n\\n        for (var attr in obj) {\\n            copy[attr] = obj[attr];\\n        }\\n\\n        return copy;        \\n\\n    }\\n\\n    var getExistingSetter = function (obj, propName) {\\n        if (WatchJS.preserveExistingSetters) {\\n            var existing = Object.getOwnPropertyDescriptor(obj, propName);\\n            return existing.set;\\n        }\\n\\n        return undefined;\\n    }\\n\\n    var defineGetAndSet = function (obj, propName, getter, setter) {\\n        try {\\n            var existingSetter = getExistingSetter(obj, propName);\\n            Object.defineProperty(obj, propName, {\\n                get: getter,\\n                set: function(value) {\\n                    setter.call(this, value, true); // coalesce changes\\n                    if (existingSetter) {\\n                        existingSetter(value);\\n                    }\\n                },\\n                enumerable: true,\\n                configurable: true\\n            });\\n        }\\n        catch(e1) {\\n            try{\\n                Object.prototype.__defineGetter__.call(obj, propName, getter);\\n                Object.prototype.__defineSetter__.call(obj, propName, function(value) {\\n                    setter.call(this,value,true); // coalesce changes\\n                });\\n            }\\n            catch(e2) {\\n                observeDirtyChanges(obj,propName,setter);\\n                //throw new Error(\\\"watchJS error: browser not supported :/\\\")\\n            }\\n        }\\n\\n    };\\n\\n    var defineProp = function (obj, propName, value) {\\n        try {\\n            Object.defineProperty(obj, propName, {\\n                enumerable: false,\\n                configurable: true,\\n                writable: false,\\n                value: value\\n            });\\n        } catch(error) {\\n            obj[propName] = value;\\n        }\\n    };\\n\\n    var observeDirtyChanges = function(obj,propName,setter) {\\n        dirtyChecklist[dirtyChecklist.length] = {\\n            prop:       propName,\\n            object:     obj,\\n            orig:       clone(obj[propName]),\\n            callback:   setter\\n        }        \\n    }\\n    \\n    var watch = function () {\\n\\n        if (isFunction(arguments[1])) {\\n            watchAll.apply(this, arguments);\\n        } else if (isArray(arguments[1])) {\\n            watchMany.apply(this, arguments);\\n        } else {\\n            watchOne.apply(this, arguments);\\n        }\\n\\n    };\\n\\n\\n    var watchAll = function (obj, watcher, level, addNRemove) {\\n\\n        if ((typeof obj == \\\"string\\\") || (!(obj instanceof Object) && !isArray(obj))) { //accepts only objects and array (not string)\\n            return;\\n        }\\n\\n        if(isArray(obj)) {\\n            defineWatcher(obj, \\\"__watchall__\\\", watcher, level); // watch all changes on the array\\n            if (level===undefined||level > 0) {\\n                for (var prop = 0; prop < obj.length; prop++) { // watch objects in array\\n                   watchAll(obj[prop],watcher,level, addNRemove);\\n                }\\n            }\\n        } \\n        else {\\n            var prop,props = [];\\n            for (prop in obj) { //for each attribute if obj is an object\\n                if (prop == \\\"$val\\\" || (!supportDefineProperty && prop === 'watchers')) {\\n                    continue;\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(obj, prop)) {\\n                    props.push(prop); //put in the props\\n                }\\n            }\\n            watchMany(obj, props, watcher, level, addNRemove); //watch all items of the props\\n        }\\n\\n\\n        if (addNRemove) {\\n            pushToLengthSubjects(obj, \\\"$$watchlengthsubjectroot\\\", watcher, level);\\n        }\\n    };\\n\\n\\n    var watchMany = function (obj, props, watcher, level, addNRemove) {\\n\\n        if ((typeof obj == \\\"string\\\") || (!(obj instanceof Object) && !isArray(obj))) { //accepts only objects and array (not string)\\n            return;\\n        }\\n\\n        for (var i=0; i<props.length; i++) { //watch each property\\n            var prop = props[i];\\n            watchOne(obj, prop, watcher, level, addNRemove);\\n        }\\n\\n    };\\n\\n    var watchOne = function (obj, prop, watcher, level, addNRemove) {\\n        if ((typeof obj == \\\"string\\\") || (!(obj instanceof Object) && !isArray(obj))) { //accepts only objects and array (not string)\\n            return;\\n        }\\n\\n        if(isFunction(obj[prop])) { //dont watch if it is a function\\n            return;\\n        }\\n        if(obj[prop] != null && (level === undefined || level > 0)){\\n            watchAll(obj[prop], watcher, level!==undefined? level-1 : level); //recursively watch all attributes of this\\n        }\\n\\n        defineWatcher(obj, prop, watcher, level);\\n\\n        if(addNRemove && (level === undefined || level > 0)){\\n            pushToLengthSubjects(obj, prop, watcher, level);\\n        }\\n\\n    };\\n\\n    var unwatch = function () {\\n\\n        if (isFunction(arguments[1])) {\\n            unwatchAll.apply(this, arguments);\\n        } else if (isArray(arguments[1])) {\\n            unwatchMany.apply(this, arguments);\\n        } else {\\n            unwatchOne.apply(this, arguments);\\n        }\\n\\n    };\\n\\n    var unwatchAll = function (obj, watcher) {\\n\\n        if (obj instanceof String || (!(obj instanceof Object) && !isArray(obj))) { //accepts only objects and array (not string)\\n            return;\\n        }\\n\\n        if (isArray(obj)) {\\n            var props = ['__watchall__'];\\n            for (var prop = 0; prop < obj.length; prop++) { //for each item if obj is an array\\n                props.push(prop); //put in the props\\n            }\\n            unwatchMany(obj, props, watcher); //watch all itens of the props\\n        } else {\\n            var unwatchPropsInObject = function (obj2) {\\n                var props = [];\\n                for (var prop2 in obj2) { //for each attribute if obj is an object\\n                    if (obj2.hasOwnProperty(prop2)) {\\n                        if (obj2[prop2] instanceof Object) {\\n                            unwatchPropsInObject(obj2[prop2]); //recurs into object props\\n                        } else {\\n                            props.push(prop2); //put in the props\\n                        }\\n                    }\\n                }\\n                unwatchMany(obj2, props, watcher); //unwatch all of the props\\n            };\\n            unwatchPropsInObject(obj);\\n        }\\n    };\\n\\n\\n    var unwatchMany = function (obj, props, watcher) {\\n\\n        for (var prop2 in props) { //watch each attribute of \\\"props\\\" if is an object\\n            if (props.hasOwnProperty(prop2)) {\\n                unwatchOne(obj, props[prop2], watcher);\\n            }\\n        }\\n    };\\n\\n    var timeouts = [],\\n        timerID = null;\\n    function clearTimerID() {\\n        timerID = null;\\n        for(var i=0; i< timeouts.length; i++) {\\n            timeouts[i]();\\n        }\\n        timeouts.length = 0;\\n    }\\n    var getTimerID= function () {\\n        if (!timerID)  {\\n            timerID = setTimeout(clearTimerID);\\n        }\\n        return timerID;\\n    }\\n    var registerTimeout = function(fn) { // register function to be called on timeout\\n        if (timerID==null) getTimerID();\\n        timeouts[timeouts.length] = fn;\\n    }\\n    \\n    // Track changes made to an array, object or an object's property \\n    // and invoke callback with a single change object containing type, value, oldvalue and array splices\\n    // Syntax: \\n    //      trackChange(obj, callback, recursive, addNRemove)\\n    //      trackChange(obj, prop, callback, recursive, addNRemove)\\n    var trackChange = function() {\\n        var fn = (isFunction(arguments[2])) ? trackProperty : trackObject ;\\n        fn.apply(this,arguments);\\n    }\\n\\n    // track changes made to an object and invoke callback with a single change object containing type, value and array splices\\n    var trackObject= function(obj, callback, recursive, addNRemove) {\\n        var change = null,lastTimerID = -1;\\n        var isArr = isArray(obj);\\n        var level,fn = function(prop, action, newValue, oldValue) {\\n            var timerID = getTimerID();\\n            if (lastTimerID!==timerID) { // check if timer has changed since last update\\n                lastTimerID = timerID;\\n                change = {\\n                    type: 'update'\\n                }\\n                change['value'] = obj;\\n                change['splices'] = null;\\n                registerTimeout(function() {\\n                    callback.call(this,change);\\n                    change = null;\\n                });\\n            }\\n            // create splices for array changes\\n            if (isArr && obj === this && change !== null)  {                \\n                if (action==='pop'||action==='shift') {\\n                    newValue = [];\\n                    oldValue = [oldValue];\\n                }\\n                else if (action==='push'||action==='unshift') {\\n                    newValue = [newValue];\\n                    oldValue = [];\\n                }\\n                else if (action!=='splice') { \\n                    return; // return here - for reverse and sort operations we don't need to return splices. a simple update will do\\n                }\\n                if (!change.splices) change.splices = [];\\n                change.splices[change.splices.length] = {\\n                    index: prop,\\n                    deleteCount: oldValue ? oldValue.length : 0,\\n                    addedCount: newValue ? newValue.length : 0,\\n                    added: newValue,\\n                    deleted: oldValue\\n                };\\n            }\\n\\n        }  \\n        level = (recursive==true) ? undefined : 0;        \\n        watchAll(obj,fn, level, addNRemove);\\n    }\\n    \\n    // track changes made to the property of an object and invoke callback with a single change object containing type, value, oldvalue and splices\\n    var trackProperty = function(obj,prop,callback,recursive, addNRemove) { \\n        if (obj && prop) {\\n            watchOne(obj,prop,function(prop, action, newvalue, oldvalue) {\\n                var change = {\\n                    type: 'update'\\n                }\\n                change['value'] = newvalue;\\n                change['oldvalue'] = oldvalue;\\n                if (recursive && isObject(newvalue)||isArray(newvalue)) {\\n                    trackObject(newvalue,callback,recursive, addNRemove);\\n                }               \\n                callback.call(this,change);\\n            },0)\\n            \\n            if (recursive && isObject(obj[prop])||isArray(obj[prop])) {\\n                trackObject(obj[prop],callback,recursive, addNRemove);\\n            }                           \\n        }\\n    }\\n    \\n    \\n    var defineWatcher = function (obj, prop, watcher, level) {\\n        var newWatcher = false;\\n        var isArr = isArray(obj);\\n        \\n        if (!obj.watchers) {\\n            defineProp(obj, \\\"watchers\\\", {});\\n            if (isArr) {\\n                // watch array functions\\n                watchFunctions(obj, function(index,action,newValue, oldValue) {\\n                    addPendingChange(obj, index, action,newValue, oldValue);\\n                    if (level !== 0 && newValue && (isObject(newValue) || isArray(newValue))) {\\n                        var i,n, ln, wAll, watchList = obj.watchers[prop];\\n                        if ((wAll = obj.watchers['__watchall__'])) {\\n                            watchList = watchList ? watchList.concat(wAll) : wAll;\\n                        }\\n                        ln = watchList ?  watchList.length : 0;\\n                        for (i = 0; i<ln; i++) {\\n                            if (action!=='splice') {\\n                                watchAll(newValue, watchList[i], (level===undefined)?level:level-1);\\n                            }\\n                            else {\\n                                // watch spliced values\\n                                for(n=0; n < newValue.length; n++) {\\n                                    watchAll(newValue[n], watchList[i], (level===undefined)?level:level-1);\\n                                }\\n                            }\\n                        }\\n                    }\\n                });\\n            }\\n        }\\n\\n        if (!obj.watchers[prop]) {\\n            obj.watchers[prop] = [];\\n            if (!isArr) newWatcher = true;\\n        }\\n\\n        for (var i=0; i<obj.watchers[prop].length; i++) {\\n            if(obj.watchers[prop][i] === watcher){\\n                return;\\n            }\\n        }\\n\\n        obj.watchers[prop].push(watcher); //add the new watcher to the watchers array\\n\\n        if (newWatcher) {\\n            var val = obj[prop];            \\n            var getter = function () {\\n                return val;                        \\n            };\\n\\n            var setter = function (newval, delayWatcher) {\\n                var oldval = val;\\n                val = newval;                \\n                if (level !== 0 \\n                    && obj[prop] && (isObject(obj[prop]) || isArray(obj[prop]))\\n                    && !obj[prop].watchers) {\\n                    // watch sub properties\\n                    var i,ln = obj.watchers[prop].length; \\n                    for(i=0; i<ln; i++) {\\n                        watchAll(obj[prop], obj.watchers[prop][i], (level===undefined)?level:level-1);\\n                    }\\n                }\\n\\n                //watchFunctions(obj, prop);\\n                \\n                if (isSuspended(obj, prop)) {\\n                    resume(obj, prop);\\n                    return;\\n                }\\n\\n                if (!WatchJS.noMore){ // this does not work with Object.observe\\n                    //if (JSON.stringify(oldval) !== JSON.stringify(newval)) {\\n                    if (oldval !== newval) {\\n                        if (!delayWatcher) {\\n                            callWatchers(obj, prop, \\\"set\\\", newval, oldval);\\n                        }\\n                        else {\\n                            addPendingChange(obj, prop, \\\"set\\\", newval, oldval);\\n                        }\\n                        WatchJS.noMore = false;\\n                    }\\n                }\\n            };\\n\\n            if (WatchJS.useDirtyCheck) {\\n                observeDirtyChanges(obj,prop,setter);\\n            }\\n            else {\\n                defineGetAndSet(obj, prop, getter, setter);\\n            }\\n        }\\n\\n    };\\n\\n    var callWatchers = function (obj, prop, action, newval, oldval) {\\n        if (prop !== undefined) {\\n            var ln, wl, watchList = obj.watchers[prop];\\n            if ((wl = obj.watchers['__watchall__'])) {\\n                watchList = watchList ? watchList.concat(wl) : wl;\\n            }\\n            ln = watchList ? watchList.length : 0;\\n            for (var wr=0; wr< ln; wr++) {\\n                watchList[wr].call(obj, prop, action, newval, oldval);\\n            }\\n        } else {\\n            for (var prop in obj) {//call all\\n                if (obj.hasOwnProperty(prop)) {\\n                    callWatchers(obj, prop, action, newval, oldval);\\n                }\\n            }\\n        }\\n    };\\n\\n    var methodNames = ['pop', 'push', 'reverse', 'shift', 'sort', 'slice', 'unshift', 'splice'];\\n    var defineArrayMethodWatcher = function (obj, original, methodName, callback) {\\n        defineProp(obj, methodName, function () {\\n            var index = 0;\\n            var i,newValue, oldValue, response;                        \\n            // get values before splicing array \\n            if (methodName === 'splice') {\\n               var start = arguments[0];\\n               var end = start + arguments[1];\\n               oldValue = obj.slice(start,end);\\n               newValue = [];\\n               for(i=2;i<arguments.length;i++) {\\n                   newValue[i-2] = arguments[i];\\n               }\\n               index = start;\\n            } \\n            else {\\n                newValue = arguments.length > 0 ? arguments[0] : undefined;\\n            } \\n\\n            response = original.apply(obj, arguments);\\n            if (methodName !== 'slice') {\\n                if (methodName === 'pop') {\\n                    oldValue = response;\\n                    index = obj.length;\\n                }\\n                else if (methodName === 'push') {\\n                    index = obj.length-1;\\n                }\\n                else if (methodName === 'shift') {\\n                    oldValue = response;\\n                }\\n                else if (methodName !== 'unshift' && newValue===undefined) {\\n                    newValue = response;\\n                }\\n                callback.call(obj, index, methodName,newValue, oldValue)\\n            }\\n            return response;\\n        });\\n    };\\n\\n    var watchFunctions = function(obj, callback) {\\n\\n        if (!isFunction(callback) || !obj || (obj instanceof String) || (!isArray(obj))) {\\n            return;\\n        }\\n\\n        for (var i = methodNames.length, methodName; i--;) {\\n            methodName = methodNames[i];\\n            defineArrayMethodWatcher(obj, obj[methodName], methodName, callback);\\n        }\\n\\n    };\\n\\n    var unwatchOne = function (obj, prop, watcher) {\\n        if (prop) {\\n            if (obj.watchers && obj.watchers[prop]) {\\n                if (watcher === undefined) {\\n                    delete obj.watchers[prop]; // remove all property watchers\\n                }\\n                else {\\n                    for (var i = 0; i < obj.watchers[prop].length; i++) {\\n                        var w = obj.watchers[prop][i];\\n                        if (w == watcher) {\\n                            obj.watchers[prop].splice(i, 1);\\n                        }\\n                    }\\n                }\\n            }\\n        } else {\\n            delete obj.watchers;\\n        }\\n\\n        removeFromLengthSubjects(obj, prop, watcher);\\n        removeFromDirtyChecklist(obj, prop);\\n    };\\n    \\n    // suspend watchers until next update cycle\\n    var suspend = function(obj, prop) {\\n        if (obj.watchers) {\\n            var name = '__wjs_suspend__'+(prop!==undefined ? prop : '');\\n            obj.watchers[name] = true;\\n        }\\n    }\\n    \\n    var isSuspended = function(obj, prop) {\\n        return obj.watchers \\n               && (obj.watchers['__wjs_suspend__'] || \\n                   obj.watchers['__wjs_suspend__'+prop]);\\n    }\\n    \\n    // resumes preivously suspended watchers\\n    var resume = function(obj, prop) {\\n        registerTimeout(function() {\\n            delete obj.watchers['__wjs_suspend__'];\\n            delete obj.watchers['__wjs_suspend__'+prop];\\n        })\\n    }\\n\\n    var pendingTimerID = null;\\n    var addPendingChange = function(obj,prop, mode, newval, oldval) {\\n        pendingChanges[pendingChanges.length] = {\\n            obj:obj,\\n            prop: prop,\\n            mode: mode,\\n            newval: newval,\\n            oldval: oldval\\n        };\\n        if (pendingTimerID===null) {\\n            pendingTimerID = setTimeout(applyPendingChanges);\\n        }\\n    };\\n    \\n    \\n    var applyPendingChanges = function()  {\\n        // apply pending changes\\n        var change = null;\\n        pendingTimerID = null;\\n        for(var i=0;i < pendingChanges.length;i++) {\\n            change = pendingChanges[i];\\n            callWatchers(change.obj, change.prop, change.mode, change.newval, change.oldval);\\n        }\\n        if (change) {\\n            pendingChanges = [];\\n            change = null;\\n        }        \\n    }\\n\\n    var loop = function(){\\n\\n        // check for new or deleted props\\n        for(var i=0; i<lengthsubjects.length; i++) {\\n\\n            var subj = lengthsubjects[i];\\n\\n            if (subj.prop === \\\"$$watchlengthsubjectroot\\\") {\\n\\n                var difference = getObjDiff(subj.obj, subj.actual);\\n\\n                if(difference.added.length || difference.removed.length){\\n                    if(difference.added.length){\\n                        watchMany(subj.obj, difference.added, subj.watcher, subj.level - 1, true);\\n                    }\\n\\n                    subj.watcher.call(subj.obj, \\\"root\\\", \\\"differentattr\\\", difference, subj.actual);\\n                }\\n                subj.actual = clone(subj.obj);\\n\\n\\n            } else {\\n\\n                var difference = getObjDiff(subj.obj[subj.prop], subj.actual);\\n\\n                if(difference.added.length || difference.removed.length){\\n                    if(difference.added.length){\\n                        for (var j=0; j<subj.obj.watchers[subj.prop].length; j++) {\\n                            watchMany(subj.obj[subj.prop], difference.added, subj.obj.watchers[subj.prop][j], subj.level - 1, true);\\n                        }\\n                    }\\n\\n                    callWatchers(subj.obj, subj.prop, \\\"differentattr\\\", difference, subj.actual);\\n                }\\n\\n                subj.actual = clone(subj.obj[subj.prop]);\\n\\n            }\\n\\n        }\\n        \\n        // start dirty check\\n        var n, value;\\n        if (dirtyChecklist.length > 0) {\\n            for (var i = 0; i < dirtyChecklist.length; i++) {\\n                n = dirtyChecklist[i];\\n                value = n.object[n.prop];\\n                if (!compareValues(n.orig, value)) {\\n                    n.orig = clone(value);\\n                    n.callback(value);\\n                }\\n            }\\n        }\\n\\n    };\\n\\n    var compareValues =  function(a,b) {\\n        var i, state = true;\\n        if (a!==b)  {\\n            if (isObject(a)) {\\n                for(i in a) {\\n                    if (!supportDefineProperty && i==='watchers') continue;\\n                    if (a[i]!==b[i]) {\\n                        state = false;\\n                        break;\\n                    };\\n                }\\n            }\\n            else {\\n                state = false;\\n            }\\n        }\\n        return state;\\n    }\\n    \\n    var pushToLengthSubjects = function(obj, prop, watcher, level){\\n\\n        var actual;\\n\\n        if (prop === \\\"$$watchlengthsubjectroot\\\") {\\n            actual =  clone(obj);\\n        } else {\\n            actual = clone(obj[prop]);\\n        }\\n\\n        lengthsubjects.push({\\n            obj: obj,\\n            prop: prop,\\n            actual: actual,\\n            watcher: watcher,\\n            level: level\\n        });\\n    };\\n\\n    var removeFromLengthSubjects = function(obj, prop, watcher){\\n        for (var i=0; i<lengthsubjects.length; i++) {\\n            var subj = lengthsubjects[i];\\n\\n            if (subj.obj == obj) {\\n                if (!prop || subj.prop == prop) {\\n                    if (!watcher || subj.watcher == watcher) {\\n                        // if we splice off one item at position i\\n                        // we need to decrement i as the array is one item shorter\\n                        // so when we increment i in the loop statement we\\n                        // will land at the correct index.\\n                        // if it's not decremented, you won't delete all length subjects\\n                        lengthsubjects.splice(i--, 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n    };\\n    \\n    var removeFromDirtyChecklist = function(obj, prop){\\n        var notInUse;\\n        for (var i=0; i<dirtyChecklist.length; i++) {\\n            var n = dirtyChecklist[i];\\n            var watchers = n.object.watchers;\\n            notInUse = (\\n                n.object == obj \\n                && (!prop || n.prop == prop)\\n                && watchers\\n                && (!prop || !watchers[prop] || watchers[prop].length == 0 )\\n            );\\n            if (notInUse)  {\\n                // we use the same syntax as in removeFromLengthSubjects\\n                dirtyChecklist.splice(i--, 1);\\n            }\\n        }\\n\\n    };    \\n\\n    setInterval(loop, 50);\\n\\n    WatchJS.watch = watch;\\n    WatchJS.unwatch = unwatch;\\n    WatchJS.callWatchers = callWatchers;\\n    WatchJS.suspend = suspend; // suspend watchers    \\n    WatchJS.onChange = trackChange;  // track changes made to object or  it's property and return a single change object\\n\\n    return WatchJS;\\n\\n}));\\n\""
		},
		{
			"name": "command.js",
			"source": "\"\\r\\n/*\\r\\n     * @author dforrer / https://github.com/dforrer\\r\\n     * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)\\r\\n*/\\r\\n\\r\\n/*\\r\\n     * @param editorRef pointer to main editor object used to initialize\\r\\n     *        each command object with a reference to the editor\\r\\n     * @constructor\\r\\n*/\\r\\n\\r\\n    var Command = function ( editorReference ) {\\r\\n\\r\\n        this.id = - 1;\\r\\n        this.inMemory = false;\\r\\n        this.updatable = false;\\r\\n        this.type = \\\"\\\";\\r\\n        this.name = \\\"\\\";\\r\\n\\r\\n    //    if ( editorReference !== undefined ) {\\r\\n\\r\\n    //        Command.editor = editorReference;\\r\\n\\r\\n    //    }\\r\\n\\r\\n    //    this.editor = Command.editor;\\r\\n\\r\\n    };\\r\\n\\r\\n    Command.prototype.toJSON = function () {\\r\\n\\r\\n        var output = {};\\r\\n        output.type = this.type;\\r\\n        output.id = this.id;\\r\\n        output.name = this.name;\\r\\n        return output;\\r\\n\\r\\n    };\\r\\n\\r\\n    Command.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n        this.inMemory = true;\\r\\n        this.type = json.type;\\r\\n        this.id = json.id;\\r\\n        this.name = json.name;\\r\\n\\r\\n    };\\r\\n\""
		},
		{
			"name": "Objectid.js",
			"source": "\"/*\\r\\n*\\r\\n* Copyright (c) 2011-2014- Justin Dearing (zippy1981@gmail.com)\\r\\n* Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)\\r\\n* and GPL (http://www.opensource.org/licenses/gpl-license.php) version 2 licenses.\\r\\n* This software is not distributed under version 3 or later of the GPL.\\r\\n*\\r\\n* Version 1.0.2\\r\\n*\\r\\n*/\\r\\n\\r\\nif (!document) var document = { cookie: '' }; // fix crashes on node\\r\\n\\r\\n/**\\r\\n * Javascript class that mimics how WCF serializes a object of type MongoDB.Bson.ObjectId\\r\\n * and converts between that format and the standard 24 character representation.\\r\\n*/\\r\\nObjectId = (function () {\\r\\n    var increment = Math.floor(Math.random() * (16777216));\\r\\n    var pid = Math.floor(Math.random() * (65536));\\r\\n    var machine = Math.floor(Math.random() * (16777216));\\r\\n\\r\\n    var setMachineCookie = function() {\\r\\n        var cookieList = document.cookie.split('; ');\\r\\n        for (var i in cookieList) {\\r\\n            var cookie = cookieList[i].split('=');\\r\\n            var cookieMachineId = parseInt(cookie[1], 10);\\r\\n            if (cookie[0] == 'mongoMachineId' && cookieMachineId && cookieMachineId >= 0 && cookieMachineId <= 16777215) {\\r\\n                machine = cookieMachineId;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        document.cookie = 'mongoMachineId=' + machine + ';expires=Tue, 19 Jan 2038 05:00:00 GMT;path=/';\\r\\n    };\\r\\n    if (typeof (localStorage) != 'undefined') {\\r\\n        try {\\r\\n            var mongoMachineId = parseInt(localStorage['mongoMachineId']);\\r\\n            if (mongoMachineId >= 0 && mongoMachineId <= 16777215) {\\r\\n                machine = Math.floor(localStorage['mongoMachineId']);\\r\\n            }\\r\\n            // Just always stick the value in.\\r\\n            localStorage['mongoMachineId'] = machine;\\r\\n        } catch (e) {\\r\\n            setMachineCookie();\\r\\n        }\\r\\n    }\\r\\n    else {\\r\\n        setMachineCookie();\\r\\n    }\\r\\n\\r\\n    function ObjId() {\\r\\n        if (!(this instanceof ObjectId)) {\\r\\n            return new ObjectId(arguments[0], arguments[1], arguments[2], arguments[3]).toString();\\r\\n        }\\r\\n\\r\\n        if (typeof (arguments[0]) == 'object') {\\r\\n            this.timestamp = arguments[0].timestamp;\\r\\n            this.machine = arguments[0].machine;\\r\\n            this.pid = arguments[0].pid;\\r\\n            this.increment = arguments[0].increment;\\r\\n        }\\r\\n        else if (typeof (arguments[0]) == 'string' && arguments[0].length == 24) {\\r\\n            this.timestamp = Number('0x' + arguments[0].substr(0, 8)),\\r\\n            this.machine = Number('0x' + arguments[0].substr(8, 6)),\\r\\n            this.pid = Number('0x' + arguments[0].substr(14, 4)),\\r\\n            this.increment = Number('0x' + arguments[0].substr(18, 6))\\r\\n        }\\r\\n        else if (arguments.length == 4 && arguments[0] != null) {\\r\\n            this.timestamp = arguments[0];\\r\\n            this.machine = arguments[1];\\r\\n            this.pid = arguments[2];\\r\\n            this.increment = arguments[3];\\r\\n        }\\r\\n        else {\\r\\n            this.timestamp = Math.floor(new Date().valueOf() / 1000);\\r\\n            this.machine = machine;\\r\\n            this.pid = pid;\\r\\n            this.increment = increment++;\\r\\n            if (increment > 0xffffff) {\\r\\n                increment = 0;\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n    return ObjId;\\r\\n})();\\r\\n\\r\\nObjectId.prototype.getDate = function () {\\r\\n    return new Date(this.timestamp * 1000);\\r\\n};\\r\\n\\r\\nObjectId.prototype.toArray = function () {\\r\\n    var strOid = this.toString();\\r\\n    var array = [];\\r\\n    var i;\\r\\n    for(i = 0; i < 12; i++) {\\r\\n        array[i] = parseInt(strOid.slice(i*2, i*2+2), 16);\\r\\n    }\\r\\n    return array;\\r\\n};\\r\\n\\r\\n/**\\r\\n* Turns a WCF representation of a BSON ObjectId into a 24 character string representation.\\r\\n*/\\r\\nObjectId.prototype.toString = function () {\\r\\n    if (this.timestamp === undefined\\r\\n        || this.machine === undefined\\r\\n        || this.pid === undefined\\r\\n        || this.increment === undefined) {\\r\\n        return 'Invalid ObjectId';\\r\\n    }\\r\\n\\r\\n    var timestamp = this.timestamp.toString(16);\\r\\n    var machine = this.machine.toString(16);\\r\\n    var pid = this.pid.toString(16);\\r\\n    var increment = this.increment.toString(16);\\r\\n    return '00000000'.substr(0, 8 - timestamp.length) + timestamp +\\r\\n           '000000'.substr(0, 6 - machine.length) + machine +\\r\\n           '0000'.substr(0, 4 - pid.length) + pid +\\r\\n           '000000'.substr(0, 6 - increment.length) + increment;\\r\\n};\\r\\n\""
		},
		{
			"name": "rawdeflate.js",
			"source": "\"/*\\r\\n * $Id: rawdeflate.js,v 0.5 2013/04/09 14:25:38 dankogai Exp dankogai $\\r\\n *\\r\\n * GNU General Public License, version 2 (GPL-2.0)\\r\\n *   http://opensource.org/licenses/GPL-2.0\\r\\n * Original:\\r\\n *  http://www.onicos.com/staff/iz/amuse/javascript/expert/deflate.txt\\r\\n */\\r\\n\\r\\n(function(ctx){\\r\\n\\r\\n/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\\r\\n * Version: 1.0.1\\r\\n * LastModified: Dec 25 1999\\r\\n */\\r\\n\\r\\n/* Interface:\\r\\n * data = zip_deflate(src);\\r\\n */\\r\\n\\r\\n/* constant parameters */\\r\\nvar zip_WSIZE = 32768;\\t\\t// Sliding Window size\\r\\nvar zip_STORED_BLOCK = 0;\\r\\nvar zip_STATIC_TREES = 1;\\r\\nvar zip_DYN_TREES    = 2;\\r\\n\\r\\n/* for deflate */\\r\\nvar zip_DEFAULT_LEVEL = 6;\\r\\nvar zip_FULL_SEARCH = true;\\r\\nvar zip_INBUFSIZ = 32768;\\t// Input buffer size\\r\\nvar zip_INBUF_EXTRA = 64;\\t// Extra buffer\\r\\nvar zip_OUTBUFSIZ = 1024 * 8;\\r\\nvar zip_window_size = 2 * zip_WSIZE;\\r\\nvar zip_MIN_MATCH = 3;\\r\\nvar zip_MAX_MATCH = 258;\\r\\nvar zip_BITS = 16;\\r\\n// for SMALL_MEM\\r\\nvar zip_LIT_BUFSIZE = 0x2000;\\r\\nvar zip_HASH_BITS = 13;\\r\\n// for MEDIUM_MEM\\r\\n// var zip_LIT_BUFSIZE = 0x4000;\\r\\n// var zip_HASH_BITS = 14;\\r\\n// for BIG_MEM\\r\\n// var zip_LIT_BUFSIZE = 0x8000;\\r\\n// var zip_HASH_BITS = 15;\\r\\nif(zip_LIT_BUFSIZE > zip_INBUFSIZ)\\r\\n    alert(\\\"error: zip_INBUFSIZ is too small\\\");\\r\\nif((zip_WSIZE<<1) > (1<<zip_BITS))\\r\\n    alert(\\\"error: zip_WSIZE is too large\\\");\\r\\nif(zip_HASH_BITS > zip_BITS-1)\\r\\n    alert(\\\"error: zip_HASH_BITS is too large\\\");\\r\\nif(zip_HASH_BITS < 8 || zip_MAX_MATCH != 258)\\r\\n    alert(\\\"error: Code too clever\\\");\\r\\nvar zip_DIST_BUFSIZE = zip_LIT_BUFSIZE;\\r\\nvar zip_HASH_SIZE = 1 << zip_HASH_BITS;\\r\\nvar zip_HASH_MASK = zip_HASH_SIZE - 1;\\r\\nvar zip_WMASK = zip_WSIZE - 1;\\r\\nvar zip_NIL = 0; // Tail of hash chains\\r\\nvar zip_TOO_FAR = 4096;\\r\\nvar zip_MIN_LOOKAHEAD = zip_MAX_MATCH + zip_MIN_MATCH + 1;\\r\\nvar zip_MAX_DIST = zip_WSIZE - zip_MIN_LOOKAHEAD;\\r\\nvar zip_SMALLEST = 1;\\r\\nvar zip_MAX_BITS = 15;\\r\\nvar zip_MAX_BL_BITS = 7;\\r\\nvar zip_LENGTH_CODES = 29;\\r\\nvar zip_LITERALS =256;\\r\\nvar zip_END_BLOCK = 256;\\r\\nvar zip_L_CODES = zip_LITERALS + 1 + zip_LENGTH_CODES;\\r\\nvar zip_D_CODES = 30;\\r\\nvar zip_BL_CODES = 19;\\r\\nvar zip_REP_3_6 = 16;\\r\\nvar zip_REPZ_3_10 = 17;\\r\\nvar zip_REPZ_11_138 = 18;\\r\\nvar zip_HEAP_SIZE = 2 * zip_L_CODES + 1;\\r\\nvar zip_H_SHIFT = parseInt((zip_HASH_BITS + zip_MIN_MATCH - 1) /\\r\\n\\t\\t\\t   zip_MIN_MATCH);\\r\\n\\r\\n/* variables */\\r\\nvar zip_free_queue;\\r\\nvar zip_qhead, zip_qtail;\\r\\nvar zip_initflag;\\r\\nvar zip_outbuf = null;\\r\\nvar zip_outcnt, zip_outoff;\\r\\nvar zip_complete;\\r\\nvar zip_window;\\r\\nvar zip_d_buf;\\r\\nvar zip_l_buf;\\r\\nvar zip_prev;\\r\\nvar zip_bi_buf;\\r\\nvar zip_bi_valid;\\r\\nvar zip_block_start;\\r\\nvar zip_ins_h;\\r\\nvar zip_hash_head;\\r\\nvar zip_prev_match;\\r\\nvar zip_match_available;\\r\\nvar zip_match_length;\\r\\nvar zip_prev_length;\\r\\nvar zip_strstart;\\r\\nvar zip_match_start;\\r\\nvar zip_eofile;\\r\\nvar zip_lookahead;\\r\\nvar zip_max_chain_length;\\r\\nvar zip_max_lazy_match;\\r\\nvar zip_compr_level;\\r\\nvar zip_good_match;\\r\\nvar zip_nice_match;\\r\\nvar zip_dyn_ltree;\\r\\nvar zip_dyn_dtree;\\r\\nvar zip_static_ltree;\\r\\nvar zip_static_dtree;\\r\\nvar zip_bl_tree;\\r\\nvar zip_l_desc;\\r\\nvar zip_d_desc;\\r\\nvar zip_bl_desc;\\r\\nvar zip_bl_count;\\r\\nvar zip_heap;\\r\\nvar zip_heap_len;\\r\\nvar zip_heap_max;\\r\\nvar zip_depth;\\r\\nvar zip_length_code;\\r\\nvar zip_dist_code;\\r\\nvar zip_base_length;\\r\\nvar zip_base_dist;\\r\\nvar zip_flag_buf;\\r\\nvar zip_last_lit;\\r\\nvar zip_last_dist;\\r\\nvar zip_last_flags;\\r\\nvar zip_flags;\\r\\nvar zip_flag_bit;\\r\\nvar zip_opt_len;\\r\\nvar zip_static_len;\\r\\nvar zip_deflate_data;\\r\\nvar zip_deflate_pos;\\r\\n\\r\\n/* objects (deflate) */\\r\\n\\r\\nvar zip_DeflateCT = function() {\\r\\n    this.fc = 0; // frequency count or bit string\\r\\n    this.dl = 0; // father node in Huffman tree or length of bit string\\r\\n}\\r\\n\\r\\nvar zip_DeflateTreeDesc = function() {\\r\\n    this.dyn_tree = null;\\t// the dynamic tree\\r\\n    this.static_tree = null;\\t// corresponding static tree or NULL\\r\\n    this.extra_bits = null;\\t// extra bits for each code or NULL\\r\\n    this.extra_base = 0;\\t// base index for extra_bits\\r\\n    this.elems = 0;\\t\\t// max number of elements in the tree\\r\\n    this.max_length = 0;\\t// max bit length for the codes\\r\\n    this.max_code = 0;\\t\\t// largest code with non zero frequency\\r\\n}\\r\\n\\r\\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\\r\\n * the desired pack level (0..9). The values given below have been tuned to\\r\\n * exclude worst case performance for pathological files. Better values may be\\r\\n * found for specific files.\\r\\n */\\r\\nvar zip_DeflateConfiguration = function(a, b, c, d) {\\r\\n    this.good_length = a; // reduce lazy search above this match length\\r\\n    this.max_lazy = b;    // do not perform lazy search above this match length\\r\\n    this.nice_length = c; // quit search above this match length\\r\\n    this.max_chain = d;\\r\\n}\\r\\n\\r\\nvar zip_DeflateBuffer = function() {\\r\\n    this.next = null;\\r\\n    this.len = 0;\\r\\n    this.ptr = new Array(zip_OUTBUFSIZ);\\r\\n    this.off = 0;\\r\\n}\\r\\n\\r\\n/* constant tables */\\r\\nvar zip_extra_lbits = new Array(\\r\\n    0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0);\\r\\nvar zip_extra_dbits = new Array(\\r\\n    0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13);\\r\\nvar zip_extra_blbits = new Array(\\r\\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7);\\r\\nvar zip_bl_order = new Array(\\r\\n    16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15);\\r\\nvar zip_configuration_table = new Array(\\r\\n\\tnew zip_DeflateConfiguration(0,    0,   0,    0),\\r\\n\\tnew zip_DeflateConfiguration(4,    4,   8,    4),\\r\\n\\tnew zip_DeflateConfiguration(4,    5,  16,    8),\\r\\n\\tnew zip_DeflateConfiguration(4,    6,  32,   32),\\r\\n\\tnew zip_DeflateConfiguration(4,    4,  16,   16),\\r\\n\\tnew zip_DeflateConfiguration(8,   16,  32,   32),\\r\\n\\tnew zip_DeflateConfiguration(8,   16, 128,  128),\\r\\n\\tnew zip_DeflateConfiguration(8,   32, 128,  256),\\r\\n\\tnew zip_DeflateConfiguration(32, 128, 258, 1024),\\r\\n\\tnew zip_DeflateConfiguration(32, 258, 258, 4096));\\r\\n\\r\\n\\r\\n/* routines (deflate) */\\r\\n\\r\\nvar zip_deflate_start = function(level) {\\r\\n    var i;\\r\\n\\r\\n    if(!level)\\r\\n\\tlevel = zip_DEFAULT_LEVEL;\\r\\n    else if(level < 1)\\r\\n\\tlevel = 1;\\r\\n    else if(level > 9)\\r\\n\\tlevel = 9;\\r\\n\\r\\n    zip_compr_level = level;\\r\\n    zip_initflag = false;\\r\\n    zip_eofile = false;\\r\\n    if(zip_outbuf != null)\\r\\n\\treturn;\\r\\n\\r\\n    zip_free_queue = zip_qhead = zip_qtail = null;\\r\\n    zip_outbuf = new Array(zip_OUTBUFSIZ);\\r\\n    zip_window = new Array(zip_window_size);\\r\\n    zip_d_buf = new Array(zip_DIST_BUFSIZE);\\r\\n    zip_l_buf = new Array(zip_INBUFSIZ + zip_INBUF_EXTRA);\\r\\n    zip_prev = new Array(1 << zip_BITS);\\r\\n    zip_dyn_ltree = new Array(zip_HEAP_SIZE);\\r\\n    for(i = 0; i < zip_HEAP_SIZE; i++)\\r\\n\\tzip_dyn_ltree[i] = new zip_DeflateCT();\\r\\n    zip_dyn_dtree = new Array(2*zip_D_CODES+1);\\r\\n    for(i = 0; i < 2*zip_D_CODES+1; i++)\\r\\n\\tzip_dyn_dtree[i] = new zip_DeflateCT();\\r\\n    zip_static_ltree = new Array(zip_L_CODES+2);\\r\\n    for(i = 0; i < zip_L_CODES+2; i++)\\r\\n\\tzip_static_ltree[i] = new zip_DeflateCT();\\r\\n    zip_static_dtree = new Array(zip_D_CODES);\\r\\n    for(i = 0; i < zip_D_CODES; i++)\\r\\n\\tzip_static_dtree[i] = new zip_DeflateCT();\\r\\n    zip_bl_tree = new Array(2*zip_BL_CODES+1);\\r\\n    for(i = 0; i < 2*zip_BL_CODES+1; i++)\\r\\n\\tzip_bl_tree[i] = new zip_DeflateCT();\\r\\n    zip_l_desc = new zip_DeflateTreeDesc();\\r\\n    zip_d_desc = new zip_DeflateTreeDesc();\\r\\n    zip_bl_desc = new zip_DeflateTreeDesc();\\r\\n    zip_bl_count = new Array(zip_MAX_BITS+1);\\r\\n    zip_heap = new Array(2*zip_L_CODES+1);\\r\\n    zip_depth = new Array(2*zip_L_CODES+1);\\r\\n    zip_length_code = new Array(zip_MAX_MATCH-zip_MIN_MATCH+1);\\r\\n    zip_dist_code = new Array(512);\\r\\n    zip_base_length = new Array(zip_LENGTH_CODES);\\r\\n    zip_base_dist = new Array(zip_D_CODES);\\r\\n    zip_flag_buf = new Array(parseInt(zip_LIT_BUFSIZE / 8));\\r\\n}\\r\\n\\r\\nvar zip_deflate_end = function() {\\r\\n    zip_free_queue = zip_qhead = zip_qtail = null;\\r\\n    zip_outbuf = null;\\r\\n    zip_window = null;\\r\\n    zip_d_buf = null;\\r\\n    zip_l_buf = null;\\r\\n    zip_prev = null;\\r\\n    zip_dyn_ltree = null;\\r\\n    zip_dyn_dtree = null;\\r\\n    zip_static_ltree = null;\\r\\n    zip_static_dtree = null;\\r\\n    zip_bl_tree = null;\\r\\n    zip_l_desc = null;\\r\\n    zip_d_desc = null;\\r\\n    zip_bl_desc = null;\\r\\n    zip_bl_count = null;\\r\\n    zip_heap = null;\\r\\n    zip_depth = null;\\r\\n    zip_length_code = null;\\r\\n    zip_dist_code = null;\\r\\n    zip_base_length = null;\\r\\n    zip_base_dist = null;\\r\\n    zip_flag_buf = null;\\r\\n}\\r\\n\\r\\nvar zip_reuse_queue = function(p) {\\r\\n    p.next = zip_free_queue;\\r\\n    zip_free_queue = p;\\r\\n}\\r\\n\\r\\nvar zip_new_queue = function() {\\r\\n    var p;\\r\\n\\r\\n    if(zip_free_queue != null)\\r\\n    {\\r\\n\\tp = zip_free_queue;\\r\\n\\tzip_free_queue = zip_free_queue.next;\\r\\n    }\\r\\n    else\\r\\n\\tp = new zip_DeflateBuffer();\\r\\n    p.next = null;\\r\\n    p.len = p.off = 0;\\r\\n\\r\\n    return p;\\r\\n}\\r\\n\\r\\nvar zip_head1 = function(i) {\\r\\n    return zip_prev[zip_WSIZE + i];\\r\\n}\\r\\n\\r\\nvar zip_head2 = function(i, val) {\\r\\n    return zip_prev[zip_WSIZE + i] = val;\\r\\n}\\r\\n\\r\\n/* put_byte is used for the compressed output, put_ubyte for the\\r\\n * uncompressed output. However unlzw() uses window for its\\r\\n * suffix table instead of its output buffer, so it does not use put_ubyte\\r\\n * (to be cleaned up).\\r\\n */\\r\\nvar zip_put_byte = function(c) {\\r\\n    zip_outbuf[zip_outoff + zip_outcnt++] = c;\\r\\n    if(zip_outoff + zip_outcnt == zip_OUTBUFSIZ)\\r\\n\\tzip_qoutbuf();\\r\\n}\\r\\n\\r\\n/* Output a 16 bit value, lsb first */\\r\\nvar zip_put_short = function(w) {\\r\\n    w &= 0xffff;\\r\\n    if(zip_outoff + zip_outcnt < zip_OUTBUFSIZ - 2) {\\r\\n\\tzip_outbuf[zip_outoff + zip_outcnt++] = (w & 0xff);\\r\\n\\tzip_outbuf[zip_outoff + zip_outcnt++] = (w >>> 8);\\r\\n    } else {\\r\\n\\tzip_put_byte(w & 0xff);\\r\\n\\tzip_put_byte(w >>> 8);\\r\\n    }\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Insert string s in the dictionary and set match_head to the previous head\\r\\n * of the hash chain (the most recent string with same hash key). Return\\r\\n * the previous length of the hash chain.\\r\\n * IN  assertion: all calls to to INSERT_STRING are made with consecutive\\r\\n *    input characters and the first MIN_MATCH bytes of s are valid\\r\\n *    (except for the last MIN_MATCH-1 bytes of the input file).\\r\\n */\\r\\nvar zip_INSERT_STRING = function() {\\r\\n    zip_ins_h = ((zip_ins_h << zip_H_SHIFT)\\r\\n\\t\\t ^ (zip_window[zip_strstart + zip_MIN_MATCH - 1] & 0xff))\\r\\n\\t& zip_HASH_MASK;\\r\\n    zip_hash_head = zip_head1(zip_ins_h);\\r\\n    zip_prev[zip_strstart & zip_WMASK] = zip_hash_head;\\r\\n    zip_head2(zip_ins_h, zip_strstart);\\r\\n}\\r\\n\\r\\n/* Send a code of the given tree. c and tree must not have side effects */\\r\\nvar zip_SEND_CODE = function(c, tree) {\\r\\n    zip_send_bits(tree[c].fc, tree[c].dl);\\r\\n}\\r\\n\\r\\n/* Mapping from a distance to a distance code. dist is the distance - 1 and\\r\\n * must not have side effects. dist_code[256] and dist_code[257] are never\\r\\n * used.\\r\\n */\\r\\nvar zip_D_CODE = function(dist) {\\r\\n    return (dist < 256 ? zip_dist_code[dist]\\r\\n\\t    : zip_dist_code[256 + (dist>>7)]) & 0xff;\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Compares to subtrees, using the tree depth as tie breaker when\\r\\n * the subtrees have equal frequency. This minimizes the worst case length.\\r\\n */\\r\\nvar zip_SMALLER = function(tree, n, m) {\\r\\n    return tree[n].fc < tree[m].fc ||\\r\\n      (tree[n].fc == tree[m].fc && zip_depth[n] <= zip_depth[m]);\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * read string data\\r\\n */\\r\\nvar zip_read_buff = function(buff, offset, n) {\\r\\n    var i;\\r\\n    for(i = 0; i < n && zip_deflate_pos < zip_deflate_data.length; i++)\\r\\n\\tbuff[offset + i] =\\r\\n\\t    zip_deflate_data.charCodeAt(zip_deflate_pos++) & 0xff;\\r\\n    return i;\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Initialize the \\\"longest match\\\" routines for a new file\\r\\n */\\r\\nvar zip_lm_init = function() {\\r\\n    var j;\\r\\n\\r\\n    /* Initialize the hash table. */\\r\\n    for(j = 0; j < zip_HASH_SIZE; j++)\\r\\n//\\tzip_head2(j, zip_NIL);\\r\\n\\tzip_prev[zip_WSIZE + j] = 0;\\r\\n    /* prev will be initialized on the fly */\\r\\n\\r\\n    /* Set the default configuration parameters:\\r\\n     */\\r\\n    zip_max_lazy_match = zip_configuration_table[zip_compr_level].max_lazy;\\r\\n    zip_good_match     = zip_configuration_table[zip_compr_level].good_length;\\r\\n    if(!zip_FULL_SEARCH)\\r\\n\\tzip_nice_match = zip_configuration_table[zip_compr_level].nice_length;\\r\\n    zip_max_chain_length = zip_configuration_table[zip_compr_level].max_chain;\\r\\n\\r\\n    zip_strstart = 0;\\r\\n    zip_block_start = 0;\\r\\n\\r\\n    zip_lookahead = zip_read_buff(zip_window, 0, 2 * zip_WSIZE);\\r\\n    if(zip_lookahead <= 0) {\\r\\n\\tzip_eofile = true;\\r\\n\\tzip_lookahead = 0;\\r\\n\\treturn;\\r\\n    }\\r\\n    zip_eofile = false;\\r\\n    /* Make sure that we always have enough lookahead. This is important\\r\\n     * if input comes from a device such as a tty.\\r\\n     */\\r\\n    while(zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\\r\\n\\tzip_fill_window();\\r\\n\\r\\n    /* If lookahead < MIN_MATCH, ins_h is garbage, but this is\\r\\n     * not important since only literal bytes will be emitted.\\r\\n     */\\r\\n    zip_ins_h = 0;\\r\\n    for(j = 0; j < zip_MIN_MATCH - 1; j++) {\\r\\n//      UPDATE_HASH(ins_h, window[j]);\\r\\n\\tzip_ins_h = ((zip_ins_h << zip_H_SHIFT) ^ (zip_window[j] & 0xff)) & zip_HASH_MASK;\\r\\n    }\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Set match_start to the longest match starting at the given string and\\r\\n * return its length. Matches shorter or equal to prev_length are discarded,\\r\\n * in which case the result is equal to prev_length and match_start is\\r\\n * garbage.\\r\\n * IN assertions: cur_match is the head of the hash chain for the current\\r\\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\\r\\n */\\r\\nvar zip_longest_match = function(cur_match) {\\r\\n    var chain_length = zip_max_chain_length; // max hash chain length\\r\\n    var scanp = zip_strstart; // current string\\r\\n    var matchp;\\t\\t// matched string\\r\\n    var len;\\t\\t// length of current match\\r\\n    var best_len = zip_prev_length;\\t// best match length so far\\r\\n\\r\\n    /* Stop when cur_match becomes <= limit. To simplify the code,\\r\\n     * we prevent matches with the string of window index 0.\\r\\n     */\\r\\n    var limit = (zip_strstart > zip_MAX_DIST ? zip_strstart - zip_MAX_DIST : zip_NIL);\\r\\n\\r\\n    var strendp = zip_strstart + zip_MAX_MATCH;\\r\\n    var scan_end1 = zip_window[scanp + best_len - 1];\\r\\n    var scan_end  = zip_window[scanp + best_len];\\r\\n\\r\\n    /* Do not waste too much time if we already have a good match: */\\r\\n    if(zip_prev_length >= zip_good_match)\\r\\n\\tchain_length >>= 2;\\r\\n\\r\\n//  Assert(encoder->strstart <= window_size-MIN_LOOKAHEAD, \\\"insufficient lookahead\\\");\\r\\n\\r\\n    do {\\r\\n//    Assert(cur_match < encoder->strstart, \\\"no future\\\");\\r\\n\\tmatchp = cur_match;\\r\\n\\r\\n\\t/* Skip to next match if the match length cannot increase\\r\\n\\t    * or if the match length is less than 2:\\r\\n\\t*/\\r\\n\\tif(zip_window[matchp + best_len]\\t!= scan_end  ||\\r\\n\\t   zip_window[matchp + best_len - 1]\\t!= scan_end1 ||\\r\\n\\t   zip_window[matchp]\\t\\t\\t!= zip_window[scanp] ||\\r\\n\\t   zip_window[++matchp]\\t\\t\\t!= zip_window[scanp + 1]) {\\r\\n\\t    continue;\\r\\n\\t}\\r\\n\\r\\n\\t/* The check at best_len-1 can be removed because it will be made\\r\\n         * again later. (This heuristic is not always a win.)\\r\\n         * It is not necessary to compare scan[2] and match[2] since they\\r\\n         * are always equal when the other bytes match, given that\\r\\n         * the hash keys are equal and that HASH_BITS >= 8.\\r\\n         */\\r\\n\\tscanp += 2;\\r\\n\\tmatchp++;\\r\\n\\r\\n\\t/* We check for insufficient lookahead only every 8th comparison;\\r\\n         * the 256th check will be made at strstart+258.\\r\\n         */\\r\\n\\tdo {\\r\\n\\t} while(zip_window[++scanp] == zip_window[++matchp] &&\\r\\n\\t\\tzip_window[++scanp] == zip_window[++matchp] &&\\r\\n\\t\\tzip_window[++scanp] == zip_window[++matchp] &&\\r\\n\\t\\tzip_window[++scanp] == zip_window[++matchp] &&\\r\\n\\t\\tzip_window[++scanp] == zip_window[++matchp] &&\\r\\n\\t\\tzip_window[++scanp] == zip_window[++matchp] &&\\r\\n\\t\\tzip_window[++scanp] == zip_window[++matchp] &&\\r\\n\\t\\tzip_window[++scanp] == zip_window[++matchp] &&\\r\\n\\t\\tscanp < strendp);\\r\\n\\r\\n      len = zip_MAX_MATCH - (strendp - scanp);\\r\\n      scanp = strendp - zip_MAX_MATCH;\\r\\n\\r\\n      if(len > best_len) {\\r\\n\\t  zip_match_start = cur_match;\\r\\n\\t  best_len = len;\\r\\n\\t  if(zip_FULL_SEARCH) {\\r\\n\\t      if(len >= zip_MAX_MATCH) break;\\r\\n\\t  } else {\\r\\n\\t      if(len >= zip_nice_match) break;\\r\\n\\t  }\\r\\n\\r\\n\\t  scan_end1  = zip_window[scanp + best_len-1];\\r\\n\\t  scan_end   = zip_window[scanp + best_len];\\r\\n      }\\r\\n    } while((cur_match = zip_prev[cur_match & zip_WMASK]) > limit\\r\\n\\t    && --chain_length != 0);\\r\\n\\r\\n    return best_len;\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Fill the window when the lookahead becomes insufficient.\\r\\n * Updates strstart and lookahead, and sets eofile if end of input file.\\r\\n * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0\\r\\n * OUT assertions: at least one byte has been read, or eofile is set;\\r\\n *    file reads are performed for at least two bytes (required for the\\r\\n *    translate_eol option).\\r\\n */\\r\\nvar zip_fill_window = function() {\\r\\n    var n, m;\\r\\n\\r\\n    // Amount of free space at the end of the window.\\r\\n    var more = zip_window_size - zip_lookahead - zip_strstart;\\r\\n\\r\\n    /* If the window is almost full and there is insufficient lookahead,\\r\\n     * move the upper half to the lower one to make room in the upper half.\\r\\n     */\\r\\n    if(more == -1) {\\r\\n\\t/* Very unlikely, but possible on 16 bit machine if strstart == 0\\r\\n         * and lookahead == 1 (input done one byte at time)\\r\\n         */\\r\\n\\tmore--;\\r\\n    } else if(zip_strstart >= zip_WSIZE + zip_MAX_DIST) {\\r\\n\\t/* By the IN assertion, the window is not empty so we can't confuse\\r\\n         * more == 0 with more == 64K on a 16 bit machine.\\r\\n         */\\r\\n//\\tAssert(window_size == (ulg)2*WSIZE, \\\"no sliding with BIG_MEM\\\");\\r\\n\\r\\n//\\tSystem.arraycopy(window, WSIZE, window, 0, WSIZE);\\r\\n\\tfor(n = 0; n < zip_WSIZE; n++)\\r\\n\\t    zip_window[n] = zip_window[n + zip_WSIZE];\\r\\n      \\r\\n\\tzip_match_start -= zip_WSIZE;\\r\\n\\tzip_strstart    -= zip_WSIZE; /* we now have strstart >= MAX_DIST: */\\r\\n\\tzip_block_start -= zip_WSIZE;\\r\\n\\r\\n\\tfor(n = 0; n < zip_HASH_SIZE; n++) {\\r\\n\\t    m = zip_head1(n);\\r\\n\\t    zip_head2(n, m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);\\r\\n\\t}\\r\\n\\tfor(n = 0; n < zip_WSIZE; n++) {\\r\\n\\t    /* If n is not on any hash chain, prev[n] is garbage but\\r\\n\\t     * its value will never be used.\\r\\n\\t     */\\r\\n\\t    m = zip_prev[n];\\r\\n\\t    zip_prev[n] = (m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);\\r\\n\\t}\\r\\n\\tmore += zip_WSIZE;\\r\\n    }\\r\\n    // At this point, more >= 2\\r\\n    if(!zip_eofile) {\\r\\n\\tn = zip_read_buff(zip_window, zip_strstart + zip_lookahead, more);\\r\\n\\tif(n <= 0)\\r\\n\\t    zip_eofile = true;\\r\\n\\telse\\r\\n\\t    zip_lookahead += n;\\r\\n    }\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Processes a new input file and return its compressed length. This\\r\\n * function does not perform lazy evaluationof matches and inserts\\r\\n * new strings in the dictionary only for unmatched strings or for short\\r\\n * matches. It is used only for the fast compression options.\\r\\n */\\r\\nvar zip_deflate_fast = function() {\\r\\n    while(zip_lookahead != 0 && zip_qhead == null) {\\r\\n\\tvar flush; // set if current block must be flushed\\r\\n\\r\\n\\t/* Insert the string window[strstart .. strstart+2] in the\\r\\n\\t * dictionary, and set hash_head to the head of the hash chain:\\r\\n\\t */\\r\\n\\tzip_INSERT_STRING();\\r\\n\\r\\n\\t/* Find the longest match, discarding those <= prev_length.\\r\\n\\t * At this point we have always match_length < MIN_MATCH\\r\\n\\t */\\r\\n\\tif(zip_hash_head != zip_NIL &&\\r\\n\\t   zip_strstart - zip_hash_head <= zip_MAX_DIST) {\\r\\n\\t    /* To simplify the code, we prevent matches with the string\\r\\n\\t     * of window index 0 (in particular we have to avoid a match\\r\\n\\t     * of the string with itself at the start of the input file).\\r\\n\\t     */\\r\\n\\t    zip_match_length = zip_longest_match(zip_hash_head);\\r\\n\\t    /* longest_match() sets match_start */\\r\\n\\t    if(zip_match_length > zip_lookahead)\\r\\n\\t\\tzip_match_length = zip_lookahead;\\r\\n\\t}\\r\\n\\tif(zip_match_length >= zip_MIN_MATCH) {\\r\\n//\\t    check_match(strstart, match_start, match_length);\\r\\n\\r\\n\\t    flush = zip_ct_tally(zip_strstart - zip_match_start,\\r\\n\\t\\t\\t\\t zip_match_length - zip_MIN_MATCH);\\r\\n\\t    zip_lookahead -= zip_match_length;\\r\\n\\r\\n\\t    /* Insert new strings in the hash table only if the match length\\r\\n\\t     * is not too large. This saves time but degrades compression.\\r\\n\\t     */\\r\\n\\t    if(zip_match_length <= zip_max_lazy_match) {\\r\\n\\t\\tzip_match_length--; // string at strstart already in hash table\\r\\n\\t\\tdo {\\r\\n\\t\\t    zip_strstart++;\\r\\n\\t\\t    zip_INSERT_STRING();\\r\\n\\t\\t    /* strstart never exceeds WSIZE-MAX_MATCH, so there are\\r\\n\\t\\t     * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\\r\\n\\t\\t     * these bytes are garbage, but it does not matter since\\r\\n\\t\\t     * the next lookahead bytes will be emitted as literals.\\r\\n\\t\\t     */\\r\\n\\t\\t} while(--zip_match_length != 0);\\r\\n\\t\\tzip_strstart++;\\r\\n\\t    } else {\\r\\n\\t\\tzip_strstart += zip_match_length;\\r\\n\\t\\tzip_match_length = 0;\\r\\n\\t\\tzip_ins_h = zip_window[zip_strstart] & 0xff;\\r\\n//\\t\\tUPDATE_HASH(ins_h, window[strstart + 1]);\\r\\n\\t\\tzip_ins_h = ((zip_ins_h<<zip_H_SHIFT) ^ (zip_window[zip_strstart + 1] & 0xff)) & zip_HASH_MASK;\\r\\n\\r\\n//#if MIN_MATCH != 3\\r\\n//\\t\\tCall UPDATE_HASH() MIN_MATCH-3 more times\\r\\n//#endif\\r\\n\\r\\n\\t    }\\r\\n\\t} else {\\r\\n\\t    /* No match, output a literal byte */\\r\\n\\t    flush = zip_ct_tally(0, zip_window[zip_strstart] & 0xff);\\r\\n\\t    zip_lookahead--;\\r\\n\\t    zip_strstart++;\\r\\n\\t}\\r\\n\\tif(flush) {\\r\\n\\t    zip_flush_block(0);\\r\\n\\t    zip_block_start = zip_strstart;\\r\\n\\t}\\r\\n\\r\\n\\t/* Make sure that we always have enough lookahead, except\\r\\n\\t * at the end of the input file. We need MAX_MATCH bytes\\r\\n\\t * for the next match, plus MIN_MATCH bytes to insert the\\r\\n\\t * string following the next match.\\r\\n\\t */\\r\\n\\twhile(zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\\r\\n\\t    zip_fill_window();\\r\\n    }\\r\\n}\\r\\n\\r\\nvar zip_deflate_better = function() {\\r\\n    /* Process the input block. */\\r\\n    while(zip_lookahead != 0 && zip_qhead == null) {\\r\\n\\t/* Insert the string window[strstart .. strstart+2] in the\\r\\n\\t * dictionary, and set hash_head to the head of the hash chain:\\r\\n\\t */\\r\\n\\tzip_INSERT_STRING();\\r\\n\\r\\n\\t/* Find the longest match, discarding those <= prev_length.\\r\\n\\t */\\r\\n\\tzip_prev_length = zip_match_length;\\r\\n\\tzip_prev_match = zip_match_start;\\r\\n\\tzip_match_length = zip_MIN_MATCH - 1;\\r\\n\\r\\n\\tif(zip_hash_head != zip_NIL &&\\r\\n\\t   zip_prev_length < zip_max_lazy_match &&\\r\\n\\t   zip_strstart - zip_hash_head <= zip_MAX_DIST) {\\r\\n\\t    /* To simplify the code, we prevent matches with the string\\r\\n\\t     * of window index 0 (in particular we have to avoid a match\\r\\n\\t     * of the string with itself at the start of the input file).\\r\\n\\t     */\\r\\n\\t    zip_match_length = zip_longest_match(zip_hash_head);\\r\\n\\t    /* longest_match() sets match_start */\\r\\n\\t    if(zip_match_length > zip_lookahead)\\r\\n\\t\\tzip_match_length = zip_lookahead;\\r\\n\\r\\n\\t    /* Ignore a length 3 match if it is too distant: */\\r\\n\\t    if(zip_match_length == zip_MIN_MATCH &&\\r\\n\\t       zip_strstart - zip_match_start > zip_TOO_FAR) {\\r\\n\\t\\t/* If prev_match is also MIN_MATCH, match_start is garbage\\r\\n\\t\\t * but we will ignore the current match anyway.\\r\\n\\t\\t */\\r\\n\\t\\tzip_match_length--;\\r\\n\\t    }\\r\\n\\t}\\r\\n\\t/* If there was a match at the previous step and the current\\r\\n\\t * match is not better, output the previous match:\\r\\n\\t */\\r\\n\\tif(zip_prev_length >= zip_MIN_MATCH &&\\r\\n\\t   zip_match_length <= zip_prev_length) {\\r\\n\\t    var flush; // set if current block must be flushed\\r\\n\\r\\n//\\t    check_match(strstart - 1, prev_match, prev_length);\\r\\n\\t    flush = zip_ct_tally(zip_strstart - 1 - zip_prev_match,\\r\\n\\t\\t\\t\\t zip_prev_length - zip_MIN_MATCH);\\r\\n\\r\\n\\t    /* Insert in hash table all strings up to the end of the match.\\r\\n\\t     * strstart-1 and strstart are already inserted.\\r\\n\\t     */\\r\\n\\t    zip_lookahead -= zip_prev_length - 1;\\r\\n\\t    zip_prev_length -= 2;\\r\\n\\t    do {\\r\\n\\t\\tzip_strstart++;\\r\\n\\t\\tzip_INSERT_STRING();\\r\\n\\t\\t/* strstart never exceeds WSIZE-MAX_MATCH, so there are\\r\\n\\t\\t * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\\r\\n\\t\\t * these bytes are garbage, but it does not matter since the\\r\\n\\t\\t * next lookahead bytes will always be emitted as literals.\\r\\n\\t\\t */\\r\\n\\t    } while(--zip_prev_length != 0);\\r\\n\\t    zip_match_available = 0;\\r\\n\\t    zip_match_length = zip_MIN_MATCH - 1;\\r\\n\\t    zip_strstart++;\\r\\n\\t    if(flush) {\\r\\n\\t\\tzip_flush_block(0);\\r\\n\\t\\tzip_block_start = zip_strstart;\\r\\n\\t    }\\r\\n\\t} else if(zip_match_available != 0) {\\r\\n\\t    /* If there was no match at the previous position, output a\\r\\n\\t     * single literal. If there was a match but the current match\\r\\n\\t     * is longer, truncate the previous match to a single literal.\\r\\n\\t     */\\r\\n\\t    if(zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff)) {\\r\\n\\t\\tzip_flush_block(0);\\r\\n\\t\\tzip_block_start = zip_strstart;\\r\\n\\t    }\\r\\n\\t    zip_strstart++;\\r\\n\\t    zip_lookahead--;\\r\\n\\t} else {\\r\\n\\t    /* There is no previous match to compare with, wait for\\r\\n\\t     * the next step to decide.\\r\\n\\t     */\\r\\n\\t    zip_match_available = 1;\\r\\n\\t    zip_strstart++;\\r\\n\\t    zip_lookahead--;\\r\\n\\t}\\r\\n\\r\\n\\t/* Make sure that we always have enough lookahead, except\\r\\n\\t * at the end of the input file. We need MAX_MATCH bytes\\r\\n\\t * for the next match, plus MIN_MATCH bytes to insert the\\r\\n\\t * string following the next match.\\r\\n\\t */\\r\\n\\twhile(zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\\r\\n\\t    zip_fill_window();\\r\\n    }\\r\\n}\\r\\n\\r\\nvar zip_init_deflate = function() {\\r\\n    if(zip_eofile)\\r\\n\\treturn;\\r\\n    zip_bi_buf = 0;\\r\\n    zip_bi_valid = 0;\\r\\n    zip_ct_init();\\r\\n    zip_lm_init();\\r\\n\\r\\n    zip_qhead = null;\\r\\n    zip_outcnt = 0;\\r\\n    zip_outoff = 0;\\r\\n    zip_match_available = 0;\\r\\n\\r\\n    if(zip_compr_level <= 3)\\r\\n    {\\r\\n\\tzip_prev_length = zip_MIN_MATCH - 1;\\r\\n\\tzip_match_length = 0;\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n\\tzip_match_length = zip_MIN_MATCH - 1;\\r\\n\\tzip_match_available = 0;\\r\\n        zip_match_available = 0;\\r\\n    }\\r\\n\\r\\n    zip_complete = false;\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Same as above, but achieves better compression. We use a lazy\\r\\n * evaluation for matches: a match is finally adopted only if there is\\r\\n * no better match at the next window position.\\r\\n */\\r\\nvar zip_deflate_internal = function(buff, off, buff_size) {\\r\\n    var n;\\r\\n\\r\\n    if(!zip_initflag)\\r\\n    {\\r\\n\\tzip_init_deflate();\\r\\n\\tzip_initflag = true;\\r\\n\\tif(zip_lookahead == 0) { // empty\\r\\n\\t    zip_complete = true;\\r\\n\\t    return 0;\\r\\n\\t}\\r\\n    }\\r\\n\\r\\n    if((n = zip_qcopy(buff, off, buff_size)) == buff_size)\\r\\n\\treturn buff_size;\\r\\n\\r\\n    if(zip_complete)\\r\\n\\treturn n;\\r\\n\\r\\n    if(zip_compr_level <= 3) // optimized for speed\\r\\n\\tzip_deflate_fast();\\r\\n    else\\r\\n\\tzip_deflate_better();\\r\\n    if(zip_lookahead == 0) {\\r\\n\\tif(zip_match_available != 0)\\r\\n\\t    zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff);\\r\\n\\tzip_flush_block(1);\\r\\n\\tzip_complete = true;\\r\\n    }\\r\\n    return n + zip_qcopy(buff, n + off, buff_size - n);\\r\\n}\\r\\n\\r\\nvar zip_qcopy = function(buff, off, buff_size) {\\r\\n    var n, i, j;\\r\\n\\r\\n    n = 0;\\r\\n    while(zip_qhead != null && n < buff_size)\\r\\n    {\\r\\n\\ti = buff_size - n;\\r\\n\\tif(i > zip_qhead.len)\\r\\n\\t    i = zip_qhead.len;\\r\\n//      System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);\\r\\n\\tfor(j = 0; j < i; j++)\\r\\n\\t    buff[off + n + j] = zip_qhead.ptr[zip_qhead.off + j];\\r\\n\\t\\r\\n\\tzip_qhead.off += i;\\r\\n\\tzip_qhead.len -= i;\\r\\n\\tn += i;\\r\\n\\tif(zip_qhead.len == 0) {\\r\\n\\t    var p;\\r\\n\\t    p = zip_qhead;\\r\\n\\t    zip_qhead = zip_qhead.next;\\r\\n\\t    zip_reuse_queue(p);\\r\\n\\t}\\r\\n    }\\r\\n\\r\\n    if(n == buff_size)\\r\\n\\treturn n;\\r\\n\\r\\n    if(zip_outoff < zip_outcnt) {\\r\\n\\ti = buff_size - n;\\r\\n\\tif(i > zip_outcnt - zip_outoff)\\r\\n\\t    i = zip_outcnt - zip_outoff;\\r\\n\\t// System.arraycopy(outbuf, outoff, buff, off + n, i);\\r\\n\\tfor(j = 0; j < i; j++)\\r\\n\\t    buff[off + n + j] = zip_outbuf[zip_outoff + j];\\r\\n\\tzip_outoff += i;\\r\\n\\tn += i;\\r\\n\\tif(zip_outcnt == zip_outoff)\\r\\n\\t    zip_outcnt = zip_outoff = 0;\\r\\n    }\\r\\n    return n;\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Allocate the match buffer, initialize the various tables and save the\\r\\n * location of the internal file attribute (ascii/binary) and method\\r\\n * (DEFLATE/STORE).\\r\\n */\\r\\nvar zip_ct_init = function() {\\r\\n    var n;\\t// iterates over tree elements\\r\\n    var bits;\\t// bit counter\\r\\n    var length;\\t// length value\\r\\n    var code;\\t// code value\\r\\n    var dist;\\t// distance index\\r\\n\\r\\n    if(zip_static_dtree[0].dl != 0) return; // ct_init already called\\r\\n\\r\\n    zip_l_desc.dyn_tree\\t\\t= zip_dyn_ltree;\\r\\n    zip_l_desc.static_tree\\t= zip_static_ltree;\\r\\n    zip_l_desc.extra_bits\\t= zip_extra_lbits;\\r\\n    zip_l_desc.extra_base\\t= zip_LITERALS + 1;\\r\\n    zip_l_desc.elems\\t\\t= zip_L_CODES;\\r\\n    zip_l_desc.max_length\\t= zip_MAX_BITS;\\r\\n    zip_l_desc.max_code\\t\\t= 0;\\r\\n\\r\\n    zip_d_desc.dyn_tree\\t\\t= zip_dyn_dtree;\\r\\n    zip_d_desc.static_tree\\t= zip_static_dtree;\\r\\n    zip_d_desc.extra_bits\\t= zip_extra_dbits;\\r\\n    zip_d_desc.extra_base\\t= 0;\\r\\n    zip_d_desc.elems\\t\\t= zip_D_CODES;\\r\\n    zip_d_desc.max_length\\t= zip_MAX_BITS;\\r\\n    zip_d_desc.max_code\\t\\t= 0;\\r\\n\\r\\n    zip_bl_desc.dyn_tree\\t= zip_bl_tree;\\r\\n    zip_bl_desc.static_tree\\t= null;\\r\\n    zip_bl_desc.extra_bits\\t= zip_extra_blbits;\\r\\n    zip_bl_desc.extra_base\\t= 0;\\r\\n    zip_bl_desc.elems\\t\\t= zip_BL_CODES;\\r\\n    zip_bl_desc.max_length\\t= zip_MAX_BL_BITS;\\r\\n    zip_bl_desc.max_code\\t= 0;\\r\\n\\r\\n    // Initialize the mapping length (0..255) -> length code (0..28)\\r\\n    length = 0;\\r\\n    for(code = 0; code < zip_LENGTH_CODES-1; code++) {\\r\\n\\tzip_base_length[code] = length;\\r\\n\\tfor(n = 0; n < (1<<zip_extra_lbits[code]); n++)\\r\\n\\t    zip_length_code[length++] = code;\\r\\n    }\\r\\n    // Assert (length == 256, \\\"ct_init: length != 256\\\");\\r\\n\\r\\n    /* Note that the length 255 (match length 258) can be represented\\r\\n     * in two different ways: code 284 + 5 bits or code 285, so we\\r\\n     * overwrite length_code[255] to use the best encoding:\\r\\n     */\\r\\n    zip_length_code[length-1] = code;\\r\\n\\r\\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\\r\\n    dist = 0;\\r\\n    for(code = 0 ; code < 16; code++) {\\r\\n\\tzip_base_dist[code] = dist;\\r\\n\\tfor(n = 0; n < (1<<zip_extra_dbits[code]); n++) {\\r\\n\\t    zip_dist_code[dist++] = code;\\r\\n\\t}\\r\\n    }\\r\\n    // Assert (dist == 256, \\\"ct_init: dist != 256\\\");\\r\\n    dist >>= 7; // from now on, all distances are divided by 128\\r\\n    for( ; code < zip_D_CODES; code++) {\\r\\n\\tzip_base_dist[code] = dist << 7;\\r\\n\\tfor(n = 0; n < (1<<(zip_extra_dbits[code]-7)); n++)\\r\\n\\t    zip_dist_code[256 + dist++] = code;\\r\\n    }\\r\\n    // Assert (dist == 256, \\\"ct_init: 256+dist != 512\\\");\\r\\n\\r\\n    // Construct the codes of the static literal tree\\r\\n    for(bits = 0; bits <= zip_MAX_BITS; bits++)\\r\\n\\tzip_bl_count[bits] = 0;\\r\\n    n = 0;\\r\\n    while(n <= 143) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }\\r\\n    while(n <= 255) { zip_static_ltree[n++].dl = 9; zip_bl_count[9]++; }\\r\\n    while(n <= 279) { zip_static_ltree[n++].dl = 7; zip_bl_count[7]++; }\\r\\n    while(n <= 287) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }\\r\\n    /* Codes 286 and 287 do not exist, but we must include them in the\\r\\n     * tree construction to get a canonical Huffman tree (longest code\\r\\n     * all ones)\\r\\n     */\\r\\n    zip_gen_codes(zip_static_ltree, zip_L_CODES + 1);\\r\\n\\r\\n    /* The static distance tree is trivial: */\\r\\n    for(n = 0; n < zip_D_CODES; n++) {\\r\\n\\tzip_static_dtree[n].dl = 5;\\r\\n\\tzip_static_dtree[n].fc = zip_bi_reverse(n, 5);\\r\\n    }\\r\\n\\r\\n    // Initialize the first block of the first file:\\r\\n    zip_init_block();\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Initialize a new block.\\r\\n */\\r\\nvar zip_init_block = function() {\\r\\n    var n; // iterates over tree elements\\r\\n\\r\\n    // Initialize the trees.\\r\\n    for(n = 0; n < zip_L_CODES;  n++) zip_dyn_ltree[n].fc = 0;\\r\\n    for(n = 0; n < zip_D_CODES;  n++) zip_dyn_dtree[n].fc = 0;\\r\\n    for(n = 0; n < zip_BL_CODES; n++) zip_bl_tree[n].fc = 0;\\r\\n\\r\\n    zip_dyn_ltree[zip_END_BLOCK].fc = 1;\\r\\n    zip_opt_len = zip_static_len = 0;\\r\\n    zip_last_lit = zip_last_dist = zip_last_flags = 0;\\r\\n    zip_flags = 0;\\r\\n    zip_flag_bit = 1;\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Restore the heap property by moving down the tree starting at node k,\\r\\n * exchanging a node with the smallest of its two sons if necessary, stopping\\r\\n * when the heap property is re-established (each father smaller than its\\r\\n * two sons).\\r\\n */\\r\\nvar zip_pqdownheap = function(\\r\\n    tree,\\t// the tree to restore\\r\\n    k) {\\t// node to move down\\r\\n    var v = zip_heap[k];\\r\\n    var j = k << 1;\\t// left son of k\\r\\n\\r\\n    while(j <= zip_heap_len) {\\r\\n\\t// Set j to the smallest of the two sons:\\r\\n\\tif(j < zip_heap_len &&\\r\\n\\t   zip_SMALLER(tree, zip_heap[j + 1], zip_heap[j]))\\r\\n\\t    j++;\\r\\n\\r\\n\\t// Exit if v is smaller than both sons\\r\\n\\tif(zip_SMALLER(tree, v, zip_heap[j]))\\r\\n\\t    break;\\r\\n\\r\\n\\t// Exchange v with the smallest son\\r\\n\\tzip_heap[k] = zip_heap[j];\\r\\n\\tk = j;\\r\\n\\r\\n\\t// And continue down the tree, setting j to the left son of k\\r\\n\\tj <<= 1;\\r\\n    }\\r\\n    zip_heap[k] = v;\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Compute the optimal bit lengths for a tree and update the total bit length\\r\\n * for the current block.\\r\\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\\r\\n *    above are the tree nodes sorted by increasing frequency.\\r\\n * OUT assertions: the field len is set to the optimal bit length, the\\r\\n *     array bl_count contains the frequencies for each bit length.\\r\\n *     The length opt_len is updated; static_len is also updated if stree is\\r\\n *     not null.\\r\\n */\\r\\nvar zip_gen_bitlen = function(desc) { // the tree descriptor\\r\\n    var tree\\t\\t= desc.dyn_tree;\\r\\n    var extra\\t\\t= desc.extra_bits;\\r\\n    var base\\t\\t= desc.extra_base;\\r\\n    var max_code\\t= desc.max_code;\\r\\n    var max_length\\t= desc.max_length;\\r\\n    var stree\\t\\t= desc.static_tree;\\r\\n    var h;\\t\\t// heap index\\r\\n    var n, m;\\t\\t// iterate over the tree elements\\r\\n    var bits;\\t\\t// bit length\\r\\n    var xbits;\\t\\t// extra bits\\r\\n    var f;\\t\\t// frequency\\r\\n    var overflow = 0;\\t// number of elements with bit length too large\\r\\n\\r\\n    for(bits = 0; bits <= zip_MAX_BITS; bits++)\\r\\n\\tzip_bl_count[bits] = 0;\\r\\n\\r\\n    /* In a first pass, compute the optimal bit lengths (which may\\r\\n     * overflow in the case of the bit length tree).\\r\\n     */\\r\\n    tree[zip_heap[zip_heap_max]].dl = 0; // root of the heap\\r\\n\\r\\n    for(h = zip_heap_max + 1; h < zip_HEAP_SIZE; h++) {\\r\\n\\tn = zip_heap[h];\\r\\n\\tbits = tree[tree[n].dl].dl + 1;\\r\\n\\tif(bits > max_length) {\\r\\n\\t    bits = max_length;\\r\\n\\t    overflow++;\\r\\n\\t}\\r\\n\\ttree[n].dl = bits;\\r\\n\\t// We overwrite tree[n].dl which is no longer needed\\r\\n\\r\\n\\tif(n > max_code)\\r\\n\\t    continue; // not a leaf node\\r\\n\\r\\n\\tzip_bl_count[bits]++;\\r\\n\\txbits = 0;\\r\\n\\tif(n >= base)\\r\\n\\t    xbits = extra[n - base];\\r\\n\\tf = tree[n].fc;\\r\\n\\tzip_opt_len += f * (bits + xbits);\\r\\n\\tif(stree != null)\\r\\n\\t    zip_static_len += f * (stree[n].dl + xbits);\\r\\n    }\\r\\n    if(overflow == 0)\\r\\n\\treturn;\\r\\n\\r\\n    // This happens for example on obj2 and pic of the Calgary corpus\\r\\n\\r\\n    // Find the first bit length which could increase:\\r\\n    do {\\r\\n\\tbits = max_length - 1;\\r\\n\\twhile(zip_bl_count[bits] == 0)\\r\\n\\t    bits--;\\r\\n\\tzip_bl_count[bits]--;\\t\\t// move one leaf down the tree\\r\\n\\tzip_bl_count[bits + 1] += 2;\\t// move one overflow item as its brother\\r\\n\\tzip_bl_count[max_length]--;\\r\\n\\t/* The brother of the overflow item also moves one step up,\\r\\n\\t * but this does not affect bl_count[max_length]\\r\\n\\t */\\r\\n\\toverflow -= 2;\\r\\n    } while(overflow > 0);\\r\\n\\r\\n    /* Now recompute all bit lengths, scanning in increasing frequency.\\r\\n     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\\r\\n     * lengths instead of fixing only the wrong ones. This idea is taken\\r\\n     * from 'ar' written by Haruhiko Okumura.)\\r\\n     */\\r\\n    for(bits = max_length; bits != 0; bits--) {\\r\\n\\tn = zip_bl_count[bits];\\r\\n\\twhile(n != 0) {\\r\\n\\t    m = zip_heap[--h];\\r\\n\\t    if(m > max_code)\\r\\n\\t\\tcontinue;\\r\\n\\t    if(tree[m].dl != bits) {\\r\\n\\t\\tzip_opt_len += (bits - tree[m].dl) * tree[m].fc;\\r\\n\\t\\ttree[m].fc = bits;\\r\\n\\t    }\\r\\n\\t    n--;\\r\\n\\t}\\r\\n    }\\r\\n}\\r\\n\\r\\n  /* ==========================================================================\\r\\n   * Generate the codes for a given tree and bit counts (which need not be\\r\\n   * optimal).\\r\\n   * IN assertion: the array bl_count contains the bit length statistics for\\r\\n   * the given tree and the field len is set for all tree elements.\\r\\n   * OUT assertion: the field code is set for all tree elements of non\\r\\n   *     zero code length.\\r\\n   */\\r\\nvar zip_gen_codes = function(tree,\\t// the tree to decorate\\r\\n\\t\\t   max_code) {\\t// largest code with non zero frequency\\r\\n    var next_code = new Array(zip_MAX_BITS+1); // next code value for each bit length\\r\\n    var code = 0;\\t\\t// running code value\\r\\n    var bits;\\t\\t\\t// bit index\\r\\n    var n;\\t\\t\\t// code index\\r\\n\\r\\n    /* The distribution counts are first used to generate the code values\\r\\n     * without bit reversal.\\r\\n     */\\r\\n    for(bits = 1; bits <= zip_MAX_BITS; bits++) {\\r\\n\\tcode = ((code + zip_bl_count[bits-1]) << 1);\\r\\n\\tnext_code[bits] = code;\\r\\n    }\\r\\n\\r\\n    /* Check that the bit counts in bl_count are consistent. The last code\\r\\n     * must be all ones.\\r\\n     */\\r\\n//    Assert (code + encoder->bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\\r\\n//\\t    \\\"inconsistent bit counts\\\");\\r\\n//    Tracev((stderr,\\\"\\\\ngen_codes: max_code %d \\\", max_code));\\r\\n\\r\\n    for(n = 0; n <= max_code; n++) {\\r\\n\\tvar len = tree[n].dl;\\r\\n\\tif(len == 0)\\r\\n\\t    continue;\\r\\n\\t// Now reverse the bits\\r\\n\\ttree[n].fc = zip_bi_reverse(next_code[len]++, len);\\r\\n\\r\\n//      Tracec(tree != static_ltree, (stderr,\\\"\\\\nn %3d %c l %2d c %4x (%x) \\\",\\r\\n//\\t  n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));\\r\\n    }\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Construct one Huffman tree and assigns the code bit strings and lengths.\\r\\n * Update the total bit length for the current block.\\r\\n * IN assertion: the field freq is set for all tree elements.\\r\\n * OUT assertions: the fields len and code are set to the optimal bit length\\r\\n *     and corresponding code. The length opt_len is updated; static_len is\\r\\n *     also updated if stree is not null. The field max_code is set.\\r\\n */\\r\\nvar zip_build_tree = function(desc) { // the tree descriptor\\r\\n    var tree\\t= desc.dyn_tree;\\r\\n    var stree\\t= desc.static_tree;\\r\\n    var elems\\t= desc.elems;\\r\\n    var n, m;\\t\\t// iterate over heap elements\\r\\n    var max_code = -1;\\t// largest code with non zero frequency\\r\\n    var node = elems;\\t// next internal node of the tree\\r\\n\\r\\n    /* Construct the initial heap, with least frequent element in\\r\\n     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\\r\\n     * heap[0] is not used.\\r\\n     */\\r\\n    zip_heap_len = 0;\\r\\n    zip_heap_max = zip_HEAP_SIZE;\\r\\n\\r\\n    for(n = 0; n < elems; n++) {\\r\\n\\tif(tree[n].fc != 0) {\\r\\n\\t    zip_heap[++zip_heap_len] = max_code = n;\\r\\n\\t    zip_depth[n] = 0;\\r\\n\\t} else\\r\\n\\t    tree[n].dl = 0;\\r\\n    }\\r\\n\\r\\n    /* The pkzip format requires that at least one distance code exists,\\r\\n     * and that at least one bit should be sent even if there is only one\\r\\n     * possible code. So to avoid special checks later on we force at least\\r\\n     * two codes of non zero frequency.\\r\\n     */\\r\\n    while(zip_heap_len < 2) {\\r\\n\\tvar xnew = zip_heap[++zip_heap_len] = (max_code < 2 ? ++max_code : 0);\\r\\n\\ttree[xnew].fc = 1;\\r\\n\\tzip_depth[xnew] = 0;\\r\\n\\tzip_opt_len--;\\r\\n\\tif(stree != null)\\r\\n\\t    zip_static_len -= stree[xnew].dl;\\r\\n\\t// new is 0 or 1 so it does not have extra bits\\r\\n    }\\r\\n    desc.max_code = max_code;\\r\\n\\r\\n    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\\r\\n     * establish sub-heaps of increasing lengths:\\r\\n     */\\r\\n    for(n = zip_heap_len >> 1; n >= 1; n--)\\r\\n\\tzip_pqdownheap(tree, n);\\r\\n\\r\\n    /* Construct the Huffman tree by repeatedly combining the least two\\r\\n     * frequent nodes.\\r\\n     */\\r\\n    do {\\r\\n\\tn = zip_heap[zip_SMALLEST];\\r\\n\\tzip_heap[zip_SMALLEST] = zip_heap[zip_heap_len--];\\r\\n\\tzip_pqdownheap(tree, zip_SMALLEST);\\r\\n\\r\\n\\tm = zip_heap[zip_SMALLEST];  // m = node of next least frequency\\r\\n\\r\\n\\t// keep the nodes sorted by frequency\\r\\n\\tzip_heap[--zip_heap_max] = n;\\r\\n\\tzip_heap[--zip_heap_max] = m;\\r\\n\\r\\n\\t// Create a new node father of n and m\\r\\n\\ttree[node].fc = tree[n].fc + tree[m].fc;\\r\\n//\\tdepth[node] = (char)(MAX(depth[n], depth[m]) + 1);\\r\\n\\tif(zip_depth[n] > zip_depth[m] + 1)\\r\\n\\t    zip_depth[node] = zip_depth[n];\\r\\n\\telse\\r\\n\\t    zip_depth[node] = zip_depth[m] + 1;\\r\\n\\ttree[n].dl = tree[m].dl = node;\\r\\n\\r\\n\\t// and insert the new node in the heap\\r\\n\\tzip_heap[zip_SMALLEST] = node++;\\r\\n\\tzip_pqdownheap(tree, zip_SMALLEST);\\r\\n\\r\\n    } while(zip_heap_len >= 2);\\r\\n\\r\\n    zip_heap[--zip_heap_max] = zip_heap[zip_SMALLEST];\\r\\n\\r\\n    /* At this point, the fields freq and dad are set. We can now\\r\\n     * generate the bit lengths.\\r\\n     */\\r\\n    zip_gen_bitlen(desc);\\r\\n\\r\\n    // The field len is now set, we can generate the bit codes\\r\\n    zip_gen_codes(tree, max_code);\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Scan a literal or distance tree to determine the frequencies of the codes\\r\\n * in the bit length tree. Updates opt_len to take into account the repeat\\r\\n * counts. (The contribution of the bit length codes will be added later\\r\\n * during the construction of bl_tree.)\\r\\n */\\r\\nvar zip_scan_tree = function(tree,// the tree to be scanned\\r\\n\\t\\t       max_code) {  // and its largest code of non zero frequency\\r\\n    var n;\\t\\t\\t// iterates over all tree elements\\r\\n    var prevlen = -1;\\t\\t// last emitted length\\r\\n    var curlen;\\t\\t\\t// length of current code\\r\\n    var nextlen = tree[0].dl;\\t// length of next code\\r\\n    var count = 0;\\t\\t// repeat count of the current code\\r\\n    var max_count = 7;\\t\\t// max repeat count\\r\\n    var min_count = 4;\\t\\t// min repeat count\\r\\n\\r\\n    if(nextlen == 0) {\\r\\n\\tmax_count = 138;\\r\\n\\tmin_count = 3;\\r\\n    }\\r\\n    tree[max_code + 1].dl = 0xffff; // guard\\r\\n\\r\\n    for(n = 0; n <= max_code; n++) {\\r\\n\\tcurlen = nextlen;\\r\\n\\tnextlen = tree[n + 1].dl;\\r\\n\\tif(++count < max_count && curlen == nextlen)\\r\\n\\t    continue;\\r\\n\\telse if(count < min_count)\\r\\n\\t    zip_bl_tree[curlen].fc += count;\\r\\n\\telse if(curlen != 0) {\\r\\n\\t    if(curlen != prevlen)\\r\\n\\t\\tzip_bl_tree[curlen].fc++;\\r\\n\\t    zip_bl_tree[zip_REP_3_6].fc++;\\r\\n\\t} else if(count <= 10)\\r\\n\\t    zip_bl_tree[zip_REPZ_3_10].fc++;\\r\\n\\telse\\r\\n\\t    zip_bl_tree[zip_REPZ_11_138].fc++;\\r\\n\\tcount = 0; prevlen = curlen;\\r\\n\\tif(nextlen == 0) {\\r\\n\\t    max_count = 138;\\r\\n\\t    min_count = 3;\\r\\n\\t} else if(curlen == nextlen) {\\r\\n\\t    max_count = 6;\\r\\n\\t    min_count = 3;\\r\\n\\t} else {\\r\\n\\t    max_count = 7;\\r\\n\\t    min_count = 4;\\r\\n\\t}\\r\\n    }\\r\\n}\\r\\n\\r\\n  /* ==========================================================================\\r\\n   * Send a literal or distance tree in compressed form, using the codes in\\r\\n   * bl_tree.\\r\\n   */\\r\\nvar zip_send_tree = function(tree, // the tree to be scanned\\r\\n\\t\\t   max_code) { // and its largest code of non zero frequency\\r\\n    var n;\\t\\t\\t// iterates over all tree elements\\r\\n    var prevlen = -1;\\t\\t// last emitted length\\r\\n    var curlen;\\t\\t\\t// length of current code\\r\\n    var nextlen = tree[0].dl;\\t// length of next code\\r\\n    var count = 0;\\t\\t// repeat count of the current code\\r\\n    var max_count = 7;\\t\\t// max repeat count\\r\\n    var min_count = 4;\\t\\t// min repeat count\\r\\n\\r\\n    /* tree[max_code+1].dl = -1; */  /* guard already set */\\r\\n    if(nextlen == 0) {\\r\\n      max_count = 138;\\r\\n      min_count = 3;\\r\\n    }\\r\\n\\r\\n    for(n = 0; n <= max_code; n++) {\\r\\n\\tcurlen = nextlen;\\r\\n\\tnextlen = tree[n+1].dl;\\r\\n\\tif(++count < max_count && curlen == nextlen) {\\r\\n\\t    continue;\\r\\n\\t} else if(count < min_count) {\\r\\n\\t    do { zip_SEND_CODE(curlen, zip_bl_tree); } while(--count != 0);\\r\\n\\t} else if(curlen != 0) {\\r\\n\\t    if(curlen != prevlen) {\\r\\n\\t\\tzip_SEND_CODE(curlen, zip_bl_tree);\\r\\n\\t\\tcount--;\\r\\n\\t    }\\r\\n\\t    // Assert(count >= 3 && count <= 6, \\\" 3_6?\\\");\\r\\n\\t    zip_SEND_CODE(zip_REP_3_6, zip_bl_tree);\\r\\n\\t    zip_send_bits(count - 3, 2);\\r\\n\\t} else if(count <= 10) {\\r\\n\\t    zip_SEND_CODE(zip_REPZ_3_10, zip_bl_tree);\\r\\n\\t    zip_send_bits(count-3, 3);\\r\\n\\t} else {\\r\\n\\t    zip_SEND_CODE(zip_REPZ_11_138, zip_bl_tree);\\r\\n\\t    zip_send_bits(count-11, 7);\\r\\n\\t}\\r\\n\\tcount = 0;\\r\\n\\tprevlen = curlen;\\r\\n\\tif(nextlen == 0) {\\r\\n\\t    max_count = 138;\\r\\n\\t    min_count = 3;\\r\\n\\t} else if(curlen == nextlen) {\\r\\n\\t    max_count = 6;\\r\\n\\t    min_count = 3;\\r\\n\\t} else {\\r\\n\\t    max_count = 7;\\r\\n\\t    min_count = 4;\\r\\n\\t}\\r\\n    }\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Construct the Huffman tree for the bit lengths and return the index in\\r\\n * bl_order of the last bit length code to send.\\r\\n */\\r\\nvar zip_build_bl_tree = function() {\\r\\n    var max_blindex;  // index of last bit length code of non zero freq\\r\\n\\r\\n    // Determine the bit length frequencies for literal and distance trees\\r\\n    zip_scan_tree(zip_dyn_ltree, zip_l_desc.max_code);\\r\\n    zip_scan_tree(zip_dyn_dtree, zip_d_desc.max_code);\\r\\n\\r\\n    // Build the bit length tree:\\r\\n    zip_build_tree(zip_bl_desc);\\r\\n    /* opt_len now includes the length of the tree representations, except\\r\\n     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\\r\\n     */\\r\\n\\r\\n    /* Determine the number of bit length codes to send. The pkzip format\\r\\n     * requires that at least 4 bit length codes be sent. (appnote.txt says\\r\\n     * 3 but the actual value used is 4.)\\r\\n     */\\r\\n    for(max_blindex = zip_BL_CODES-1; max_blindex >= 3; max_blindex--) {\\r\\n\\tif(zip_bl_tree[zip_bl_order[max_blindex]].dl != 0) break;\\r\\n    }\\r\\n    /* Update opt_len to include the bit length tree and counts */\\r\\n    zip_opt_len += 3*(max_blindex+1) + 5+5+4;\\r\\n//    Tracev((stderr, \\\"\\\\ndyn trees: dyn %ld, stat %ld\\\",\\r\\n//\\t    encoder->opt_len, encoder->static_len));\\r\\n\\r\\n    return max_blindex;\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Send the header for a block using dynamic Huffman trees: the counts, the\\r\\n * lengths of the bit length codes, the literal tree and the distance tree.\\r\\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\\r\\n */\\r\\nvar zip_send_all_trees = function(lcodes, dcodes, blcodes) { // number of codes for each tree\\r\\n    var rank; // index in bl_order\\r\\n\\r\\n//    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \\\"not enough codes\\\");\\r\\n//    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\\r\\n//\\t    \\\"too many codes\\\");\\r\\n//    Tracev((stderr, \\\"\\\\nbl counts: \\\"));\\r\\n    zip_send_bits(lcodes-257, 5); // not +255 as stated in appnote.txt\\r\\n    zip_send_bits(dcodes-1,   5);\\r\\n    zip_send_bits(blcodes-4,  4); // not -3 as stated in appnote.txt\\r\\n    for(rank = 0; rank < blcodes; rank++) {\\r\\n//      Tracev((stderr, \\\"\\\\nbl code %2d \\\", bl_order[rank]));\\r\\n\\tzip_send_bits(zip_bl_tree[zip_bl_order[rank]].dl, 3);\\r\\n    }\\r\\n\\r\\n    // send the literal tree\\r\\n    zip_send_tree(zip_dyn_ltree,lcodes-1);\\r\\n\\r\\n    // send the distance tree\\r\\n    zip_send_tree(zip_dyn_dtree,dcodes-1);\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Determine the best encoding for the current block: dynamic trees, static\\r\\n * trees or store, and output the encoded block to the zip file.\\r\\n */\\r\\nvar zip_flush_block = function(eof) { // true if this is the last block for a file\\r\\n    var opt_lenb, static_lenb; // opt_len and static_len in bytes\\r\\n    var max_blindex;\\t// index of last bit length code of non zero freq\\r\\n    var stored_len;\\t// length of input block\\r\\n\\r\\n    stored_len = zip_strstart - zip_block_start;\\r\\n    zip_flag_buf[zip_last_flags] = zip_flags; // Save the flags for the last 8 items\\r\\n\\r\\n    // Construct the literal and distance trees\\r\\n    zip_build_tree(zip_l_desc);\\r\\n//    Tracev((stderr, \\\"\\\\nlit data: dyn %ld, stat %ld\\\",\\r\\n//\\t    encoder->opt_len, encoder->static_len));\\r\\n\\r\\n    zip_build_tree(zip_d_desc);\\r\\n//    Tracev((stderr, \\\"\\\\ndist data: dyn %ld, stat %ld\\\",\\r\\n//\\t    encoder->opt_len, encoder->static_len));\\r\\n    /* At this point, opt_len and static_len are the total bit lengths of\\r\\n     * the compressed block data, excluding the tree representations.\\r\\n     */\\r\\n\\r\\n    /* Build the bit length tree for the above two trees, and get the index\\r\\n     * in bl_order of the last bit length code to send.\\r\\n     */\\r\\n    max_blindex = zip_build_bl_tree();\\r\\n\\r\\n    // Determine the best encoding. Compute first the block length in bytes\\r\\n    opt_lenb\\t= (zip_opt_len   +3+7)>>3;\\r\\n    static_lenb = (zip_static_len+3+7)>>3;\\r\\n\\r\\n//    Trace((stderr, \\\"\\\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u \\\",\\r\\n//\\t   opt_lenb, encoder->opt_len,\\r\\n//\\t   static_lenb, encoder->static_len, stored_len,\\r\\n//\\t   encoder->last_lit, encoder->last_dist));\\r\\n\\r\\n    if(static_lenb <= opt_lenb)\\r\\n\\topt_lenb = static_lenb;\\r\\n    if(stored_len + 4 <= opt_lenb // 4: two words for the lengths\\r\\n       && zip_block_start >= 0) {\\r\\n\\tvar i;\\r\\n\\r\\n\\t/* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\\r\\n\\t * Otherwise we can't have processed more than WSIZE input bytes since\\r\\n\\t * the last block flush, because compression would have been\\r\\n\\t * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\\r\\n\\t * transform a block into a stored block.\\r\\n\\t */\\r\\n\\tzip_send_bits((zip_STORED_BLOCK<<1)+eof, 3);  /* send block type */\\r\\n\\tzip_bi_windup();\\t\\t /* align on byte boundary */\\r\\n\\tzip_put_short(stored_len);\\r\\n\\tzip_put_short(~stored_len);\\r\\n\\r\\n      // copy block\\r\\n/*\\r\\n      p = &window[block_start];\\r\\n      for(i = 0; i < stored_len; i++)\\r\\n\\tput_byte(p[i]);\\r\\n*/\\r\\n\\tfor(i = 0; i < stored_len; i++)\\r\\n\\t    zip_put_byte(zip_window[zip_block_start + i]);\\r\\n\\r\\n    } else if(static_lenb == opt_lenb) {\\r\\n\\tzip_send_bits((zip_STATIC_TREES<<1)+eof, 3);\\r\\n\\tzip_compress_block(zip_static_ltree, zip_static_dtree);\\r\\n    } else {\\r\\n\\tzip_send_bits((zip_DYN_TREES<<1)+eof, 3);\\r\\n\\tzip_send_all_trees(zip_l_desc.max_code+1,\\r\\n\\t\\t\\t   zip_d_desc.max_code+1,\\r\\n\\t\\t\\t   max_blindex+1);\\r\\n\\tzip_compress_block(zip_dyn_ltree, zip_dyn_dtree);\\r\\n    }\\r\\n\\r\\n    zip_init_block();\\r\\n\\r\\n    if(eof != 0)\\r\\n\\tzip_bi_windup();\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Save the match info and tally the frequency counts. Return true if\\r\\n * the current block must be flushed.\\r\\n */\\r\\nvar zip_ct_tally = function(\\r\\n\\tdist, // distance of matched string\\r\\n\\tlc) { // match length-MIN_MATCH or unmatched char (if dist==0)\\r\\n    zip_l_buf[zip_last_lit++] = lc;\\r\\n    if(dist == 0) {\\r\\n\\t// lc is the unmatched char\\r\\n\\tzip_dyn_ltree[lc].fc++;\\r\\n    } else {\\r\\n\\t// Here, lc is the match length - MIN_MATCH\\r\\n\\tdist--;\\t\\t    // dist = match distance - 1\\r\\n//      Assert((ush)dist < (ush)MAX_DIST &&\\r\\n//\\t     (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\\r\\n//\\t     (ush)D_CODE(dist) < (ush)D_CODES,  \\\"ct_tally: bad match\\\");\\r\\n\\r\\n\\tzip_dyn_ltree[zip_length_code[lc]+zip_LITERALS+1].fc++;\\r\\n\\tzip_dyn_dtree[zip_D_CODE(dist)].fc++;\\r\\n\\r\\n\\tzip_d_buf[zip_last_dist++] = dist;\\r\\n\\tzip_flags |= zip_flag_bit;\\r\\n    }\\r\\n    zip_flag_bit <<= 1;\\r\\n\\r\\n    // Output the flags if they fill a byte\\r\\n    if((zip_last_lit & 7) == 0) {\\r\\n\\tzip_flag_buf[zip_last_flags++] = zip_flags;\\r\\n\\tzip_flags = 0;\\r\\n\\tzip_flag_bit = 1;\\r\\n    }\\r\\n    // Try to guess if it is profitable to stop the current block here\\r\\n    if(zip_compr_level > 2 && (zip_last_lit & 0xfff) == 0) {\\r\\n\\t// Compute an upper bound for the compressed length\\r\\n\\tvar out_length = zip_last_lit * 8;\\r\\n\\tvar in_length = zip_strstart - zip_block_start;\\r\\n\\tvar dcode;\\r\\n\\r\\n\\tfor(dcode = 0; dcode < zip_D_CODES; dcode++) {\\r\\n\\t    out_length += zip_dyn_dtree[dcode].fc * (5 + zip_extra_dbits[dcode]);\\r\\n\\t}\\r\\n\\tout_length >>= 3;\\r\\n//      Trace((stderr,\\\"\\\\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) \\\",\\r\\n//\\t     encoder->last_lit, encoder->last_dist, in_length, out_length,\\r\\n//\\t     100L - out_length*100L/in_length));\\r\\n\\tif(zip_last_dist < parseInt(zip_last_lit/2) &&\\r\\n\\t   out_length < parseInt(in_length/2))\\r\\n\\t    return true;\\r\\n    }\\r\\n    return (zip_last_lit == zip_LIT_BUFSIZE-1 ||\\r\\n\\t    zip_last_dist == zip_DIST_BUFSIZE);\\r\\n    /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K\\r\\n     * on 16 bit machines and because stored blocks are restricted to\\r\\n     * 64K-1 bytes.\\r\\n     */\\r\\n}\\r\\n\\r\\n  /* ==========================================================================\\r\\n   * Send the block data compressed using the given Huffman trees\\r\\n   */\\r\\nvar zip_compress_block = function(\\r\\n\\tltree,\\t// literal tree\\r\\n\\tdtree) {\\t// distance tree\\r\\n    var dist;\\t\\t// distance of matched string\\r\\n    var lc;\\t\\t// match length or unmatched char (if dist == 0)\\r\\n    var lx = 0;\\t\\t// running index in l_buf\\r\\n    var dx = 0;\\t\\t// running index in d_buf\\r\\n    var fx = 0;\\t\\t// running index in flag_buf\\r\\n    var flag = 0;\\t// current flags\\r\\n    var code;\\t\\t// the code to send\\r\\n    var extra;\\t\\t// number of extra bits to send\\r\\n\\r\\n    if(zip_last_lit != 0) do {\\r\\n\\tif((lx & 7) == 0)\\r\\n\\t    flag = zip_flag_buf[fx++];\\r\\n\\tlc = zip_l_buf[lx++] & 0xff;\\r\\n\\tif((flag & 1) == 0) {\\r\\n\\t    zip_SEND_CODE(lc, ltree); /* send a literal byte */\\r\\n//\\tTracecv(isgraph(lc), (stderr,\\\" '%c' \\\", lc));\\r\\n\\t} else {\\r\\n\\t    // Here, lc is the match length - MIN_MATCH\\r\\n\\t    code = zip_length_code[lc];\\r\\n\\t    zip_SEND_CODE(code+zip_LITERALS+1, ltree); // send the length code\\r\\n\\t    extra = zip_extra_lbits[code];\\r\\n\\t    if(extra != 0) {\\r\\n\\t\\tlc -= zip_base_length[code];\\r\\n\\t\\tzip_send_bits(lc, extra); // send the extra length bits\\r\\n\\t    }\\r\\n\\t    dist = zip_d_buf[dx++];\\r\\n\\t    // Here, dist is the match distance - 1\\r\\n\\t    code = zip_D_CODE(dist);\\r\\n//\\tAssert (code < D_CODES, \\\"bad d_code\\\");\\r\\n\\r\\n\\t    zip_SEND_CODE(code, dtree);\\t  // send the distance code\\r\\n\\t    extra = zip_extra_dbits[code];\\r\\n\\t    if(extra != 0) {\\r\\n\\t\\tdist -= zip_base_dist[code];\\r\\n\\t\\tzip_send_bits(dist, extra);   // send the extra distance bits\\r\\n\\t    }\\r\\n\\t} // literal or match pair ?\\r\\n\\tflag >>= 1;\\r\\n    } while(lx < zip_last_lit);\\r\\n\\r\\n    zip_SEND_CODE(zip_END_BLOCK, ltree);\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Send a value on a given number of bits.\\r\\n * IN assertion: length <= 16 and value fits in length bits.\\r\\n */\\r\\nvar zip_Buf_size = 16; // bit size of bi_buf\\r\\nvar zip_send_bits = function(\\r\\n\\tvalue,\\t// value to send\\r\\n\\tlength) {\\t// number of bits\\r\\n    /* If not enough room in bi_buf, use (valid) bits from bi_buf and\\r\\n     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))\\r\\n     * unused bits in value.\\r\\n     */\\r\\n    if(zip_bi_valid > zip_Buf_size - length) {\\r\\n\\tzip_bi_buf |= (value << zip_bi_valid);\\r\\n\\tzip_put_short(zip_bi_buf);\\r\\n\\tzip_bi_buf = (value >> (zip_Buf_size - zip_bi_valid));\\r\\n\\tzip_bi_valid += length - zip_Buf_size;\\r\\n    } else {\\r\\n\\tzip_bi_buf |= value << zip_bi_valid;\\r\\n\\tzip_bi_valid += length;\\r\\n    }\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Reverse the first len bits of a code, using straightforward code (a faster\\r\\n * method would use a table)\\r\\n * IN assertion: 1 <= len <= 15\\r\\n */\\r\\nvar zip_bi_reverse = function(\\r\\n\\tcode,\\t// the value to invert\\r\\n\\tlen) {\\t// its bit length\\r\\n    var res = 0;\\r\\n    do {\\r\\n\\tres |= code & 1;\\r\\n\\tcode >>= 1;\\r\\n\\tres <<= 1;\\r\\n    } while(--len > 0);\\r\\n    return res >> 1;\\r\\n}\\r\\n\\r\\n/* ==========================================================================\\r\\n * Write out any remaining bits in an incomplete byte.\\r\\n */\\r\\nvar zip_bi_windup = function() {\\r\\n    if(zip_bi_valid > 8) {\\r\\n\\tzip_put_short(zip_bi_buf);\\r\\n    } else if(zip_bi_valid > 0) {\\r\\n\\tzip_put_byte(zip_bi_buf);\\r\\n    }\\r\\n    zip_bi_buf = 0;\\r\\n    zip_bi_valid = 0;\\r\\n}\\r\\n\\r\\nvar zip_qoutbuf = function() {\\r\\n    if(zip_outcnt != 0) {\\r\\n\\tvar q, i;\\r\\n\\tq = zip_new_queue();\\r\\n\\tif(zip_qhead == null)\\r\\n\\t    zip_qhead = zip_qtail = q;\\r\\n\\telse\\r\\n\\t    zip_qtail = zip_qtail.next = q;\\r\\n\\tq.len = zip_outcnt - zip_outoff;\\r\\n//      System.arraycopy(zip_outbuf, zip_outoff, q.ptr, 0, q.len);\\r\\n\\tfor(i = 0; i < q.len; i++)\\r\\n\\t    q.ptr[i] = zip_outbuf[zip_outoff + i];\\r\\n\\tzip_outcnt = zip_outoff = 0;\\r\\n    }\\r\\n}\\r\\n\\r\\nvar zip_deflate = function(str, level) {\\r\\n    var i, j;\\r\\n\\r\\n    zip_deflate_data = str;\\r\\n    zip_deflate_pos = 0;\\r\\n    if(typeof level == \\\"undefined\\\")\\r\\n\\tlevel = zip_DEFAULT_LEVEL;\\r\\n    zip_deflate_start(level);\\r\\n\\r\\n    var buff = new Array(1024);\\r\\n    var aout = [];\\r\\n    while((i = zip_deflate_internal(buff, 0, buff.length)) > 0) {\\r\\n\\tvar cbuf = new Array(i);\\r\\n\\tfor(j = 0; j < i; j++){\\r\\n\\t    cbuf[j] = String.fromCharCode(buff[j]);\\r\\n\\t}\\r\\n\\taout[aout.length] = cbuf.join(\\\"\\\");\\r\\n    }\\r\\n    zip_deflate_data = null; // G.C.\\r\\n    return aout.join(\\\"\\\");\\r\\n}\\r\\n\\r\\nif (! ctx.RawDeflate) ctx.RawDeflate = {};\\r\\nctx.RawDeflate.deflate = zip_deflate;\\r\\n\\r\\n})(this);\\r\\n\""
		},
		{
			"name": "rawinflate.js",
			"source": "\"/*\\r\\n * $Id: rawinflate.js,v 0.3 2013/04/09 14:25:38 dankogai Exp dankogai $\\r\\n *\\r\\n * GNU General Public License, version 2 (GPL-2.0)\\r\\n *   http://opensource.org/licenses/GPL-2.0\\r\\n * original:\\r\\n *   http://www.onicos.com/staff/iz/amuse/javascript/expert/inflate.txt\\r\\n */\\r\\n\\r\\n(function(ctx){\\r\\n\\r\\n/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\\r\\n * Version: 1.0.0.1\\r\\n * LastModified: Dec 25 1999\\r\\n */\\r\\n\\r\\n/* Interface:\\r\\n * data = zip_inflate(src);\\r\\n */\\r\\n\\r\\n/* constant parameters */\\r\\nvar zip_WSIZE = 32768;\\t\\t// Sliding Window size\\r\\nvar zip_STORED_BLOCK = 0;\\r\\nvar zip_STATIC_TREES = 1;\\r\\nvar zip_DYN_TREES    = 2;\\r\\n\\r\\n/* for inflate */\\r\\nvar zip_lbits = 9; \\t\\t// bits in base literal/length lookup table\\r\\nvar zip_dbits = 6; \\t\\t// bits in base distance lookup table\\r\\nvar zip_INBUFSIZ = 32768;\\t// Input buffer size\\r\\nvar zip_INBUF_EXTRA = 64;\\t// Extra buffer\\r\\n\\r\\n/* variables (inflate) */\\r\\nvar zip_slide;\\r\\nvar zip_wp;\\t\\t\\t// current position in slide\\r\\nvar zip_fixed_tl = null;\\t// inflate static\\r\\nvar zip_fixed_td;\\t\\t// inflate static\\r\\nvar zip_fixed_bl, zip_fixed_bd;\\t// inflate static\\r\\nvar zip_bit_buf;\\t\\t// bit buffer\\r\\nvar zip_bit_len;\\t\\t// bits in bit buffer\\r\\nvar zip_method;\\r\\nvar zip_eof;\\r\\nvar zip_copy_leng;\\r\\nvar zip_copy_dist;\\r\\nvar zip_tl, zip_td;\\t// literal/length and distance decoder tables\\r\\nvar zip_bl, zip_bd;\\t// number of bits decoded by tl and td\\r\\n\\r\\nvar zip_inflate_data;\\r\\nvar zip_inflate_pos;\\r\\n\\r\\n\\r\\n/* constant tables (inflate) */\\r\\nvar zip_MASK_BITS = new Array(\\r\\n    0x0000,\\r\\n    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,\\r\\n    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff);\\r\\n// Tables for deflate from PKZIP's appnote.txt.\\r\\nvar zip_cplens = new Array( // Copy lengths for literal codes 257..285\\r\\n    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\\r\\n    35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0);\\r\\n/* note: see note #13 above about the 258 in this list. */\\r\\nvar zip_cplext = new Array( // Extra bits for literal codes 257..285\\r\\n    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\\r\\n    3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99); // 99==invalid\\r\\nvar zip_cpdist = new Array( // Copy offsets for distance codes 0..29\\r\\n    1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\\r\\n    257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\\r\\n    8193, 12289, 16385, 24577);\\r\\nvar zip_cpdext = new Array( // Extra bits for distance codes\\r\\n    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\\r\\n    7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\\r\\n    12, 12, 13, 13);\\r\\nvar zip_border = new Array(  // Order of the bit length code lengths\\r\\n    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15);\\r\\n/* objects (inflate) */\\r\\n\\r\\nvar zip_HuftList = function() {\\r\\n    this.next = null;\\r\\n    this.list = null;\\r\\n}\\r\\n\\r\\nvar zip_HuftNode = function() {\\r\\n    this.e = 0; // number of extra bits or operation\\r\\n    this.b = 0; // number of bits in this code or subcode\\r\\n\\r\\n    // union\\r\\n    this.n = 0; // literal, length base, or distance base\\r\\n    this.t = null; // (zip_HuftNode) pointer to next level of table\\r\\n}\\r\\n\\r\\nvar zip_HuftBuild = function(b,\\t// code lengths in bits (all assumed <= BMAX)\\r\\n\\t\\t       n,\\t// number of codes (assumed <= N_MAX)\\r\\n\\t\\t       s,\\t// number of simple-valued codes (0..s-1)\\r\\n\\t\\t       d,\\t// list of base values for non-simple codes\\r\\n\\t\\t       e,\\t// list of extra bits for non-simple codes\\r\\n\\t\\t       mm\\t// maximum lookup bits\\r\\n\\t\\t   ) {\\r\\n    this.BMAX = 16;   // maximum bit length of any code\\r\\n    this.N_MAX = 288; // maximum number of codes in any set\\r\\n    this.status = 0;\\t// 0: success, 1: incomplete table, 2: bad input\\r\\n    this.root = null;\\t// (zip_HuftList) starting table\\r\\n    this.m = 0;\\t\\t// maximum lookup bits, returns actual\\r\\n\\r\\n/* Given a list of code lengths and a maximum table size, make a set of\\r\\n   tables to decode that set of codes.\\tReturn zero on success, one if\\r\\n   the given code set is incomplete (the tables are still built in this\\r\\n   case), two if the input is invalid (all zero length codes or an\\r\\n   oversubscribed set of lengths), and three if not enough memory.\\r\\n   The code with value 256 is special, and the tables are constructed\\r\\n   so that no bits beyond that code are fetched when that code is\\r\\n   decoded. */\\r\\n    {\\r\\n\\tvar a;\\t\\t\\t// counter for codes of length k\\r\\n\\tvar c = new Array(this.BMAX+1);\\t// bit length count table\\r\\n\\tvar el;\\t\\t\\t// length of EOB code (value 256)\\r\\n\\tvar f;\\t\\t\\t// i repeats in table every f entries\\r\\n\\tvar g;\\t\\t\\t// maximum code length\\r\\n\\tvar h;\\t\\t\\t// table level\\r\\n\\tvar i;\\t\\t\\t// counter, current code\\r\\n\\tvar j;\\t\\t\\t// counter\\r\\n\\tvar k;\\t\\t\\t// number of bits in current code\\r\\n\\tvar lx = new Array(this.BMAX+1);\\t// stack of bits per table\\r\\n\\tvar p;\\t\\t\\t// pointer into c[], b[], or v[]\\r\\n\\tvar pidx;\\t\\t// index of p\\r\\n\\tvar q;\\t\\t\\t// (zip_HuftNode) points to current table\\r\\n\\tvar r = new zip_HuftNode(); // table entry for structure assignment\\r\\n\\tvar u = new Array(this.BMAX); // zip_HuftNode[BMAX][]  table stack\\r\\n\\tvar v = new Array(this.N_MAX); // values in order of bit length\\r\\n\\tvar w;\\r\\n\\tvar x = new Array(this.BMAX+1);// bit offsets, then code stack\\r\\n\\tvar xp;\\t\\t\\t// pointer into x or c\\r\\n\\tvar y;\\t\\t\\t// number of dummy codes added\\r\\n\\tvar z;\\t\\t\\t// number of entries in current table\\r\\n\\tvar o;\\r\\n\\tvar tail;\\t\\t// (zip_HuftList)\\r\\n\\r\\n\\ttail = this.root = null;\\r\\n\\tfor(i = 0; i < c.length; i++)\\r\\n\\t    c[i] = 0;\\r\\n\\tfor(i = 0; i < lx.length; i++)\\r\\n\\t    lx[i] = 0;\\r\\n\\tfor(i = 0; i < u.length; i++)\\r\\n\\t    u[i] = null;\\r\\n\\tfor(i = 0; i < v.length; i++)\\r\\n\\t    v[i] = 0;\\r\\n\\tfor(i = 0; i < x.length; i++)\\r\\n\\t    x[i] = 0;\\r\\n\\r\\n\\t// Generate counts for each bit length\\r\\n\\tel = n > 256 ? b[256] : this.BMAX; // set length of EOB code, if any\\r\\n\\tp = b; pidx = 0;\\r\\n\\ti = n;\\r\\n\\tdo {\\r\\n\\t    c[p[pidx]]++;\\t// assume all entries <= BMAX\\r\\n\\t    pidx++;\\r\\n\\t} while(--i > 0);\\r\\n\\tif(c[0] == n) {\\t// null input--all zero length codes\\r\\n\\t    this.root = null;\\r\\n\\t    this.m = 0;\\r\\n\\t    this.status = 0;\\r\\n\\t    return;\\r\\n\\t}\\r\\n\\r\\n\\t// Find minimum and maximum length, bound *m by those\\r\\n\\tfor(j = 1; j <= this.BMAX; j++)\\r\\n\\t    if(c[j] != 0)\\r\\n\\t\\tbreak;\\r\\n\\tk = j;\\t\\t\\t// minimum code length\\r\\n\\tif(mm < j)\\r\\n\\t    mm = j;\\r\\n\\tfor(i = this.BMAX; i != 0; i--)\\r\\n\\t    if(c[i] != 0)\\r\\n\\t\\tbreak;\\r\\n\\tg = i;\\t\\t\\t// maximum code length\\r\\n\\tif(mm > i)\\r\\n\\t    mm = i;\\r\\n\\r\\n\\t// Adjust last length count to fill out codes, if needed\\r\\n\\tfor(y = 1 << j; j < i; j++, y <<= 1)\\r\\n\\t    if((y -= c[j]) < 0) {\\r\\n\\t\\tthis.status = 2;\\t// bad input: more codes than bits\\r\\n\\t\\tthis.m = mm;\\r\\n\\t\\treturn;\\r\\n\\t    }\\r\\n\\tif((y -= c[i]) < 0) {\\r\\n\\t    this.status = 2;\\r\\n\\t    this.m = mm;\\r\\n\\t    return;\\r\\n\\t}\\r\\n\\tc[i] += y;\\r\\n\\r\\n\\t// Generate starting offsets into the value table for each length\\r\\n\\tx[1] = j = 0;\\r\\n\\tp = c;\\r\\n\\tpidx = 1;\\r\\n\\txp = 2;\\r\\n\\twhile(--i > 0)\\t\\t// note that i == g from above\\r\\n\\t    x[xp++] = (j += p[pidx++]);\\r\\n\\r\\n\\t// Make a table of values in order of bit lengths\\r\\n\\tp = b; pidx = 0;\\r\\n\\ti = 0;\\r\\n\\tdo {\\r\\n\\t    if((j = p[pidx++]) != 0)\\r\\n\\t\\tv[x[j]++] = i;\\r\\n\\t} while(++i < n);\\r\\n\\tn = x[g];\\t\\t\\t// set n to length of v\\r\\n\\r\\n\\t// Generate the Huffman codes and for each, make the table entries\\r\\n\\tx[0] = i = 0;\\t\\t// first Huffman code is zero\\r\\n\\tp = v; pidx = 0;\\t\\t// grab values in bit order\\r\\n\\th = -1;\\t\\t\\t// no tables yet--level -1\\r\\n\\tw = lx[0] = 0;\\t\\t// no bits decoded yet\\r\\n\\tq = null;\\t\\t\\t// ditto\\r\\n\\tz = 0;\\t\\t\\t// ditto\\r\\n\\r\\n\\t// go through the bit lengths (k already is bits in shortest code)\\r\\n\\tfor(; k <= g; k++) {\\r\\n\\t    a = c[k];\\r\\n\\t    while(a-- > 0) {\\r\\n\\t\\t// here i is the Huffman code of length k bits for value p[pidx]\\r\\n\\t\\t// make tables up to required level\\r\\n\\t\\twhile(k > w + lx[1 + h]) {\\r\\n\\t\\t    w += lx[1 + h]; // add bits already decoded\\r\\n\\t\\t    h++;\\r\\n\\r\\n\\t\\t    // compute minimum size table less than or equal to *m bits\\r\\n\\t\\t    z = (z = g - w) > mm ? mm : z; // upper limit\\r\\n\\t\\t    if((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table\\r\\n\\t\\t\\t// too few codes for k-w bit table\\r\\n\\t\\t\\tf -= a + 1;\\t// deduct codes from patterns left\\r\\n\\t\\t\\txp = k;\\r\\n\\t\\t\\twhile(++j < z) { // try smaller tables up to z bits\\r\\n\\t\\t\\t    if((f <<= 1) <= c[++xp])\\r\\n\\t\\t\\t\\tbreak;\\t// enough codes to use up j bits\\r\\n\\t\\t\\t    f -= c[xp];\\t// else deduct codes from patterns\\r\\n\\t\\t\\t}\\r\\n\\t\\t    }\\r\\n\\t\\t    if(w + j > el && w < el)\\r\\n\\t\\t\\tj = el - w;\\t// make EOB code end at table\\r\\n\\t\\t    z = 1 << j;\\t// table entries for j-bit table\\r\\n\\t\\t    lx[1 + h] = j; // set table size in stack\\r\\n\\r\\n\\t\\t    // allocate and link in new table\\r\\n\\t\\t    q = new Array(z);\\r\\n\\t\\t    for(o = 0; o < z; o++) {\\r\\n\\t\\t\\tq[o] = new zip_HuftNode();\\r\\n\\t\\t    }\\r\\n\\r\\n\\t\\t    if(tail == null)\\r\\n\\t\\t\\ttail = this.root = new zip_HuftList();\\r\\n\\t\\t    else\\r\\n\\t\\t\\ttail = tail.next = new zip_HuftList();\\r\\n\\t\\t    tail.next = null;\\r\\n\\t\\t    tail.list = q;\\r\\n\\t\\t    u[h] = q;\\t// table starts after link\\r\\n\\r\\n\\t\\t    /* connect to last table, if there is one */\\r\\n\\t\\t    if(h > 0) {\\r\\n\\t\\t\\tx[h] = i;\\t\\t// save pattern for backing up\\r\\n\\t\\t\\tr.b = lx[h];\\t// bits to dump before this table\\r\\n\\t\\t\\tr.e = 16 + j;\\t// bits in this table\\r\\n\\t\\t\\tr.t = q;\\t\\t// pointer to this table\\r\\n\\t\\t\\tj = (i & ((1 << w) - 1)) >> (w - lx[h]);\\r\\n\\t\\t\\tu[h-1][j].e = r.e;\\r\\n\\t\\t\\tu[h-1][j].b = r.b;\\r\\n\\t\\t\\tu[h-1][j].n = r.n;\\r\\n\\t\\t\\tu[h-1][j].t = r.t;\\r\\n\\t\\t    }\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// set up table entry in r\\r\\n\\t\\tr.b = k - w;\\r\\n\\t\\tif(pidx >= n)\\r\\n\\t\\t    r.e = 99;\\t\\t// out of values--invalid code\\r\\n\\t\\telse if(p[pidx] < s) {\\r\\n\\t\\t    r.e = (p[pidx] < 256 ? 16 : 15); // 256 is end-of-block code\\r\\n\\t\\t    r.n = p[pidx++];\\t// simple code is just the value\\r\\n\\t\\t} else {\\r\\n\\t\\t    r.e = e[p[pidx] - s];\\t// non-simple--look up in lists\\r\\n\\t\\t    r.n = d[p[pidx++] - s];\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// fill code-like entries with r //\\r\\n\\t\\tf = 1 << (k - w);\\r\\n\\t\\tfor(j = i >> w; j < z; j += f) {\\r\\n\\t\\t    q[j].e = r.e;\\r\\n\\t\\t    q[j].b = r.b;\\r\\n\\t\\t    q[j].n = r.n;\\r\\n\\t\\t    q[j].t = r.t;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// backwards increment the k-bit code i\\r\\n\\t\\tfor(j = 1 << (k - 1); (i & j) != 0; j >>= 1)\\r\\n\\t\\t    i ^= j;\\r\\n\\t\\ti ^= j;\\r\\n\\r\\n\\t\\t// backup over finished tables\\r\\n\\t\\twhile((i & ((1 << w) - 1)) != x[h]) {\\r\\n\\t\\t    w -= lx[h];\\t\\t// don't need to update q\\r\\n\\t\\t    h--;\\r\\n\\t\\t}\\r\\n\\t    }\\r\\n\\t}\\r\\n\\r\\n\\t/* return actual size of base table */\\r\\n\\tthis.m = lx[1];\\r\\n\\r\\n\\t/* Return true (1) if we were given an incomplete table */\\r\\n\\tthis.status = ((y != 0 && g != 1) ? 1 : 0);\\r\\n    } /* end of constructor */\\r\\n}\\r\\n\\r\\n\\r\\n/* routines (inflate) */\\r\\n\\r\\nvar zip_GET_BYTE = function() {\\r\\n    if(zip_inflate_data.length == zip_inflate_pos)\\r\\n\\treturn -1;\\r\\n    return zip_inflate_data.charCodeAt(zip_inflate_pos++) & 0xff;\\r\\n}\\r\\n\\r\\nvar zip_NEEDBITS = function(n) {\\r\\n    while(zip_bit_len < n) {\\r\\n\\tzip_bit_buf |= zip_GET_BYTE() << zip_bit_len;\\r\\n\\tzip_bit_len += 8;\\r\\n    }\\r\\n}\\r\\n\\r\\nvar zip_GETBITS = function(n) {\\r\\n    return zip_bit_buf & zip_MASK_BITS[n];\\r\\n}\\r\\n\\r\\nvar zip_DUMPBITS = function(n) {\\r\\n    zip_bit_buf >>= n;\\r\\n    zip_bit_len -= n;\\r\\n}\\r\\n\\r\\nvar zip_inflate_codes = function(buff, off, size) {\\r\\n    /* inflate (decompress) the codes in a deflated (compressed) block.\\r\\n       Return an error code or zero if it all goes ok. */\\r\\n    var e;\\t\\t// table entry flag/number of extra bits\\r\\n    var t;\\t\\t// (zip_HuftNode) pointer to table entry\\r\\n    var n;\\r\\n\\r\\n    if(size == 0)\\r\\n      return 0;\\r\\n\\r\\n    // inflate the coded data\\r\\n    n = 0;\\r\\n    for(;;) {\\t\\t\\t// do until end of block\\r\\n\\tzip_NEEDBITS(zip_bl);\\r\\n\\tt = zip_tl.list[zip_GETBITS(zip_bl)];\\r\\n\\te = t.e;\\r\\n\\twhile(e > 16) {\\r\\n\\t    if(e == 99)\\r\\n\\t\\treturn -1;\\r\\n\\t    zip_DUMPBITS(t.b);\\r\\n\\t    e -= 16;\\r\\n\\t    zip_NEEDBITS(e);\\r\\n\\t    t = t.t[zip_GETBITS(e)];\\r\\n\\t    e = t.e;\\r\\n\\t}\\r\\n\\tzip_DUMPBITS(t.b);\\r\\n\\r\\n\\tif(e == 16) {\\t\\t// then it's a literal\\r\\n\\t    zip_wp &= zip_WSIZE - 1;\\r\\n\\t    buff[off + n++] = zip_slide[zip_wp++] = t.n;\\r\\n\\t    if(n == size)\\r\\n\\t\\treturn size;\\r\\n\\t    continue;\\r\\n\\t}\\r\\n\\r\\n\\t// exit if end of block\\r\\n\\tif(e == 15)\\r\\n\\t    break;\\r\\n\\r\\n\\t// it's an EOB or a length\\r\\n\\r\\n\\t// get length of block to copy\\r\\n\\tzip_NEEDBITS(e);\\r\\n\\tzip_copy_leng = t.n + zip_GETBITS(e);\\r\\n\\tzip_DUMPBITS(e);\\r\\n\\r\\n\\t// decode distance of block to copy\\r\\n\\tzip_NEEDBITS(zip_bd);\\r\\n\\tt = zip_td.list[zip_GETBITS(zip_bd)];\\r\\n\\te = t.e;\\r\\n\\r\\n\\twhile(e > 16) {\\r\\n\\t    if(e == 99)\\r\\n\\t\\treturn -1;\\r\\n\\t    zip_DUMPBITS(t.b);\\r\\n\\t    e -= 16;\\r\\n\\t    zip_NEEDBITS(e);\\r\\n\\t    t = t.t[zip_GETBITS(e)];\\r\\n\\t    e = t.e;\\r\\n\\t}\\r\\n\\tzip_DUMPBITS(t.b);\\r\\n\\tzip_NEEDBITS(e);\\r\\n\\tzip_copy_dist = zip_wp - t.n - zip_GETBITS(e);\\r\\n\\tzip_DUMPBITS(e);\\r\\n\\r\\n\\t// do the copy\\r\\n\\twhile(zip_copy_leng > 0 && n < size) {\\r\\n\\t    zip_copy_leng--;\\r\\n\\t    zip_copy_dist &= zip_WSIZE - 1;\\r\\n\\t    zip_wp &= zip_WSIZE - 1;\\r\\n\\t    buff[off + n++] = zip_slide[zip_wp++]\\r\\n\\t\\t= zip_slide[zip_copy_dist++];\\r\\n\\t}\\r\\n\\r\\n\\tif(n == size)\\r\\n\\t    return size;\\r\\n    }\\r\\n\\r\\n    zip_method = -1; // done\\r\\n    return n;\\r\\n}\\r\\n\\r\\nvar zip_inflate_stored = function(buff, off, size) {\\r\\n    /* \\\"decompress\\\" an inflated type 0 (stored) block. */\\r\\n    var n;\\r\\n\\r\\n    // go to byte boundary\\r\\n    n = zip_bit_len & 7;\\r\\n    zip_DUMPBITS(n);\\r\\n\\r\\n    // get the length and its complement\\r\\n    zip_NEEDBITS(16);\\r\\n    n = zip_GETBITS(16);\\r\\n    zip_DUMPBITS(16);\\r\\n    zip_NEEDBITS(16);\\r\\n    if(n != ((~zip_bit_buf) & 0xffff))\\r\\n\\treturn -1;\\t\\t\\t// error in compressed data\\r\\n    zip_DUMPBITS(16);\\r\\n\\r\\n    // read and output the compressed data\\r\\n    zip_copy_leng = n;\\r\\n\\r\\n    n = 0;\\r\\n    while(zip_copy_leng > 0 && n < size) {\\r\\n\\tzip_copy_leng--;\\r\\n\\tzip_wp &= zip_WSIZE - 1;\\r\\n\\tzip_NEEDBITS(8);\\r\\n\\tbuff[off + n++] = zip_slide[zip_wp++] =\\r\\n\\t    zip_GETBITS(8);\\r\\n\\tzip_DUMPBITS(8);\\r\\n    }\\r\\n\\r\\n    if(zip_copy_leng == 0)\\r\\n      zip_method = -1; // done\\r\\n    return n;\\r\\n}\\r\\n\\r\\nvar zip_inflate_fixed = function(buff, off, size) {\\r\\n    /* decompress an inflated type 1 (fixed Huffman codes) block.  We should\\r\\n       either replace this with a custom decoder, or at least precompute the\\r\\n       Huffman tables. */\\r\\n\\r\\n    // if first time, set up tables for fixed blocks\\r\\n    if(zip_fixed_tl == null) {\\r\\n\\tvar i;\\t\\t\\t// temporary variable\\r\\n\\tvar l = new Array(288);\\t// length list for huft_build\\r\\n\\tvar h;\\t// zip_HuftBuild\\r\\n\\r\\n\\t// literal table\\r\\n\\tfor(i = 0; i < 144; i++)\\r\\n\\t    l[i] = 8;\\r\\n\\tfor(; i < 256; i++)\\r\\n\\t    l[i] = 9;\\r\\n\\tfor(; i < 280; i++)\\r\\n\\t    l[i] = 7;\\r\\n\\tfor(; i < 288; i++)\\t// make a complete, but wrong code set\\r\\n\\t    l[i] = 8;\\r\\n\\tzip_fixed_bl = 7;\\r\\n\\r\\n\\th = new zip_HuftBuild(l, 288, 257, zip_cplens, zip_cplext,\\r\\n\\t\\t\\t      zip_fixed_bl);\\r\\n\\tif(h.status != 0) {\\r\\n\\t    alert(\\\"HufBuild error: \\\"+h.status);\\r\\n\\t    return -1;\\r\\n\\t}\\r\\n\\tzip_fixed_tl = h.root;\\r\\n\\tzip_fixed_bl = h.m;\\r\\n\\r\\n\\t// distance table\\r\\n\\tfor(i = 0; i < 30; i++)\\t// make an incomplete code set\\r\\n\\t    l[i] = 5;\\r\\n\\tzip_fixed_bd = 5;\\r\\n\\r\\n\\th = new zip_HuftBuild(l, 30, 0, zip_cpdist, zip_cpdext, zip_fixed_bd);\\r\\n\\tif(h.status > 1) {\\r\\n\\t    zip_fixed_tl = null;\\r\\n\\t    alert(\\\"HufBuild error: \\\"+h.status);\\r\\n\\t    return -1;\\r\\n\\t}\\r\\n\\tzip_fixed_td = h.root;\\r\\n\\tzip_fixed_bd = h.m;\\r\\n    }\\r\\n\\r\\n    zip_tl = zip_fixed_tl;\\r\\n    zip_td = zip_fixed_td;\\r\\n    zip_bl = zip_fixed_bl;\\r\\n    zip_bd = zip_fixed_bd;\\r\\n    return zip_inflate_codes(buff, off, size);\\r\\n}\\r\\n\\r\\nvar zip_inflate_dynamic = function(buff, off, size) {\\r\\n    // decompress an inflated type 2 (dynamic Huffman codes) block.\\r\\n    var i;\\t\\t// temporary variables\\r\\n    var j;\\r\\n    var l;\\t\\t// last length\\r\\n    var n;\\t\\t// number of lengths to get\\r\\n    var t;\\t\\t// (zip_HuftNode) literal/length code table\\r\\n    var nb;\\t\\t// number of bit length codes\\r\\n    var nl;\\t\\t// number of literal/length codes\\r\\n    var nd;\\t\\t// number of distance codes\\r\\n    var ll = new Array(286+30); // literal/length and distance code lengths\\r\\n    var h;\\t\\t// (zip_HuftBuild)\\r\\n\\r\\n    for(i = 0; i < ll.length; i++)\\r\\n\\tll[i] = 0;\\r\\n\\r\\n    // read in table lengths\\r\\n    zip_NEEDBITS(5);\\r\\n    nl = 257 + zip_GETBITS(5);\\t// number of literal/length codes\\r\\n    zip_DUMPBITS(5);\\r\\n    zip_NEEDBITS(5);\\r\\n    nd = 1 + zip_GETBITS(5);\\t// number of distance codes\\r\\n    zip_DUMPBITS(5);\\r\\n    zip_NEEDBITS(4);\\r\\n    nb = 4 + zip_GETBITS(4);\\t// number of bit length codes\\r\\n    zip_DUMPBITS(4);\\r\\n    if(nl > 286 || nd > 30)\\r\\n      return -1;\\t\\t// bad lengths\\r\\n\\r\\n    // read in bit-length-code lengths\\r\\n    for(j = 0; j < nb; j++)\\r\\n    {\\r\\n\\tzip_NEEDBITS(3);\\r\\n\\tll[zip_border[j]] = zip_GETBITS(3);\\r\\n\\tzip_DUMPBITS(3);\\r\\n    }\\r\\n    for(; j < 19; j++)\\r\\n\\tll[zip_border[j]] = 0;\\r\\n\\r\\n    // build decoding table for trees--single level, 7 bit lookup\\r\\n    zip_bl = 7;\\r\\n    h = new zip_HuftBuild(ll, 19, 19, null, null, zip_bl);\\r\\n    if(h.status != 0)\\r\\n\\treturn -1;\\t// incomplete code set\\r\\n\\r\\n    zip_tl = h.root;\\r\\n    zip_bl = h.m;\\r\\n\\r\\n    // read in literal and distance code lengths\\r\\n    n = nl + nd;\\r\\n    i = l = 0;\\r\\n    while(i < n) {\\r\\n\\tzip_NEEDBITS(zip_bl);\\r\\n\\tt = zip_tl.list[zip_GETBITS(zip_bl)];\\r\\n\\tj = t.b;\\r\\n\\tzip_DUMPBITS(j);\\r\\n\\tj = t.n;\\r\\n\\tif(j < 16)\\t\\t// length of code in bits (0..15)\\r\\n\\t    ll[i++] = l = j;\\t// save last length in l\\r\\n\\telse if(j == 16) {\\t// repeat last length 3 to 6 times\\r\\n\\t    zip_NEEDBITS(2);\\r\\n\\t    j = 3 + zip_GETBITS(2);\\r\\n\\t    zip_DUMPBITS(2);\\r\\n\\t    if(i + j > n)\\r\\n\\t\\treturn -1;\\r\\n\\t    while(j-- > 0)\\r\\n\\t\\tll[i++] = l;\\r\\n\\t} else if(j == 17) {\\t// 3 to 10 zero length codes\\r\\n\\t    zip_NEEDBITS(3);\\r\\n\\t    j = 3 + zip_GETBITS(3);\\r\\n\\t    zip_DUMPBITS(3);\\r\\n\\t    if(i + j > n)\\r\\n\\t\\treturn -1;\\r\\n\\t    while(j-- > 0)\\r\\n\\t\\tll[i++] = 0;\\r\\n\\t    l = 0;\\r\\n\\t} else {\\t\\t// j == 18: 11 to 138 zero length codes\\r\\n\\t    zip_NEEDBITS(7);\\r\\n\\t    j = 11 + zip_GETBITS(7);\\r\\n\\t    zip_DUMPBITS(7);\\r\\n\\t    if(i + j > n)\\r\\n\\t\\treturn -1;\\r\\n\\t    while(j-- > 0)\\r\\n\\t\\tll[i++] = 0;\\r\\n\\t    l = 0;\\r\\n\\t}\\r\\n    }\\r\\n\\r\\n    // build the decoding tables for literal/length and distance codes\\r\\n    zip_bl = zip_lbits;\\r\\n    h = new zip_HuftBuild(ll, nl, 257, zip_cplens, zip_cplext, zip_bl);\\r\\n    if(zip_bl == 0)\\t// no literals or lengths\\r\\n\\th.status = 1;\\r\\n    if(h.status != 0) {\\r\\n\\tif(h.status == 1)\\r\\n\\t    ;// **incomplete literal tree**\\r\\n\\treturn -1;\\t\\t// incomplete code set\\r\\n    }\\r\\n    zip_tl = h.root;\\r\\n    zip_bl = h.m;\\r\\n\\r\\n    for(i = 0; i < nd; i++)\\r\\n\\tll[i] = ll[i + nl];\\r\\n    zip_bd = zip_dbits;\\r\\n    h = new zip_HuftBuild(ll, nd, 0, zip_cpdist, zip_cpdext, zip_bd);\\r\\n    zip_td = h.root;\\r\\n    zip_bd = h.m;\\r\\n\\r\\n    if(zip_bd == 0 && nl > 257) {   // lengths but no distances\\r\\n\\t// **incomplete distance tree**\\r\\n\\treturn -1;\\r\\n    }\\r\\n\\r\\n    if(h.status == 1) {\\r\\n\\t;// **incomplete distance tree**\\r\\n    }\\r\\n    if(h.status != 0)\\r\\n\\treturn -1;\\r\\n\\r\\n    // decompress until an end-of-block code\\r\\n    return zip_inflate_codes(buff, off, size);\\r\\n}\\r\\n\\r\\nvar zip_inflate_start = function() {\\r\\n    var i;\\r\\n\\r\\n    if(zip_slide == null)\\r\\n\\tzip_slide = new Array(2 * zip_WSIZE);\\r\\n    zip_wp = 0;\\r\\n    zip_bit_buf = 0;\\r\\n    zip_bit_len = 0;\\r\\n    zip_method = -1;\\r\\n    zip_eof = false;\\r\\n    zip_copy_leng = zip_copy_dist = 0;\\r\\n    zip_tl = null;\\r\\n}\\r\\n\\r\\nvar zip_inflate_internal = function(buff, off, size) {\\r\\n    // decompress an inflated entry\\r\\n    var n, i;\\r\\n\\r\\n    n = 0;\\r\\n    while(n < size) {\\r\\n\\tif(zip_eof && zip_method == -1)\\r\\n\\t    return n;\\r\\n\\r\\n\\tif(zip_copy_leng > 0) {\\r\\n\\t    if(zip_method != zip_STORED_BLOCK) {\\r\\n\\t\\t// STATIC_TREES or DYN_TREES\\r\\n\\t\\twhile(zip_copy_leng > 0 && n < size) {\\r\\n\\t\\t    zip_copy_leng--;\\r\\n\\t\\t    zip_copy_dist &= zip_WSIZE - 1;\\r\\n\\t\\t    zip_wp &= zip_WSIZE - 1;\\r\\n\\t\\t    buff[off + n++] = zip_slide[zip_wp++] =\\r\\n\\t\\t\\tzip_slide[zip_copy_dist++];\\r\\n\\t\\t}\\r\\n\\t    } else {\\r\\n\\t\\twhile(zip_copy_leng > 0 && n < size) {\\r\\n\\t\\t    zip_copy_leng--;\\r\\n\\t\\t    zip_wp &= zip_WSIZE - 1;\\r\\n\\t\\t    zip_NEEDBITS(8);\\r\\n\\t\\t    buff[off + n++] = zip_slide[zip_wp++] = zip_GETBITS(8);\\r\\n\\t\\t    zip_DUMPBITS(8);\\r\\n\\t\\t}\\r\\n\\t\\tif(zip_copy_leng == 0)\\r\\n\\t\\t    zip_method = -1; // done\\r\\n\\t    }\\r\\n\\t    if(n == size)\\r\\n\\t\\treturn n;\\r\\n\\t}\\r\\n\\r\\n\\tif(zip_method == -1) {\\r\\n\\t    if(zip_eof)\\r\\n\\t\\tbreak;\\r\\n\\r\\n\\t    // read in last block bit\\r\\n\\t    zip_NEEDBITS(1);\\r\\n\\t    if(zip_GETBITS(1) != 0)\\r\\n\\t\\tzip_eof = true;\\r\\n\\t    zip_DUMPBITS(1);\\r\\n\\r\\n\\t    // read in block type\\r\\n\\t    zip_NEEDBITS(2);\\r\\n\\t    zip_method = zip_GETBITS(2);\\r\\n\\t    zip_DUMPBITS(2);\\r\\n\\t    zip_tl = null;\\r\\n\\t    zip_copy_leng = 0;\\r\\n\\t}\\r\\n\\r\\n\\tswitch(zip_method) {\\r\\n\\t  case 0: // zip_STORED_BLOCK\\r\\n\\t    i = zip_inflate_stored(buff, off + n, size - n);\\r\\n\\t    break;\\r\\n\\r\\n\\t  case 1: // zip_STATIC_TREES\\r\\n\\t    if(zip_tl != null)\\r\\n\\t\\ti = zip_inflate_codes(buff, off + n, size - n);\\r\\n\\t    else\\r\\n\\t\\ti = zip_inflate_fixed(buff, off + n, size - n);\\r\\n\\t    break;\\r\\n\\r\\n\\t  case 2: // zip_DYN_TREES\\r\\n\\t    if(zip_tl != null)\\r\\n\\t\\ti = zip_inflate_codes(buff, off + n, size - n);\\r\\n\\t    else\\r\\n\\t\\ti = zip_inflate_dynamic(buff, off + n, size - n);\\r\\n\\t    break;\\r\\n\\r\\n\\t  default: // error\\r\\n\\t    i = -1;\\r\\n\\t    break;\\r\\n\\t}\\r\\n\\r\\n\\tif(i == -1) {\\r\\n\\t    if(zip_eof)\\r\\n\\t\\treturn 0;\\r\\n\\t    return -1;\\r\\n\\t}\\r\\n\\tn += i;\\r\\n    }\\r\\n    return n;\\r\\n}\\r\\n\\r\\nvar zip_inflate = function(str) {\\r\\n    var i, j;\\r\\n\\r\\n    zip_inflate_start();\\r\\n    zip_inflate_data = str;\\r\\n    zip_inflate_pos = 0;\\r\\n\\r\\n    var buff = new Array(1024);\\r\\n    var aout = [];\\r\\n    while((i = zip_inflate_internal(buff, 0, buff.length)) > 0) {\\r\\n\\tvar cbuf = new Array(i);\\r\\n\\tfor(j = 0; j < i; j++){\\r\\n\\t    cbuf[j] = String.fromCharCode(buff[j]);\\r\\n\\t}\\r\\n\\taout[aout.length] = cbuf.join(\\\"\\\");\\r\\n    }\\r\\n    zip_inflate_data = null; // G.C.\\r\\n    return aout.join(\\\"\\\");\\r\\n}\\r\\n\\r\\nif (! ctx.RawDeflate) ctx.RawDeflate = {};\\r\\nctx.RawDeflate.inflate = zip_inflate;\\r\\n\\r\\n})(this);\\r\\n\""
		},
		{
			"name": "store2.min.js",
			"source": "\"/*! store2 - v2.7.0 - 2018-03-04\\r\\n* Copyright (c) 2018 Nathan Bubna; Licensed (MIT OR GPL-3.0) */\\r\\n\\r\\n!function(a,b){var c={version:\\\"2.7.0\\\",areas:{},apis:{},inherit:function(a,b){for(var c in a)b.hasOwnProperty(c)||(b[c]=a[c]);return b},stringify:function(a){return void 0===a||\\\"function\\\"==typeof a?a+\\\"\\\":JSON.stringify(a)},parse:function(a){try{return JSON.parse(a)}catch(b){return a}},fn:function(a,b){c.storeAPI[a]=b;for(var d in c.apis)c.apis[d][a]=b},get:function(a,b){return a.getItem(b)},set:function(a,b,c){a.setItem(b,c)},remove:function(a,b){a.removeItem(b)},key:function(a,b){return a.key(b)},length:function(a){return a.length},clear:function(a){a.clear()},Store:function(a,b,d){var e=c.inherit(c.storeAPI,function(a,b,c){return 0===arguments.length?e.getAll():\\\"function\\\"==typeof b?e.transact(a,b,c):void 0!==b?e.set(a,b,c):\\\"string\\\"==typeof a||\\\"number\\\"==typeof a?e.get(a):a?e.setAll(a,b):e.clear()});e._id=a;try{b.setItem(\\\"_-bad-_\\\",\\\"wolf\\\"),e._area=b,b.removeItem(\\\"_-bad-_\\\")}catch(a){}return e._area||(e._area=c.inherit(c.storageAPI,{items:{},name:\\\"fake\\\"})),e._ns=d||\\\"\\\",c.areas[a]||(c.areas[a]=e._area),c.apis[e._ns+e._id]||(c.apis[e._ns+e._id]=e),e},storeAPI:{area:function(a,b){var d=this[a];return d&&d.area||(d=c.Store(a,b,this._ns),this[a]||(this[a]=d)),d},namespace:function(a,b){if(!a)return this._ns?this._ns.substring(0,this._ns.length-1):\\\"\\\";var d=a,e=this[d];return e&&e.namespace||(e=c.Store(this._id,this._area,this._ns+d+\\\".\\\"),this[d]||(this[d]=e),b||e.area(\\\"session\\\",c.areas.session)),e},isFake:function(){return\\\"fake\\\"===this._area.name},toString:function(){return\\\"store\\\"+(this._ns?\\\".\\\"+this.namespace():\\\"\\\")+\\\"[\\\"+this._id+\\\"]\\\"},has:function(a){return this._area.has?this._area.has(this._in(a)):!!(this._in(a)in this._area)},size:function(){return this.keys().length},each:function(a,b){for(var d=0,e=c.length(this._area);d<e;d++){var f=this._out(c.key(this._area,d));if(void 0!==f&&a.call(this,f,b||this.get(f))===!1)break;e>c.length(this._area)&&(e--,d--)}return b||this},keys:function(a){return this.each(function(a,b){b.push(a)},a||[])},get:function(a,b){var d=c.get(this._area,this._in(a));return null!==d?c.parse(d):b||d},getAll:function(a){return this.each(function(a,b){b[a]=this.get(a)},a||{})},transact:function(a,b,c){var d=this.get(a,c),e=b(d);return this.set(a,void 0===e?d:e),this},set:function(a,b,d){var e=this.get(a);return null!=e&&d===!1?b:c.set(this._area,this._in(a),c.stringify(b),d)||e},setAll:function(a,b){var c,d;for(var e in a)d=a[e],this.set(e,d,b)!==d&&(c=!0);return c},add:function(a,b){var d=this.get(a);if(d instanceof Array)b=d.concat(b);else if(null!==d){var e=typeof d;if(e===typeof b&&\\\"object\\\"===e){for(var f in b)d[f]=b[f];b=d}else b=d+b}return c.set(this._area,this._in(a),c.stringify(b)),b},remove:function(a){var b=this.get(a);return c.remove(this._area,this._in(a)),b},clear:function(){return this._ns?this.each(function(a){c.remove(this._area,this._in(a))},1):c.clear(this._area),this},clearAll:function(){var a=this._area;for(var b in c.areas)c.areas.hasOwnProperty(b)&&(this._area=c.areas[b],this.clear());return this._area=a,this},_in:function(a){return\\\"string\\\"!=typeof a&&(a=c.stringify(a)),this._ns?this._ns+a:a},_out:function(a){return this._ns?a&&0===a.indexOf(this._ns)?a.substring(this._ns.length):void 0:a}},storageAPI:{length:0,has:function(a){return this.items.hasOwnProperty(a)},key:function(a){var b=0;for(var c in this.items)if(this.has(c)&&a===b++)return c},setItem:function(a,b){this.has(a)||this.length++,this.items[a]=b},removeItem:function(a){this.has(a)&&(delete this.items[a],this.length--)},getItem:function(a){return this.has(a)?this.items[a]:null},clear:function(){for(var a in this.items)this.removeItem(a)},toString:function(){return this.length+\\\" items in \\\"+this.name+\\\"Storage\\\"}}},d=c.Store(\\\"local\\\",function(){try{return localStorage}catch(a){}}());d.local=d,d._=c,d.area(\\\"session\\\",function(){try{return sessionStorage}catch(a){}}()),\\\"function\\\"==typeof b&&void 0!==b.amd?b(\\\"store2\\\",[],function(){return d}):\\\"undefined\\\"!=typeof module&&module.exports?module.exports=d:(a.store&&(c.conflict=a.store),a.store=d)}(this,this.define);\\r\\n//# sourceMappingURL=store2.min.js.map\""
		},
		{
			"name": "system.min.js",
			"source": "\"// system.js - http://github.com/mrdoob/system.js\\r\\n'use strict';var System={browser:function(){var a=navigator.userAgent;return/Arora/i.test(a)?\\\"Arora\\\":/Opera|OPR/.test(a)?\\\"Opera\\\":/Maxthon/i.test(a)?\\\"Maxthon\\\":/Vivaldi/i.test(a)?\\\"Vivaldi\\\":/YaBrowser/i.test(a)?\\\"Yandex\\\":/Chrome/i.test(a)?\\\"Chrome\\\":/Epiphany/i.test(a)?\\\"Epiphany\\\":/Firefox/i.test(a)?\\\"Firefox\\\":/Mobile(\\\\/.*)? Safari/i.test(a)?\\\"Mobile Safari\\\":/MSIE/i.test(a)?\\\"Internet Explorer\\\":/Midori/i.test(a)?\\\"Midori\\\":/Safari/i.test(a)?\\\"Safari\\\":!1}(),os:function(){var a=navigator.userAgent;return/Android/i.test(a)?\\r\\n\\\"Android\\\":/CrOS/i.test(a)?\\\"Chrome OS\\\":/iP[ao]d|iPhone/i.test(a)?\\\"iOS\\\":/Linux/i.test(a)?\\\"Linux\\\":/Mac OS/i.test(a)?\\\"Mac OS\\\":/windows/i.test(a)?\\\"Windows\\\":!1}(),support:{canvas:!!window.CanvasRenderingContext2D,localStorage:function(){try{return!!window.localStorage.getItem}catch(a){return!1}}(),file:!!window.File&&!!window.FileReader&&!!window.FileList&&!!window.Blob,fileSystem:!!window.requestFileSystem||!!window.webkitRequestFileSystem,getUserMedia:!!window.navigator.getUserMedia||!!window.navigator.webkitGetUserMedia||\\r\\n!!window.navigator.mozGetUserMedia||!!window.navigator.msGetUserMedia,requestAnimationFrame:!!window.mozRequestAnimationFrame||!!window.webkitRequestAnimationFrame||!!window.oRequestAnimationFrame||!!window.msRequestAnimationFrame,sessionStorage:function(){try{return!!window.sessionStorage.getItem}catch(a){return!1}}(),svg:function(){try{return!!document.createElementNS&&!!document.createElementNS(\\\"http://www.w3.org/2000/svg\\\",\\\"svg\\\").createSVGRect}catch(a){return!1}}(),webgl:function(){try{return!!window.WebGLRenderingContext&&\\r\\n!!document.createElement(\\\"canvas\\\").getContext(\\\"experimental-webgl\\\")}catch(a){return!1}}(),worker:!!window.Worker}};\\r\\n\""
		},
		{
			"name": "zangodb.min.js",
			"source": "\"!function(t){if(\\\"object\\\"==typeof exports&&\\\"undefined\\\"!=typeof module)module.exports=t();else if(\\\"function\\\"==typeof define&&define.amd)define([],t);else{(\\\"undefined\\\"!=typeof window?window:\\\"undefined\\\"!=typeof global?global:\\\"undefined\\\"!=typeof self?self:this).zango=t()}}(function(){return function t(e,n,r){function i(u,a){if(!n[u]){if(!e[u]){var s=\\\"function\\\"==typeof require&&require;if(!a&&s)return s(u,!0);if(o)return o(u,!0);var f=new Error(\\\"Cannot find module '\\\"+u+\\\"'\\\");throw f.code=\\\"MODULE_NOT_FOUND\\\",f}var c=n[u]={exports:{}};e[u][0].call(c.exports,function(t){var n=e[u][1][t];return i(n||t)},c,c.exports,t,e,n,r)}return n[u].exports}for(var o=\\\"function\\\"==typeof require&&require,u=0;u<r.length;u++)i(r[u]);return i}({1:[function(t,e,n){\\\"use strict\\\";var r=function(){function t(t,e){var n=[],r=!0,i=!1,o=void 0;try{for(var u,a=t[Symbol.iterator]();!(r=(u=a.next()).done)&&(n.push(u.value),!e||n.length!==e);r=!0);}catch(t){i=!0,o=t}finally{try{!r&&a.return&&a.return()}finally{if(i)throw o}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError(\\\"Invalid attempt to destructure non-iterable instance\\\")}}(),i=t(\\\"./util.js\\\").unknownOp,o=t(\\\"./cursor.js\\\"),u={$match:function(t,e){return t.filter(e)},$project:function(t,e){return t.project(e)},$group:function(t,e){return t.group(e)},$unwind:function(t,e){return t.unwind(e)},$sort:function(t,e){return t.sort(e)},$skip:function(t,e){return t.skip(e)},$limit:function(t,e){return t.limit(e)}},a=function(t){var e=Object.keys(t);if(e.length>1)throw Error(\\\"stages must be passed only one operator\\\");var n=e[0],r=u[n];return r||i(n),[r,t[n]]};e.exports=function(t,e){var n=new o(t,\\\"readonly\\\"),i=!0,u=!1,s=void 0;try{for(var f,c=e[Symbol.iterator]();!(i=(f=c.next()).done);i=!0){var l=f.value,p=a(l),h=r(p,2);(0,h[0])(n,h[1])}}catch(t){u=!0,s=t}finally{try{!i&&c.return&&c.return()}finally{if(u)throw s}}return n}},{\\\"./cursor.js\\\":4,\\\"./util.js\\\":21}],2:[function(t,e,n){\\\"use strict\\\";function r(t,e){if(!(t instanceof e))throw new TypeError(\\\"Cannot call a class as a function\\\")}var i=\\\"function\\\"==typeof Symbol&&\\\"symbol\\\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\\\"function\\\"==typeof Symbol&&t.constructor===Symbol?\\\"symbol\\\":typeof t},o=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\\\"value\\\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=t(\\\"q\\\"),a=t(\\\"./util.js\\\").getIDBError,s=t(\\\"./cursor.js\\\"),f=t(\\\"./aggregate.js\\\"),c=t(\\\"./update.js\\\"),l=t(\\\"./remove.js\\\"),p=function(){function t(e,n){r(this,t),this._db=e,this._name=n,this._indexes=new Set}return o(t,[{key:\\\"_isIndexed\\\",value:function(t){return this._indexes.has(t)||\\\"_id\\\"===t}},{key:\\\"find\\\",value:function(t,e){var n=new s(this,\\\"readonly\\\");return n.filter(t),e&&n.project(e),n}},{key:\\\"findOne\\\",value:function(t,e,n){\\\"function\\\"==typeof e&&(n=e,e=null);var r=u.defer();return this.find(t,e).limit(1).toArray(function(t,e){t?r.reject(t):r.resolve(e[0])}),r.promise.nodeify(n),r.promise}},{key:\\\"aggregate\\\",value:function(t){return f(this,t)}},{key:\\\"_validate\\\",value:function(t){for(var e in t){if(\\\"$\\\"===e[0])throw Error(\\\"field name cannot start with '$'\\\");var n=t[e];if(Array.isArray(n)){var r=!0,o=!1,u=void 0;try{for(var a,s=n[Symbol.iterator]();!(r=(a=s.next()).done);r=!0){var f=a.value;this._validate(f)}}catch(t){o=!0,u=t}finally{try{!r&&s.return&&s.return()}finally{if(o)throw u}}}else\\\"object\\\"===(void 0===n?\\\"undefined\\\":i(n))&&this._validate(n)}}},{key:\\\"insert\\\",value:function(t,e){var n=this;Array.isArray(t)||(t=[t]);var r=u.defer();return this._db._getConn(function(e,i){var o=void 0,u=n._name;try{o=i.transaction([u],\\\"readwrite\\\")}catch(e){return r.reject(e)}o.oncomplete=function(){return r.resolve()},o.onerror=function(t){return r.reject(a(t))};var s=o.objectStore(u),f=0;!function e(){var i=t[f];try{n._validate(i)}catch(t){return r.reject(t)}s.add(i).onsuccess=function(){++f<t.length&&e()}}()}),r.promise.nodeify(e),r.promise}},{key:\\\"_modify\\\",value:function(t,e,n){var r=u.defer(),i=new s(this,\\\"readwrite\\\");return i.filter(e),t(i,function(t){t?r.reject(t):r.resolve()}),r.promise.nodeify(n),r.promise}},{key:\\\"update\\\",value:function(t,e,n){return this._modify(function(t,n){return c(t,e,n)},t,n)}},{key:\\\"remove\\\",value:function(t,e){return this._modify(l,t,e)}},{key:\\\"name\\\",get:function(){return this._name}}]),t}();e.exports=p},{\\\"./aggregate.js\\\":1,\\\"./cursor.js\\\":4,\\\"./remove.js\\\":16,\\\"./update.js\\\":20,\\\"./util.js\\\":21,q:96}],3:[function(t,e,n){\\\"use strict\\\";var r=\\\"function\\\"==typeof Symbol&&\\\"symbol\\\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\\\"function\\\"==typeof Symbol&&t.constructor===Symbol?\\\"symbol\\\":typeof t},i=function(){function t(t,e){var n=[],r=!0,i=!1,o=void 0;try{for(var u,a=t[Symbol.iterator]();!(r=(u=a.next()).done)&&(n.push(u.value),!e||n.length!==e);r=!0);}catch(t){i=!0,o=t}finally{try{!r&&a.return&&a.return()}finally{if(i)throw o}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError(\\\"Invalid attempt to destructure non-iterable instance\\\")}}(),o=t(\\\"deepmerge\\\"),u=t(\\\"./util.js\\\"),a=u.hashify,s=u.getIDBError,f=t(\\\"./filter.js\\\"),c=t(\\\"./sort.js\\\"),l=t(\\\"./lang/filter.js\\\"),p=l.build,h=l.Conjunction,y=l.Disjunction,d=l.Exists,v=function(t){return t>0?\\\"next\\\":\\\"prev\\\"},g=function(t){return t.length>1?new h(t):t[0]},b=function(t){var e=t.parent,n=t.index;e.args.splice(n,1)},m=function(t,e){var n=t.col,r=t.read_pref;n._db._getConn(function(t,i){if(t)return e(t);var o=n._name;try{var u=i.transaction([o],r);u.onerror=function(t){return e(s(t))},e(null,u.objectStore(o))}catch(t){e(t)}})},w=function(t,e){var n=e.idb_key_range||null,r=e.idb_direction||\\\"next\\\",i=e.path.literal;return(\\\"_id\\\"===i?t:t.index(i)).openCursor(n,r)},_=function(t){return t.openCursor()},j=function(t){var e=[],n=!0,r=!1,o=void 0;try{for(var u,a=t[Symbol.iterator]();!(n=(u=a.next()).done);n=!0){var s=i(u.value,2),c=s[0],l=s[1];if(c===f){var h=p(l);if(!1===h)return;if(!h)continue;l=h}e.push([c,l])}}catch(t){r=!0,o=t}finally{try{!n&&a.return&&a.return()}finally{if(r)throw o}}return e},x=function(t){var e=t.pipeline,n=[],r=[],u=0,a=!0,s=!1,l=void 0;try{for(var p,h=e[Symbol.iterator]();!(a=(p=h.next()).done);a=!0){var y=i(p.value,2),d=y[0],v=y[1];if(d===c)r.push(v);else{if(d!==f)break;n.push(v)}u++}}catch(t){s=!0,l=t}finally{try{!a&&h.return&&h.return()}finally{if(s)throw l}}e.splice(0,u),t.pred=g(n),r.length&&(t.sort_spec=r.reduce(o,{}))},O=function(t,e){if(!e)return[];var n=[],r=[],i=!0,o=!1,u=void 0;try{for(var a,s=e.getClauses()[Symbol.iterator]();!(i=(a=s.next()).done);i=!0){var f=a.value;t._isIndexed(f.path.literal)&&(f instanceof d?r.push(f):n.push(f))}}catch(t){o=!0,u=t}finally{try{!i&&s.return&&s.return()}finally{if(o)throw u}}return n.length?n:r},k=function(t){var e=t.col,n=t.pred;t.clauses=O(e,n)},E=function(t){if(t.hint){var e=t.clauses,n=t.hint,r=[],i=!0,o=!1,u=void 0;try{for(var a,s=e[Symbol.iterator]();!(i=(a=s.next()).done);i=!0){var f=a.value;f.path.literal===n&&r.push(f)}}catch(t){o=!0,u=t}finally{try{!i&&s.return&&s.return()}finally{if(o)throw u}}r.length||(r=[{path:{literal:n}}]),t.clauses=r}},A=function(t){if(t.sort_spec){var e=t.clauses,n=t.sort_spec,r=t.pipeline,i=[],o=!0,u=!1,a=void 0;try{for(var s,f=e[Symbol.iterator]();!(o=(s=f.next()).done);o=!0){var l=s.value,p=l.path.literal;if(n.hasOwnProperty(p)){var h=n[p];l.idb_direction=v(h),i.push(l)}}}catch(t){u=!0,a=t}finally{try{!o&&f.return&&f.return()}finally{if(u)throw a}}i.length?t.clauses=i:r.unshift([c,n])}},S=function(t){var e=t.pred,n=t.clauses,i=t.pipeline,o=void 0;if(n.length){var u=function(){var t=n[0];if(o=function(e){return w(e,t)},!e||t===e)return{v:o};b(t)}();if(\\\"object\\\"===(void 0===u?\\\"undefined\\\":r(u)))return u.v}else if(o=_,!e)return o;return i.unshift([f,e]),o},I=function(t){var e=void 0,n=void 0,r=S(t),i=function(t){n.onsuccess=function(n){e=n.target.result,t()},n.onerror=function(e){return t(s(e))}},o=function(t){i(t),e.continue()},u=function(a){m(t,function(t,s){if(t)return a(t);n=r(s),i(function(t){e&&(u=o),a(t)})})};return function(t){return u(function(n){return t(n,e)})}},T=function(t,e){var n=t.pipeline,r=!0,o=!1,u=void 0;try{for(var a,s=n[Symbol.iterator]();!(r=(a=s.next()).done);r=!0){var f=i(a.value,2);e=(0,f[0])(e,f[1])}}catch(t){o=!0,u=t}finally{try{!r&&s.return&&s.return()}finally{if(o)throw u}}return e},P=function(t){for(var e=[],n=t.pred.args,r=n.length-1;r>=0;r--){var i={col:t.col,read_pref:t.read_pref,pred:n[r],pipeline:[]};k(i);var o=B(i);e.push(T(i,o))}var u=new Set,s=function(t){var e=a(t._id);if(!u.has(e))return u.add(e)},f=function(){return e.pop()},l=f(),p=function(t){(l=f())?h(t):t()},h=function t(e){l(function(n,r,i){n?e(n):r?s(r)?e(null,r,i):t(e):p(e)})},y=t.sort_spec;return y&&t.pipeline.push([c,y]),h},B=function(t){var e=I(t);return function(t){e(function(e,n){n?t(null,n.value,n):t(e)})}};e.exports=function(t){var e=void 0;try{e=j(t._pipeline)}catch(t){return function(e){return e(t)}}if(!e)return function(t){return t()};var n={col:t._col,read_pref:t._read_pref,hint:t._hint,pipeline:e};x(n);var r=void 0;return n.pred instanceof y?r=P(n):(k(n),E(n),A(n),r=B(n)),T(n,r)}},{\\\"./filter.js\\\":6,\\\"./lang/filter.js\\\":11,\\\"./sort.js\\\":18,\\\"./util.js\\\":21,deepmerge:26}],4:[function(t,e,n){\\\"use strict\\\";function r(t,e){if(!(t instanceof e))throw new TypeError(\\\"Cannot call a class as a function\\\")}function i(t,e){if(!t)throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\");return!e||\\\"object\\\"!=typeof e&&\\\"function\\\"!=typeof e?t:e}function o(t,e){if(\\\"function\\\"!=typeof e&&null!==e)throw new TypeError(\\\"Super expression must either be null or a function, not \\\"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\\\"value\\\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),a=t(\\\"events\\\"),s=t(\\\"q\\\"),f=t(\\\"./create_next_fn.js\\\"),c=t(\\\"./filter.js\\\"),l=t(\\\"./project.js\\\"),p=t(\\\"./group.js\\\"),h=t(\\\"./unwind.js\\\"),y=t(\\\"./sort.js\\\"),d=t(\\\"./skip.js\\\"),v=t(\\\"./limit.js\\\"),g=function(t){function e(t,n){r(this,e);var o=i(this,Object.getPrototypeOf(e).call(this));return o._col=t,o._read_pref=n,o._pipeline=[],o._next=o._init,o}return o(e,a),u(e,[{key:\\\"_forEach\\\",value:function(t,e){var n=this;this._next(function(r,i){i?(t(i),n.emit(\\\"data\\\",i),n._forEach(t,e)):(n.emit(\\\"end\\\"),e(r))})}},{key:\\\"forEach\\\",value:function(){var t=arguments.length<=0||void 0===arguments[0]?function(){}:arguments[0],e=arguments[1],n=s.defer();return this._forEach(t,function(t){t?n.reject(t):n.resolve()}),n.promise.nodeify(e),n.promise}},{key:\\\"_toArray\\\",value:function(t){var e=[];this._forEach(function(t){e.push(t)},function(n){return t(n,e)})}},{key:\\\"toArray\\\",value:function(t){var e=s.defer();return this._toArray(function(t,n){t?e.reject(t):e.resolve(n)}),e.promise.nodeify(t),e.promise}},{key:\\\"_assertUnopened\\\",value:function(){if(this._opened)throw Error(\\\"cursor has already been opened\\\")}},{key:\\\"hint\\\",value:function(t){if(this._assertUnopened(),!this._col._isIndexed(t))throw Error(\\\"index '\\\"+t+\\\"' does not exist\\\");return this._hint=t,this}},{key:\\\"_addStage\\\",value:function(t,e){return this._assertUnopened(),this._pipeline.push([t,e]),this}},{key:\\\"filter\\\",value:function(t){return this._addStage(c,t)}},{key:\\\"limit\\\",value:function(t){return this._addStage(v,t)}},{key:\\\"skip\\\",value:function(t){return this._addStage(d,t)}},{key:\\\"project\\\",value:function(t){return this._addStage(l,t)}},{key:\\\"group\\\",value:function(t){return this._addStage(p,t)}},{key:\\\"unwind\\\",value:function(t){return this._addStage(h,t)}},{key:\\\"sort\\\",value:function(t){return this._addStage(y,t)}},{key:\\\"_init\\\",value:function(t){this._opened=!0,this._next=f(this),this._next(t)}}]),e}();e.exports=g},{\\\"./create_next_fn.js\\\":3,\\\"./filter.js\\\":6,\\\"./group.js\\\":7,\\\"./limit.js\\\":14,\\\"./project.js\\\":15,\\\"./skip.js\\\":17,\\\"./sort.js\\\":18,\\\"./unwind.js\\\":19,events:71,q:96}],5:[function(t,e,n){\\\"use strict\\\";function r(t,e){if(!(t instanceof e))throw new TypeError(\\\"Cannot call a class as a function\\\")}function i(t,e){if(!t)throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\");return!e||\\\"object\\\"!=typeof e&&\\\"function\\\"!=typeof e?t:e}function o(t,e){if(\\\"function\\\"!=typeof e&&null!==e)throw new TypeError(\\\"Super expression must either be null or a function, not \\\"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var u=\\\"function\\\"==typeof Symbol&&\\\"symbol\\\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\\\"function\\\"==typeof Symbol&&t.constructor===Symbol?\\\"symbol\\\":typeof t},a=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\\\"value\\\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),s=t(\\\"events\\\"),f=t(\\\"memoizee\\\"),c=t(\\\"q\\\"),l=t(\\\"./util.js\\\").getIDBError,p=t(\\\"./collection.js\\\"),h=function(t){function e(t,n,o){r(this,e);var a=i(this,Object.getPrototypeOf(e).call(this));if(a._name=t,\\\"object\\\"===(void 0===n?\\\"undefined\\\":u(n))?o=n:a._version=n,a._cols={},a._config={},a._initGetConn(),Array.isArray(o)){var s=!0,f=!1,c=void 0;try{for(var l,p=o[Symbol.iterator]();!(s=(l=p.next()).done);s=!0){var h=l.value;a._addCollection(h),a._config[h]=!0}}catch(t){f=!0,c=t}finally{try{!s&&p.return&&p.return()}finally{if(f)throw c}}}else for(var y in o)a._addCollection(y),a._addIndex(o[y],y);return a}return o(e,s),a(e,[{key:\\\"_addCollection\\\",value:function(t){this._cols[t]=new p(this,t)}},{key:\\\"_addIndex\\\",value:function(t,e){var n=this._config;if(!t)return n[e]=!1;if(\\\"object\\\"!==(void 0===t?\\\"undefined\\\":u(t)))return n[e]={};var r=this._cols[e];if(Array.isArray(t)){var i={},o=!0,a=!1,s=void 0;try{for(var f,c=t[Symbol.iterator]();!(o=(f=c.next()).done);o=!0){var l=f.value;i[l]=!0,r._indexes.add(l)}}catch(t){a=!0,s=t}finally{try{!o&&c.return&&c.return()}finally{if(a)throw s}}n[e]=i}else{for(var p in t)t[p]&&r._indexes.add(p);n[e]=t}}},{key:\\\"_addStore\\\",value:function(t,e){var n=t.createObjectStore(e,{keyPath:\\\"_id\\\",autoIncrement:!0}),r=this._config[e];for(var i in r)r[i]?n.createIndex(i,i,{unique:!1}):n.deleteIndex(i)}},{key:\\\"_getConn\\\",value:function(t){var e=this,n=void 0;(n=this._version?indexedDB.open(this._name,this._version):indexedDB.open(this._name)).onsuccess=function(n){var r=n.target.result;e._idb=r,e._version=r.version,e._open=!0,t(null,r)},n.onerror=function(e){return t(l(e))},n.onupgradeneeded=function(n){var r=n.target.result;for(var i in e._config)try{e._config[i]?r.objectStoreNames.contains(i)||e._addStore(r,i):r.deleteObjectStore(i)}catch(e){return t(e)}},n.onblocked=function(){return e.emit(\\\"blocked\\\")}}},{key:\\\"_initGetConn\\\",value:function(){this._getConn=f(this._getConn,{async:!0})}},{key:\\\"collection\\\",value:function(t){var e=this._cols[t];if(!e)throw Error(\\\"collection '\\\"+t+\\\"' does not exist\\\");return e}},{key:\\\"open\\\",value:function(t){var e=this,n=c.defer();return this._getConn(function(t){t?n.reject(t):n.resolve(e)}),n.promise.nodeify(t),n.promise}},{key:\\\"close\\\",value:function(){this._open&&(this._idb.close(),this._open=!1,this._initGetConn())}},{key:\\\"drop\\\",value:function(t){this.close();var e=c.defer(),n=indexedDB.deleteDatabase(this._name);return n.onsuccess=function(){return e.resolve()},n.onerror=function(t){return e.reject(l(t))},e.promise.nodeify(t),e.promise}},{key:\\\"name\\\",get:function(){return this._name}},{key:\\\"version\\\",get:function(){return this._version}}]),e}();e.exports=h},{\\\"./collection.js\\\":2,\\\"./util.js\\\":21,events:71,memoizee:81,q:96}],6:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"./lang/fields.js\\\");e.exports=function(t,e){return function(n){!function i(){t(function(t,o,u){o?e.run(new r(o))?n(null,o,u):i():n(t)})}()}}},{\\\"./lang/fields.js\\\":10}],7:[function(t,e,n){\\\"use strict\\\";function r(t,e){if(!t)throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\");return!e||\\\"object\\\"!=typeof e&&\\\"function\\\"!=typeof e?t:e}function i(t,e){if(\\\"function\\\"!=typeof e&&null!==e)throw new TypeError(\\\"Super expression must either be null or a function, not \\\"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function o(t,e){if(!(t instanceof e))throw new TypeError(\\\"Cannot call a class as a function\\\")}var u=\\\"function\\\"==typeof Symbol&&\\\"symbol\\\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\\\"function\\\"==typeof Symbol&&t.constructor===Symbol?\\\"symbol\\\":typeof t},a=function t(e,n,r){null===e&&(e=Function.prototype);var i=Object.getOwnPropertyDescriptor(e,n);if(void 0===i){var o=Object.getPrototypeOf(e);return null===o?void 0:t(o,n,r)}if(\\\"value\\\"in i)return i.value;var u=i.get;if(void 0!==u)return u.call(r)},s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\\\"value\\\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),f=t(\\\"memoizee\\\"),c=t(\\\"./util.js\\\"),l=c.unknownOp,p=c.hashify,h=t(\\\"./lang/expression.js\\\"),y=t(\\\"./lang/fields.js\\\"),d=function(){function t(){o(this,t)}return s(t,[{key:\\\"getOpValueWithRefs\\\",value:function(t,e,n){var r=t.ast,i=t.fields;n(r.run(i))}},{key:\\\"value\\\",get:function(){return this._value}}],[{key:\\\"getNoRefsSteps\\\",value:function(t){return t.in_iter}},{key:\\\"getOpValue\\\",value:function(t,e){e(t.ast.run())}}]),t}(),v=function(t){function e(){o(this,e);var t=r(this,Object.getPrototypeOf(e).call(this));return t._value=0,t}return i(e,d),s(e,[{key:\\\"getOpValueWithRefs\\\",value:function(t,n,r){a(Object.getPrototypeOf(e.prototype),\\\"getOpValueWithRefs\\\",this).call(this,t,n,function(t){e._verify(t,r)})}},{key:\\\"add\\\",value:function(t){this._value+=t}}],[{key:\\\"_verify\\\",value:function(t,e){\\\"number\\\"==typeof t&&e(t)}},{key:\\\"getOpValue\\\",value:function(t,n){a(Object.getPrototypeOf(e),\\\"getOpValue\\\",this).call(this,t,function(t){return e._verify(t,n)})}}]),e}(),g=function(t){function e(){o(this,e);var t=r(this,Object.getPrototypeOf(e).call(this));return t._count=0,t}return i(e,v),s(e,[{key:\\\"add\\\",value:function(t){this._count++,a(Object.getPrototypeOf(e.prototype),\\\"add\\\",this).call(this,t)}},{key:\\\"value\\\",get:function(){return this._value/this._count||0}}]),e}(),b=function(t){function e(t){o(this,e);var n=r(this,Object.getPrototypeOf(e).call(this));return n._value=null,n._fn=t,n._add=n._add1,n}return i(e,d),s(e,[{key:\\\"_add1\\\",value:function(t){this._value=t,this._add=this._add2}},{key:\\\"_add2\\\",value:function(t){this._fn(t,this._value)&&(this._value=t)}},{key:\\\"add\\\",value:function(t){null!=t&&this._add(t)}}],[{key:\\\"getNoRefsSteps\\\",value:function(t){return t.in_end}}]),e}(),m=function(t){for(var e=arguments.length,n=Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];var i=!0,o=!1,u=void 0;try{for(var a,s=t[Symbol.iterator]();!(i=(a=s.next()).done);i=!0)a.value.apply(void 0,n)}catch(t){o=!0,u=t}finally{try{!i&&s.return&&s.return()}finally{if(o)throw u}}},w=function(t,e){var n=!0,r=!1,i=void 0;try{for(var o,u=e[Symbol.iterator]();!(n=(o=u.next()).done);n=!0){var a=o.value;m(t,a)}}catch(t){r=!0,i=t}finally{try{!n&&u.return&&u.return()}finally{if(r)throw i}}},_=function(t,e,n,r){return function(i){var o=function(t){t||w(e,n),i(t,n)};!function e(){t(function(t,n){if(!n)return o(t);r(n),e()})}()}},j=function(t,e,n){var r=n.in_start,i=n.in_iter,o=n.in_end,u=[],a=f(function(t,e){var n={_id:e};return u.push(n),m(r,n),n},{length:1}),s=e.ast,c=function(t){return s.run(new y(t))},l=void 0;return l=i.length?function(t){var e=c(t),n=a(p(e),e);m(i,n,t)}:function(t){var e=c(t);a(p(e),e)},_(t,o,u,l)},x=function(t,e,n){if(e.has_refs)return j(t,e,n);var r=n.in_start,i=n.in_iter,o=n.in_end,a=[],s=function(){var t={_id:e.ast.run()};return m(r,t),a.push(t),t};if(i.length){var c=function(){var e=f(function(){return s()});return{v:_(t,o,a,function(t){m(i,e(),t)})}}();if(\\\"object\\\"===(void 0===c?\\\"undefined\\\":u(c)))return c.v}return function(e){t(function(t,n){n&&(s(),w(o,a)),e(t,a)})}},O={$sum:v,$avg:g,$min:function(t){function e(){return o(this,e),r(this,Object.getPrototypeOf(e).call(this,function(t,e){return t<e}))}return i(e,b),e}(),$max:function(t){function e(){return o(this,e),r(this,Object.getPrototypeOf(e).call(this,function(t,e){return t>e}))}return i(e,b),e}(),$push:function(t){function e(){o(this,e);var t=r(this,Object.getPrototypeOf(e).call(this));return t._value=[],t}return i(e,d),s(e,[{key:\\\"add\\\",value:function(t){this._value.push(t)}}]),e}(),$addToSet:function(t){function e(){o(this,e);var t=r(this,Object.getPrototypeOf(e).call(this));return t._hashes={},t}return i(e,d),s(e,[{key:\\\"add\\\",value:function(t){this._hashes[p(t)]=t}},{key:\\\"value\\\",get:function(){var t=[];for(var e in this._hashes)t.push(this._hashes[e]);return t}}],[{key:\\\"getNoRefsSteps\\\",value:function(t){return t.in_end}}]),e}()},k=function(t,e,n){var r=t.in_start,i=t.in_iter,o=t.in_end,u=Object.keys(n);if(u.length>1)throw Error(\\\"fields must have only one operator\\\");var a=u[0],s=O[a];if(!s)throw\\\"$\\\"===a[0]&&l(a),Error(\\\"unexpected field '\\\"+a+\\\"'\\\");var f=h(n[a]);r.push(function(t){t[e]=new s(f)}),f.has_refs?i.push(function(t,n){var r=new y(n);if(r.ensure(f.paths)){var i=t[e],o=Object.assign({fields:r},f);i.getOpValueWithRefs(o,n,function(t){return i.add(t)})}}):s.getOpValue(f,function(n){s.getNoRefsSteps(t).push(function(t){t[e].add(n)})}),o.push(function(t){t[e]=t[e].value})};e.exports=function(t,e){if(!e.hasOwnProperty(\\\"_id\\\"))throw Error(\\\"the '_id' field is missing\\\");var n=h(e._id),r=Object.assign({},e);delete r._id;var i={in_start:[],in_iter:[],in_end:[]};for(var o in r)k(i,o,r[o]);var u=x(t,n,i),a=function(t){u(function(e,n){e?t(e):(a=function(t){return t(null,n.pop())})(t)})};return function(t){return a(t)}}},{\\\"./lang/expression.js\\\":9,\\\"./lang/fields.js\\\":10,\\\"./util.js\\\":21,memoizee:81}],8:[function(t,e,n){\\\"use strict\\\";e.exports={Db:t(\\\"./db.js\\\")}},{\\\"./db.js\\\":5}],9:[function(t,e,n){\\\"use strict\\\";function r(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++)n[e]=t[e];return n}return Array.from(t)}function i(t,e){if(!t)throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\");return!e||\\\"object\\\"!=typeof e&&\\\"function\\\"!=typeof e?t:e}function o(t,e){if(\\\"function\\\"!=typeof e&&null!==e)throw new TypeError(\\\"Super expression must either be null or a function, not \\\"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function u(t,e){if(!(t instanceof e))throw new TypeError(\\\"Cannot call a class as a function\\\")}var a=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\\\"value\\\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),s=t(\\\"../util.js\\\").unknownOp,f=t(\\\"./missing_symbol.js\\\"),c=t(\\\"./path.js\\\"),l=function(){function t(e){u(this,t),this.value=e}return a(t,[{key:\\\"run\\\",value:function(){return this.value}},{key:\\\"ResultType\\\",get:function(){return this.constructor}}],[{key:\\\"any\\\",value:function(e){return\\\"number\\\"==typeof e?new p(e):\\\"string\\\"==typeof e?new h(e):Array.isArray(e)?new y(e):e instanceof Date?new d(e):new t(e)}},{key:\\\"literal\\\",value:function(e){return new v(t.any(e))}}]),t}(),p=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,l),a(e,null,[{key:\\\"isType\\\",value:function(t){return\\\"number\\\"==typeof t}}]),e}(),h=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,l),a(e,null,[{key:\\\"isType\\\",value:function(t){return\\\"string\\\"==typeof t}}]),e}(),y=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,l),a(e,null,[{key:\\\"isType\\\",value:function(t){return Array.isArray(t)}}]),e}(),d=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,l),a(e,null,[{key:\\\"isType\\\",value:function(t){return t instanceof Date}}]),e}(),v=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,l),a(e,[{key:\\\"run\\\",value:function(){return this.value.run()}},{key:\\\"ResultType\\\",get:function(){return this.value.ResultType}}]),e}(),g=function(){function t(e){u(this,t),this.path=e}return a(t,[{key:\\\"run\\\",value:function(t){var e=t.get(this.path);return e===f?null:e}}]),t}(),b=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,l),a(e,[{key:\\\"run\\\",value:function(t){var e={},n=this.value;for(var r in n)e[r]=n[r].run(t);return e}}]),e}(),m=function(){function t(){u(this,t),this.args=[]}return a(t,[{key:\\\"add\\\",value:function(t){this.args.push(t)}},{key:\\\"alt\\\",get:function(){return new l(null)}}]),t}(),w=function(t){function e(t){u(this,e);var n=i(this,Object.getPrototypeOf(e).call(this));return n.fn=t,n}return o(e,m),a(e,[{key:\\\"run\\\",value:function(t){var e=this.args,n=this.fn;return e.map(function(e){return e.run(t)}).reduce(n)}},{key:\\\"length\\\",get:function(){return 1/0}}]),e}(),_=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,w),a(e,[{key:\\\"run\\\",value:function(t){return this.fn(this.args[0].run(t))}},{key:\\\"length\\\",get:function(){return 1}}]),e}(),j=function(t,e){return function(n){function r(){return u(this,r),i(this,Object.getPrototypeOf(r).call(this,e))}return o(r,t),r}()},x=function(t,e){var n=arguments.length<=2||void 0===arguments[2]?e:arguments[2],r=function(e){function n(){return u(this,n),i(this,Object.getPrototypeOf(n).apply(this,arguments))}return o(n,t),n}();return r.prototype.InputType=e,r.prototype.ResultType=n,r},O=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,x(w,p)),e}(),k=function(t){return j(O,t)},E=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,k(function(t,e){return t+e})),e}(),A=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,k(function(t,e){return t-e})),e}(),S=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,k(function(t,e){return t*e})),e}(),I=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,k(function(t,e){return t/e})),e}(),T=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,k(function(t,e){return t%e})),e}(),P=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,x(w,p)),a(e,[{key:\\\"run\\\",value:function(t){return this.fn.apply(this,r(this.args.map(function(e){return e.run(t)})))}},{key:\\\"length\\\",get:function(){return this.fn.length}}]),e}(),B=function(t){return j(P,t)},C=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,B(Math.abs)),e}(),L=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,B(Math.ceil)),e}(),U=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,B(Math.floor)),e}(),R=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,B(Math.log)),e}(),$=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,B(Math.log10)),e}(),N=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,B(Math.pow)),e}(),M=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,B(Math.sqrt)),e}(),D=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,B(Math.trunc)),e}(),z=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,x(w,h)),e}(),F=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,j(z,function(t,e){return t+e})),e}(),Y=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,x(_,h)),a(e,[{key:\\\"alt\\\",get:function(){return new h(\\\"\\\")}}]),e}(),q=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,j(Y,function(t){return t.toLowerCase()})),e}(),V=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,j(Y,function(t){return t.toUpperCase()})),e}(),Q=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,x(w,y)),e}(),K=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,j(Q,function(t,e){return t.concat(e)})),e}(),W=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,x(_,d,p)),e}(),H=function(t){return j(W,t)},J=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,H(function(t){return t.getDate()})),e}(),G=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,H(function(t){return t.getUTCFullYear()})),e}(),X=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,H(function(t){return t.getUTCMonth()+1})),e}(),Z=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,H(function(t){return t.getUTCHours()})),e}(),tt=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,H(function(t){return t.getUTCMinutes()})),e}(),et=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,H(function(t){return t.getUTCSeconds()})),e}(),nt=function(t){function e(){return u(this,e),i(this,Object.getPrototypeOf(e).apply(this,arguments))}return o(e,H(function(t){return t.getUTCMilliseconds()})),e}(),rt=function(){function t(e,n,r){u(this,t);var i=r.InputType,o=r.alt;this.result_types=new Set([r.ResultType,o.ResultType]),this.stack=e,this.isType=i.isType,this.args=n,this.op=r,this.alt_value=o.value}return a(t,[{key:\\\"run\\\",value:function(t){var e=this.stack,n=this.isType,r=this.op,i=[],o=!0,u=!1,a=void 0;try{for(var s,f=this.args[Symbol.iterator]();!(o=(s=f.next()).done);o=!0){var c=s.value.run(t);if(!n(c))return this.alt_value;i.push(c)}}catch(t){u=!0,a=t}finally{try{!o&&f.return&&f.return()}finally{if(u)throw a}}for(var l=i.length-1;l>=0;l--)e.push(i[l]);return r.run(t)}}]),t}(),it=function(){function t(e){u(this,t),this.stack=e}return a(t,[{key:\\\"run\\\",value:function(){return this.stack.pop()}}]),t}(),ot={$add:E,$subtract:A,$multiply:S,$divide:I,$mod:T,$abs:C,$ceil:L,$floor:U,$ln:R,$log10:$,$pow:N,$sqrt:M,$trunc:D,$concat:F,$toLower:q,$toUpper:V,$concatArrays:K,$dayOfMonth:J,$year:G,$month:X,$hour:Z,$minute:tt,$second:et,$millisecond:nt},ut=function(t,e,n){var r=ot[e];r||s(e),Array.isArray(n)||(n=[n]);for(var i=new r,o=[],u=[],a=[],f=0;f<n.length&&f<i.length;f++){var c=st(u,n[f]);if(c.ResultType){if(c.ResultType!==i.InputType)return i.alt;i.add(c)}else{if(c instanceof rt){if(!c.result_types.has(i.InputType))return i.alt;if(1===c.result_types.size){i.add(c);continue}}o.push(c),i.add(new it(a))}}return u.length?(t.push.apply(t,u),o.length?new rt(a,o,i):i):new i.ResultType(i.run())},at=function(t,e){var n=new Set,r=new Set;for(var i in e)(\\\"$\\\"===i[0]?n:r).add(i);if(n.size>1)throw Error(\\\"objects cannot have more than one operator\\\");if(n.size){var o=!0,u=!1,a=void 0;try{for(var s,f=r[Symbol.iterator]();!(o=(s=f.next()).done);o=!0){var c=s.value;throw Error(\\\"unexpected field '\\\"+c+\\\"'\\\")}}catch(t){u=!0,a=t}finally{try{!o&&f.return&&f.return()}finally{if(u)throw a}}var p=!0,h=!1,y=void 0;try{for(var d,v=n[Symbol.iterator]();!(p=(d=v.next()).done);p=!0){var g=d.value;return\\\"$literal\\\"===g?l.literal(e[g]):ut(t,g,e[g])}}catch(t){h=!0,y=t}finally{try{!p&&v.return&&v.return()}finally{if(h)throw y}}}var m=[],w={};for(var _ in e)w[_]=st(m,e[_]);var j=new b(w);return m.length?(t.push.apply(t,m),j):new l(j.run())},st=function(t,e){if(\\\"string\\\"==typeof e&&\\\"$\\\"===e[0]){var n=new c(e.substring(1));return t.push(n),new g(n)}return null==e||e.constructor!==Object?l.any(e):at(t,e)};e.exports=function(t){var e=[];return{ast:st(e,t),paths:e,has_refs:!!e.length}}},{\\\"../util.js\\\":21,\\\"./missing_symbol.js\\\":12,\\\"./path.js\\\":13}],10:[function(t,e,n){\\\"use strict\\\";function r(t,e){if(!(t instanceof e))throw new TypeError(\\\"Cannot call a class as a function\\\")}var i=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\\\"value\\\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),o=t(\\\"memoizee\\\"),u=t(\\\"../util.js\\\").get,a=t(\\\"./missing_symbol.js\\\"),s=function(){function t(e){r(this,t),this._doc=e,this.get=o(this.get)}return i(t,[{key:\\\"get\\\",value:function(t){var e=a;return u(this._doc,t.pieces,function(t,n){e=t[n]}),e}},{key:\\\"ensure\\\",value:function(t){var e=!0,n=!1,r=void 0;try{for(var i,o=t[Symbol.iterator]();!(e=(i=o.next()).done);e=!0){var u=i.value;if(this.get(u)===a)return!1}}catch(t){n=!0,r=t}finally{try{!e&&o.return&&o.return()}finally{if(n)throw r}}return!0}}]),t}();e.exports=s},{\\\"../util.js\\\":21,\\\"./missing_symbol.js\\\":12,memoizee:81}],11:[function(t,e,n){\\\"use strict\\\";function r(t){return Array.isArray(t)?t:Array.from(t)}function i(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++)n[e]=t[e];return n}return Array.from(t)}function o(t,e){if(!t)throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\");return!e||\\\"object\\\"!=typeof e&&\\\"function\\\"!=typeof e?t:e}function u(t,e){if(\\\"function\\\"!=typeof e&&null!==e)throw new TypeError(\\\"Super expression must either be null or a function, not \\\"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function a(t,e){if(!(t instanceof e))throw new TypeError(\\\"Cannot call a class as a function\\\")}var s=function t(e,n,r){null===e&&(e=Function.prototype);var i=Object.getOwnPropertyDescriptor(e,n);if(void 0===i){var o=Object.getPrototypeOf(e);return null===o?void 0:t(o,n,r)}if(\\\"value\\\"in i)return i.value;var u=i.get;if(void 0!==u)return u.call(r)},f=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\\\"value\\\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),c=t(\\\"../util.js\\\"),l=c.isObject,p=c.equal,h=c.unknownOp,y=t(\\\"./missing_symbol.js\\\"),d=t(\\\"./path.js\\\"),v=t(\\\"./fields.js\\\"),g=function t(e){if(\\\"number\\\"==typeof e)return!isNaN(e);if(\\\"string\\\"==typeof e)return!0;if(\\\"boolean\\\"==typeof e)return!0;if(!e)return!1;if(e.constructor===Object)return!1;if(Array.isArray(e)){var n=!0,r=!1,i=void 0;try{for(var o,u=e[Symbol.iterator]();!(n=(o=u.next()).done);n=!0)if(!t(o.value))return!1}catch(t){r=!0,i=t}finally{try{!n&&u.return&&u.return()}finally{if(r)throw i}}return!0}return e instanceof Date&&!isNaN(e.valueOf())},b=function(){function t(){a(this,t)}return f(t,[{key:\\\"getClauses\\\",value:function(){return this.is_index_matchable?[this]:[]}}]),t}(),m=function(t){function e(t){a(this,e);var n=o(this,Object.getPrototypeOf(e).call(this));return n.args=t,n}return u(e,b),e}(),w=function(t){function e(){return a(this,e),o(this,Object.getPrototypeOf(e).apply(this,arguments))}return u(e,m),f(e,[{key:\\\"getClauses\\\",value:function(){for(var t=[],e=0;e<this.args.length;e++){var n=this.args[e];n instanceof m?t.push.apply(t,i(n.getClauses())):n.is_index_matchable&&(n.parent=this,n.index=e,t.push(n))}return t}},{key:\\\"run\\\",value:function(t){var e=!0,n=!1,r=void 0;try{for(var i,o=this.args[Symbol.iterator]();!(e=(i=o.next()).done);e=!0)if(!i.value.run(t))return!1}catch(t){n=!0,r=t}finally{try{!e&&o.return&&o.return()}finally{if(n)throw r}}return!0}}]),e}(),_=function(t){function e(){return a(this,e),o(this,Object.getPrototypeOf(e).apply(this,arguments))}return u(e,m),f(e,[{key:\\\"getClauses\\\",value:function(){return[]}},{key:\\\"run\\\",value:function(t){var e=!0,n=!1,r=void 0;try{for(var i,o=this.args[Symbol.iterator]();!(e=(i=o.next()).done);e=!0)if(i.value.run(t))return!0}catch(t){n=!0,r=t}finally{try{!e&&o.return&&o.return()}finally{if(n)throw r}}return!1}}]),e}(),j=function(t){function e(){return a(this,e),o(this,Object.getPrototypeOf(e).apply(this,arguments))}return u(e,w),f(e,[{key:\\\"getClauses\\\",value:function(){return[]}},{key:\\\"run\\\",value:function(t){return!s(Object.getPrototypeOf(e.prototype),\\\"run\\\",this).call(this,t)}}]),e}(),x=function(t){function e(t,n){a(this,e);var r=o(this,Object.getPrototypeOf(e).call(this));return r.path=t,r.bool=n,r}return u(e,b),f(e,[{key:\\\"run\\\",value:function(t){return t.get(this.path)!==y===this.bool}},{key:\\\"is_index_matchable\\\",get:function(){return!!this.bool}}]),e}(),O=function(t){function e(t,n){a(this,e);var r=o(this,Object.getPrototypeOf(e).call(this));return r.path=t,r.value=n,r}return u(e,b),f(e,[{key:\\\"run\\\",value:function(t){var e=t.get(this.path);return e!==y&&p(e,this.value)}},{key:\\\"is_index_matchable\\\",get:function(){return g(this.value)}},{key:\\\"idb_key_range\\\",get:function(){return IDBKeyRange.only(this.value)}}]),e}(),k=function(t){function e(){return a(this,e),o(this,Object.getPrototypeOf(e).apply(this,arguments))}return u(e,O),f(e,[{key:\\\"run\\\",value:function(t){return!s(Object.getPrototypeOf(e.prototype),\\\"run\\\",this).call(this,t)}},{key:\\\"is_index_matchable\\\",get:function(){return!1}}]),e}(),E=function(t){function e(t,n,r){a(this,e);var i=o(this,Object.getPrototypeOf(e).call(this));return i.path=t,i.fns=n,i.values=r,i}return u(e,b),f(e,[{key:\\\"run\\\",value:function(t){var e=t.get(this.path);if(e===y||null==e)return!1;for(var n=this.fns,r=this.values,i=0;i<n.length;i++)if(!n[i](e,r[i]))return!1;return!0}},{key:\\\"is_index_matchable\\\",get:function(){return!0}}]),e}(),A=function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];return function(t){function n(t,r){return a(this,n),o(this,Object.getPrototypeOf(n).call(this,t,e,r))}return u(n,E),n}()},S=function(t,e){return t>e},I=function(t,e){return t>=e},T=function(t,e){return t<e},P=function(t,e){return t<=e},B=function(t){function e(){return a(this,e),o(this,Object.getPrototypeOf(e).apply(this,arguments))}return u(e,A(S)),f(e,[{key:\\\"idb_key_range\\\",get:function(){var t;return(t=IDBKeyRange).lowerBound.apply(t,i(this.values).concat([!0]))}}]),e}(),C=function(t){function e(){return a(this,e),o(this,Object.getPrototypeOf(e).apply(this,arguments))}return u(e,A(I)),f(e,[{key:\\\"idb_key_range\\\",get:function(){var t;return(t=IDBKeyRange).lowerBound.apply(t,i(this.values))}}]),e}(),L=function(t){function e(){return a(this,e),o(this,Object.getPrototypeOf(e).apply(this,arguments))}return u(e,A(T)),f(e,[{key:\\\"idb_key_range\\\",get:function(){var t;return(t=IDBKeyRange).upperBound.apply(t,i(this.values).concat([!0]))}}]),e}(),U=function(t){function e(){return a(this,e),o(this,Object.getPrototypeOf(e).apply(this,arguments))}return u(e,A(P)),f(e,[{key:\\\"idb_key_range\\\",get:function(){var t;return(t=IDBKeyRange).upperBound.apply(t,i(this.values))}}]),e}(),R=function(t){function e(){return a(this,e),o(this,Object.getPrototypeOf(e).apply(this,arguments))}return u(e,A(S,T)),f(e,[{key:\\\"idb_key_range\\\",get:function(){var t;return(t=IDBKeyRange).bound.apply(t,i(this.values).concat([!0,!0]))}}]),e}(),$=function(t){function e(){return a(this,e),o(this,Object.getPrototypeOf(e).apply(this,arguments))}return u(e,A(I,T)),f(e,[{key:\\\"idb_key_range\\\",get:function(){var t;return(t=IDBKeyRange).bound.apply(t,i(this.values).concat([!1,!0]))}}]),e}(),N=function(t){function e(){return a(this,e),o(this,Object.getPrototypeOf(e).apply(this,arguments))}return u(e,A(S,P)),f(e,[{key:\\\"idb_key_range\\\",get:function(){var t;return(t=IDBKeyRange).bound.apply(t,i(this.values).concat([!0,!1]))}}]),e}(),M=function(t){function e(){return a(this,e),o(this,Object.getPrototypeOf(e).apply(this,arguments))}return u(e,A(I,P)),f(e,[{key:\\\"idb_key_range\\\",get:function(){var t;return(t=IDBKeyRange).bound.apply(t,i(this.values))}}]),e}(),D=function(t){function e(t,n){a(this,e);var r=o(this,Object.getPrototypeOf(e).call(this));return r.path=t,r.op=n,r}return u(e,b),f(e,[{key:\\\"run\\\",value:function(t){var e=t.get(this.path);if(!e||!e[Symbol.iterator])return!1;var n=this.op,r=!0,i=!1,o=void 0;try{for(var u,a=e[Symbol.iterator]();!(r=(u=a.next()).done);r=!0){var s=u.value;if(l(s)&&n.run(new v(s)))return!0}}catch(t){i=!0,o=t}finally{try{!r&&a.return&&a.return()}finally{if(i)throw o}}return!1}},{key:\\\"is_index_matchable\\\",get:function(){return!1}}]),e}(),z=function(t,e){var n=[],r=!0,i=!1,o=void 0;try{for(var u,a=e[Symbol.iterator]();!(r=(u=a.next()).done);r=!0){var s=u.value,f=Q(s);f&&n.push(f)}}catch(t){i=!0,o=t}finally{try{!r&&a.return&&a.return()}finally{if(i)throw o}}return n.length&&t.push(new j(n)),!0},F={$and:function(t,e){var n=!0,r=!1,o=void 0;try{for(var u,a=e[Symbol.iterator]();!(n=(u=a.next()).done);n=!0){var s=u.value,f=Q(s);if(!1===f)return!1;f&&(f.constructor===w?t.push.apply(t,i(f.args)):t.push(f))}}catch(t){r=!0,o=t}finally{try{!n&&a.return&&a.return()}finally{if(r)throw o}}return!0},$or:function(t,e){var n=[],r=void 0,o=!0,u=!1,a=void 0;try{for(var s,f=e[Symbol.iterator]();!(o=(s=f.next()).done);o=!0){var c=s.value,l=Q(c);l?l.constructor===_?n.push.apply(n,i(l.args)):n.push(l):!1===l&&(r=!0)}}catch(t){u=!0,a=t}finally{try{!o&&f.return&&f.return()}finally{if(u)throw a}}if(n.length>1)t.push(new _(n));else if(n.length)t.push(n[0]);else if(r)return!1;return!0},$not:z,$nor:z},Y=[[R,\\\"$gt\\\",\\\"$lt\\\"],[$,\\\"$gte\\\",\\\"$lt\\\"],[N,\\\"$gt\\\",\\\"$lte\\\"],[M,\\\"$gte\\\",\\\"$lte\\\"],[B,\\\"$gt\\\"],[C,\\\"$gte\\\"],[L,\\\"$lt\\\"],[U,\\\"$lte\\\"]],q=function(t,e,n,i){var o=!0,u=!1,a=void 0;try{for(var s,f=Y[Symbol.iterator]();!(o=(s=f.next()).done);o=!0){var c=r(s.value),l=function(r,o){var u=[],a=!0,s=!1,f=void 0;try{for(var c,l=o[Symbol.iterator]();!(a=(c=l.next()).done);a=!0){var p=c.value;if(!i.has(p))return;var h=n[p];if(!g(h))return!1;u.push(h)}}catch(t){s=!0,f=t}finally{try{!a&&l.return&&l.return()}finally{if(s)throw f}}return t.push(new r(e,u)),!0}(c[0],c.slice(1));if(!1===l)return;if(l){i.delete(\\\"$gt\\\"),i.delete(\\\"$gte\\\"),i.delete(\\\"$lt\\\"),i.delete(\\\"$lte\\\");break}}}catch(t){u=!0,a=t}finally{try{!o&&f.return&&f.return()}finally{if(u)throw a}}return!0},V=function(t,e,n){var r=function(){return t.push(new O(e,n)),!0};if(null==n||n.constructor!==Object)return r();var i=new Set(Object.keys(n));if(i.has(\\\"$exists\\\")&&!n.$exists)return t.push(new x(e,!1)),!0;var o=[];if(i.has(\\\"$eq\\\")&&(o.push(new O(e,n.$eq)),i.delete(\\\"$eq\\\")),i.has(\\\"$ne\\\")&&(o.push(new k(e,n.$ne)),i.delete(\\\"$ne\\\")),!q(o,e,n,i))return!1;if(i.has(\\\"$in\\\")){var u=[],a=!0,s=!1,f=void 0;try{for(var c,l=n.$in[Symbol.iterator]();!(a=(c=l.next()).done);a=!0){var p=c.value;u.push(new O(e,p))}}catch(t){s=!0,f=t}finally{try{!a&&l.return&&l.return()}finally{if(s)throw f}}u.length>1?o.push(new _(u)):u.length&&o.push(u[0]),i.delete(\\\"$in\\\")}if(i.has(\\\"$nin\\\")){var y=!0,d=!1,v=void 0;try{for(var g,b=n.$nin[Symbol.iterator]();!(y=(g=b.next()).done);y=!0){var m=g.value;o.push(new k(e,m))}}catch(t){d=!0,v=t}finally{try{!y&&b.return&&b.return()}finally{if(d)throw v}}i.delete(\\\"$nin\\\")}if(i.has(\\\"$elemMatch\\\")){var w=Q(n.$elemMatch);w&&o.push(new D(e,w)),i.delete(\\\"$elemMatch\\\")}n.$exists&&!o.length&&(o.push(new x(e,!0)),i.delete(\\\"$exists\\\"));var j=!0,E=!1,A=void 0;try{for(var S,I=i[Symbol.iterator]();!(j=(S=I.next()).done);j=!0){var T=S.value;\\\"$\\\"===T[0]&&h(T)}}catch(t){E=!0,A=t}finally{try{!j&&I.return&&I.return()}finally{if(E)throw A}}return o.length?(t.push.apply(t,o),!0):r()},Q=function(t){var e=[];for(var n in t){var r=t[n],i=void 0;if(\\\"$\\\"!==n[0])i=V(e,new d(n),r);else{Array.isArray(r)||(r=[r]);var o=F[n];o||h(n),i=o(e,r)}if(!i)return i}if(e.length)return 1===e.length?e[0]:new w(e)};e.exports.build=Q,e.exports.Conjunction=w,e.exports.Disjunction=_,e.exports.Exists=x},{\\\"../util.js\\\":21,\\\"./fields.js\\\":10,\\\"./missing_symbol.js\\\":12,\\\"./path.js\\\":13}],12:[function(t,e,n){\\\"use strict\\\";e.exports=Symbol(\\\"missing\\\")},{}],13:[function(t,e,n){\\\"use strict\\\";function r(t,e){if(!(t instanceof e))throw new TypeError(\\\"Cannot call a class as a function\\\")}var i=t(\\\"../util.js\\\").toPathPieces;e.exports=function t(e){r(this,t),this.pieces=i(e),this.literal=e}},{\\\"../util.js\\\":21}],14:[function(t,e,n){\\\"use strict\\\";e.exports=function(t,e){var n=0;return function(r){n++<e?t(r):r()}}},{}],15:[function(t,e,n){\\\"use strict\\\";var r=\\\"function\\\"==typeof Symbol&&\\\"symbol\\\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\\\"function\\\"==typeof Symbol&&t.constructor===Symbol?\\\"symbol\\\":typeof t},i=function(){function t(t,e){var n=[],r=!0,i=!1,o=void 0;try{for(var u,a=t[Symbol.iterator]();!(r=(u=a.next()).done)&&(n.push(u.value),!e||n.length!==e);r=!0);}catch(t){i=!0,o=t}finally{try{!r&&a.return&&a.return()}finally{if(i)throw o}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError(\\\"Invalid attempt to destructure non-iterable instance\\\")}}(),o=t(\\\"./util.js\\\"),u=o.toPathPieces,a=o.set,s=o.remove2,f=o.copy,c=t(\\\"./lang/expression.js\\\"),l=t(\\\"./lang/fields.js\\\"),p=function(t,e,n){var r=!0,o=!1,u=void 0;try{for(var a,s=n[Symbol.iterator]();!(r=(a=s.next()).done);r=!0){var f=i(a.value,2),c=f[0];(0,f[1])(t,e,c)}}catch(t){o=!0,u=t}finally{try{!r&&s.return&&s.return()}finally{if(o)throw u}}return e},h=function(t){var e=c(t),n=e.ast,i=e.paths;if(!e.has_refs){var o=function(){var t=n.run();return{v:function(e){for(var n=arguments.length,r=Array(n>1?n-1:0),i=1;i<n;i++)r[i-1]=arguments[i];return a.apply(void 0,r.concat([t]))}}}();if(\\\"object\\\"===(void 0===o?\\\"undefined\\\":r(o)))return o.v}return function(t){for(var e=arguments.length,r=Array(e>1?e-1:0),o=1;o<e;o++)r[o-1]=arguments[o];var u=new l(t);u.ensure(i)&&a.apply(void 0,r.concat([n.run(u)]))}};e.exports=function(t,e){var n=function(t){return!!e[t]},r=!0;e.hasOwnProperty(\\\"_id\\\")&&(r=n(\\\"_id\\\"),delete e._id);var i=[],o=[],a=!0,c=function(t){if(n(t)!==a)throw Error(\\\"cannot mix inclusions and exclusions\\\")},l=function(t){a=n(t),l=c};for(var y in e){var d=e[y],v=u(y);\\\"boolean\\\"==typeof d||1===d||0===d?(l(y),i.push(v)):o.push([v,h(d)])}var g=[];o.length&&g.push(function(t,e){return p(t,e,o)}),i.length?function(){a===r&&i.push([\\\"_id\\\"]);var t=a?f:s;g.push(function(e){return t(e,i)})}():function(){var t=void 0;t=r?function(t,e){t.hasOwnProperty(\\\"_id\\\")&&(e._id=t._id)}:function(t,e){delete e._id},g.push(function(e,n){return t(e,n),n})}();return function(e){t(function(t,n){if(!n)return e(t);var r=n,i=!0,o=!1,u=void 0;try{for(var a,s=g[Symbol.iterator]();!(i=(a=s.next()).done);i=!0)r=(0,a.value)(n,r)}catch(t){o=!0,u=t}finally{try{!i&&s.return&&s.return()}finally{if(o)throw u}}e(null,r)})}}},{\\\"./lang/expression.js\\\":9,\\\"./lang/fields.js\\\":10,\\\"./util.js\\\":21}],16:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"./util.js\\\").getIDBError;e.exports=function(t,e){!function n(){t._next(function(t,i,o){if(!i)return e(t);var u=o.delete();u.onsuccess=n,u.onerror=function(t){return e(r(t))}})}()}},{\\\"./util.js\\\":21}],17:[function(t,e,n){\\\"use strict\\\";e.exports=function(t,e){var n=0;return function r(i){t(function(t,o){o?++n>e?i(null,o):r(i):i(t)})}}},{}],18:[function(t,e,n){\\\"use strict\\\";var r=function(){function t(t,e){var n=[],r=!0,i=!1,o=void 0;try{for(var u,a=t[Symbol.iterator]();!(r=(u=a.next()).done)&&(n.push(u.value),!e||n.length!==e);r=!0);}catch(t){i=!0,o=t}finally{try{!r&&a.return&&a.return()}finally{if(i)throw o}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError(\\\"Invalid attempt to destructure non-iterable instance\\\")}}(),i=t(\\\"./util.js\\\"),o=i.toPathPieces,u=i.isObject,a=i.equal,s=function(t,e,n,r){for(var i=0;i<n.length-1;i++){var o=n[i];if(t=t[o],e=e[o],u(t)){if(u(e))continue}else if(!u(e))return null;return r}var s=n[i];if(t.hasOwnProperty(s)){if(e.hasOwnProperty(s))return t=t[s],e=e[s],a(t,e)?0:(t<e?1:-1)*r}else if(!e.hasOwnProperty(s))return null;return r};e.exports=function(t,e){var n=[];for(var i in e)n.push([o(i),e[i]]);var u=function(t,e){var i=!0,o=!1,u=void 0;try{for(var a,f=n[Symbol.iterator]();!(i=(a=f.next()).done);i=!0){var c=r(a.value,2),l=c[0],p=c[1],h=s(t,e,l,p);if(h>0||h<0)return h}}catch(t){o=!0,u=t}finally{try{!i&&f.return&&f.return()}finally{if(o)throw u}}return-p},a=[],f=function(t){return t(null,a.pop())},c=function(e){var n=function(t){if(t)return e(t);a=a.sort(u),(c=f)(e)};!function e(){t(function(t,r){if(!r)return n(t);a.push(r),e()})}()};return function(t){return c(t)}}},{\\\"./util.js\\\":21}],19:[function(t,e,n){\\\"use strict\\\";function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var i=t(\\\"./util.js\\\"),o=i.toPathPieces,u=i.get;e.exports=function(t,e){var n=o(e.substring(1)),i=[],a=function(t){return t(null,i.pop())},s=function(t,e){var o=i.length;if(u(t,n,function(t,e){var n=t[e];if(n&&n[Symbol.iterator]){var o=!0,u=!1,a=void 0;try{for(var s,f=n[Symbol.iterator]();!(o=(s=f.next()).done);o=!0){var c=s.value;i.push(r({},e,c))}}catch(t){u=!0,a=t}finally{try{!o&&f.return&&f.return()}finally{if(u)throw a}}}}),o===i.length)return f(e);a(e)},f=function(e){t(function(t,n){t?e(t):n?s(n,e):(f=a)(e)})};return function(t){return f(t)}}},{\\\"./util.js\\\":21}],20:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"./util.js\\\"),i=r.toPathPieces,o=r.get,u=r.set,a=r.modify,s=r.remove1,f=r.rename,c=r.equal,l=r.unknownOp,p=r.getIDBError,h={};h.$set=function(t,e){return function(n){u(n,t,e)}},h.$unset=function(t){return function(e){return s(e,t)}},h.$rename=function(t,e){return function(n){f(n,t,e)}};var y=function(t,e,n){return function(r){a(r,t,e,n)}},d=function(t){return function(e,n){return y(e,function(e,r){var i=e[r];\\\"number\\\"==typeof i&&(e[r]=t(n,i))},function(t,e){return t[e]=0})}};h.$inc=d(function(t,e){return t+e}),h.$mul=d(function(t,e){return t*e});var v=function(t){return function(e,n){return y(e,function(e,r){t(n,e[r])&&(e[r]=n)},function(t,e){return t[e]=n})}};h.$min=v(function(t,e){return t<e}),h.$max=v(function(t,e){return t>e}),h.$push=function(t,e){return y(t,function(t,n){var r=t[n];Array.isArray(r)&&r.push(e)},function(t,n){return t[n]=[e]})},h.$pop=function(t,e){var n=void 0;return n=e<1?function(t){return t.shift()}:function(t){return t.pop()},function(e){o(e,t,function(t,e){var r=t[e];Array.isArray(r)&&n(r)})}},h.$pullAll=function(t,e){return function(n){o(n,t,function(t,n){var r=t[n];if(Array.isArray(r)){var i=[],o=!0,u=!1,a=void 0;try{for(var s,f=r[Symbol.iterator]();!(o=(s=f.next()).done);o=!0){var l=s.value;(function(t){var n=!0,r=!1,i=void 0;try{for(var o,u=e[Symbol.iterator]();!(n=(o=u.next()).done);n=!0){var a=o.value;if(c(t,a))return!0}}catch(t){r=!0,i=t}finally{try{!n&&u.return&&u.return()}finally{if(r)throw i}}})(l)||i.push(l)}}catch(t){u=!0,a=t}finally{try{!o&&f.return&&f.return()}finally{if(u)throw a}}t[n]=i}})}},h.$pull=function(t,e){return h.$pullAll(t,[e])},h.$addToSet=function(t,e){return function(n){o(n,t,function(t,n){var r=t[n];if(Array.isArray(r)){var i=!0,o=!1,u=void 0;try{for(var a,s=r[Symbol.iterator]();!(i=(a=s.next()).done);i=!0){var f=a.value;if(c(f,e))return}}catch(t){o=!0,u=t}finally{try{!i&&s.return&&s.return()}finally{if(o)throw u}}r.push(e)}})}};var g=function(t,e,n){if(\\\"$\\\"!==e[0])return t.push(h.$set(i(e),n));var r=h[e];r||l(e);for(var o in n)t.push(r(i(o),n[o]))};e.exports=function(t,e,n){var r=[];for(var i in e)g(r,i,e[i]);if(!r.length)return n(null);!function e(){t._next(function(t,i,o){if(!i)return n(t);var u=!0,a=!1,s=void 0;try{for(var f,c=r[Symbol.iterator]();!(u=(f=c.next()).done);u=!0)(0,f.value)(i)}catch(t){a=!0,s=t}finally{try{!u&&c.return&&c.return()}finally{if(a)throw s}}var l=o.update(i);l.onsuccess=e,l.onerror=function(t){return n(p(t))}})}()}},{\\\"./util.js\\\":21}],21:[function(t,e,n){\\\"use strict\\\";var r=\\\"function\\\"==typeof Symbol&&\\\"symbol\\\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\\\"function\\\"==typeof Symbol&&t.constructor===Symbol?\\\"symbol\\\":typeof t},i=t(\\\"deepmerge\\\"),o=t(\\\"clone\\\"),u=t(\\\"object-hash\\\"),a=function(t,e){for(var n=0;n<e.length-1;n++){var r=e[n];if(!t.hasOwnProperty(r))return;if(t=t[r],!c(t))return}if(t.hasOwnProperty(e[n]))return t},s=function(t,e,n){for(var r=n;r<e.length-1;r++)t[e[r]]={},t=t[e[r]];return t},f=function(t,e,n){(t=a(t,e))&&n(t,e[e.length-1])},c=function(t){return\\\"object\\\"===(void 0===t?\\\"undefined\\\":r(t))&&null!==t},l=function(t,e,n,r){var i=e[e.length-1],o=function(n){t=s(t,e,n),r(t,i)};if(!t.hasOwnProperty(e[0]))return o(0);if(e.length>1){t=t[e[0]];for(var u=1;u<e.length-1;u++){var a=e[u];if(!c(t[a]))return;if(Array.isArray(t)&&a<0)return;if(!t.hasOwnProperty(a))return o(u);t=t[a]}}n(t,i)},p=function t(e,n,r){for(var i in e)!function(i){var u=[],a=!0,s=!1,f=void 0;try{for(var c,l=r[Symbol.iterator]();!(a=(c=l.next()).done);a=!0){var p=c.value;if(p[0]===i){if(1===p.length)return;u.push(p.slice(1))}}}catch(t){s=!0,f=t}finally{try{!a&&l.return&&l.return()}finally{if(s)throw f}}if(u.length){var h=e[i];n[i]=new h.constructor,t(h,n[i],u)}else n[i]=o(e[i])}(i)},h=function(t,e,n){for(var r=0;r<n.length-1;r++){var i=n[r];if(t=t[i],!c(t))return;e[i]=new t.constructor,e=e[i]}if(t.hasOwnProperty(n[r]))return e[n[r]]=t[n[r]],t},y=function(t){if(void 0!==t)return u(t)};e.exports.toPathPieces=function(t){return t.split(\\\".\\\")},e.exports.exists=function(t,e){return!!a(t,e)},e.exports.create=s,e.exports.get=f,e.exports.set=function(t,e,n){var r=function(t,e){return t[e]=n};l(t,e,r,r)},e.exports.isObject=c,e.exports.modify=l,e.exports.remove1=function(t,e){for(var n=0;n<e.length-1;n++)if(t=t[e[n]],!c(t))return;if(Array.isArray(t)){var r=Number.parseFloat(e[n]);Number.isInteger(r)&&t.splice(r,1)}else delete t[e[n]]},e.exports.remove2=function(t,e){var n=new t.constructor;return p(t,n,e),n},e.exports.rename=function(t,e,n){f(t,e,function(t,e){t[n]=t[e],delete t[e]})},e.exports.copy=function(t,e){var n=[],r=!0,o=!1,u=void 0;try{for(var a,s=e[Symbol.iterator]();!(r=(a=s.next()).done);r=!0){var f=a.value,c=new t.constructor;h(t,c,f)&&n.push(c)}}catch(t){o=!0,u=t}finally{try{!r&&s.return&&s.return()}finally{if(o)throw u}}return n.reduce(i,{})},e.exports.equal=function(t,e){return y(t)===y(e)},e.exports.unknownOp=function(t){throw Error(\\\"unknown operator '\\\"+t+\\\"'\\\")},e.exports.hashify=y,e.exports.getIDBError=function(t){return Error(t.target.error.message)}},{clone:24,deepmerge:26,\\\"object-hash\\\":94}],22:[function(t,e,n){\\\"use strict\\\";function r(t){var e=t.length;if(e%4>0)throw new Error(\\\"Invalid string. Length must be a multiple of 4\\\");return\\\"=\\\"===t[e-2]?2:\\\"=\\\"===t[e-1]?1:0}function i(t){return u[t>>18&63]+u[t>>12&63]+u[t>>6&63]+u[63&t]}function o(t,e,n){for(var r,o=[],u=e;u<n;u+=3)r=(t[u]<<16)+(t[u+1]<<8)+t[u+2],o.push(i(r));return o.join(\\\"\\\")}n.byteLength=function(t){return 3*t.length/4-r(t)},n.toByteArray=function(t){var e,n,i,o,u,f=t.length;o=r(t),u=new s(3*f/4-o),n=o>0?f-4:f;var c=0;for(e=0;e<n;e+=4)i=a[t.charCodeAt(e)]<<18|a[t.charCodeAt(e+1)]<<12|a[t.charCodeAt(e+2)]<<6|a[t.charCodeAt(e+3)],u[c++]=i>>16&255,u[c++]=i>>8&255,u[c++]=255&i;return 2===o?(i=a[t.charCodeAt(e)]<<2|a[t.charCodeAt(e+1)]>>4,u[c++]=255&i):1===o&&(i=a[t.charCodeAt(e)]<<10|a[t.charCodeAt(e+1)]<<4|a[t.charCodeAt(e+2)]>>2,u[c++]=i>>8&255,u[c++]=255&i),u},n.fromByteArray=function(t){for(var e,n=t.length,r=n%3,i=\\\"\\\",a=[],s=0,f=n-r;s<f;s+=16383)a.push(o(t,s,s+16383>f?f:s+16383));return 1===r?(e=t[n-1],i+=u[e>>2],i+=u[e<<4&63],i+=\\\"==\\\"):2===r&&(e=(t[n-2]<<8)+t[n-1],i+=u[e>>10],i+=u[e>>4&63],i+=u[e<<2&63],i+=\\\"=\\\"),a.push(i),a.join(\\\"\\\")};for(var u=[],a=[],s=\\\"undefined\\\"!=typeof Uint8Array?Uint8Array:Array,f=\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\",c=0,l=f.length;c<l;++c)u[c]=f[c],a[f.charCodeAt(c)]=c;a[\\\"-\\\".charCodeAt(0)]=62,a[\\\"_\\\".charCodeAt(0)]=63},{}],23:[function(t,e,n){\\\"use strict\\\";function r(t){if(t>H)throw new RangeError(\\\"Invalid typed array length\\\");var e=new Uint8Array(t);return e.__proto__=i.prototype,e}function i(t,e,n){if(\\\"number\\\"==typeof t){if(\\\"string\\\"==typeof e)throw new Error(\\\"If encoding is specified then the first argument must be a string\\\");return s(t)}return o(t,e,n)}function o(t,e,n){if(\\\"number\\\"==typeof t)throw new TypeError('\\\"value\\\" argument must not be a number');return q(t)?l(t,e,n):\\\"string\\\"==typeof t?f(t,e):p(t)}function u(t){if(\\\"number\\\"!=typeof t)throw new TypeError('\\\"size\\\" argument must be a number');if(t<0)throw new RangeError('\\\"size\\\" argument must not be negative')}function a(t,e,n){return u(t),t<=0?r(t):void 0!==e?\\\"string\\\"==typeof n?r(t).fill(e,n):r(t).fill(e):r(t)}function s(t){return u(t),r(t<0?0:0|h(t))}function f(t,e){if(\\\"string\\\"==typeof e&&\\\"\\\"!==e||(e=\\\"utf8\\\"),!i.isEncoding(e))throw new TypeError('\\\"encoding\\\" must be a valid string encoding');var n=0|y(t,e),o=r(n),u=o.write(t,e);return u!==n&&(o=o.slice(0,u)),o}function c(t){for(var e=t.length<0?0:0|h(t.length),n=r(e),i=0;i<e;i+=1)n[i]=255&t[i];return n}function l(t,e,n){if(e<0||t.byteLength<e)throw new RangeError(\\\"'offset' is out of bounds\\\");if(t.byteLength<e+(n||0))throw new RangeError(\\\"'length' is out of bounds\\\");var r;return r=void 0===e&&void 0===n?new Uint8Array(t):void 0===n?new Uint8Array(t,e):new Uint8Array(t,e,n),r.__proto__=i.prototype,r}function p(t){if(i.isBuffer(t)){var e=0|h(t.length),n=r(e);return 0===n.length?n:(t.copy(n,0,0,e),n)}if(t){if(V(t)||\\\"length\\\"in t)return\\\"number\\\"!=typeof t.length||Q(t.length)?r(0):c(t);if(\\\"Buffer\\\"===t.type&&Array.isArray(t.data))return c(t.data)}throw new TypeError(\\\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\\\")}function h(t){if(t>=H)throw new RangeError(\\\"Attempt to allocate Buffer larger than maximum size: 0x\\\"+H.toString(16)+\\\" bytes\\\");return 0|t}function y(t,e){if(i.isBuffer(t))return t.length;if(V(t)||q(t))return t.byteLength;\\\"string\\\"!=typeof t&&(t=\\\"\\\"+t);var n=t.length;if(0===n)return 0;for(var r=!1;;)switch(e){case\\\"ascii\\\":case\\\"latin1\\\":case\\\"binary\\\":return n;case\\\"utf8\\\":case\\\"utf-8\\\":case void 0:return M(t).length;case\\\"ucs2\\\":case\\\"ucs-2\\\":case\\\"utf16le\\\":case\\\"utf-16le\\\":return 2*n;case\\\"hex\\\":return n>>>1;case\\\"base64\\\":return F(t).length;default:if(r)return M(t).length;e=(\\\"\\\"+e).toLowerCase(),r=!0}}function d(t,e,n){var r=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return\\\"\\\";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return\\\"\\\";if(n>>>=0,e>>>=0,n<=e)return\\\"\\\";for(t||(t=\\\"utf8\\\");;)switch(t){case\\\"hex\\\":return T(this,e,n);case\\\"utf8\\\":case\\\"utf-8\\\":return E(this,e,n);case\\\"ascii\\\":return S(this,e,n);case\\\"latin1\\\":case\\\"binary\\\":return I(this,e,n);case\\\"base64\\\":return k(this,e,n);case\\\"ucs2\\\":case\\\"ucs-2\\\":case\\\"utf16le\\\":case\\\"utf-16le\\\":return P(this,e,n);default:if(r)throw new TypeError(\\\"Unknown encoding: \\\"+t);t=(t+\\\"\\\").toLowerCase(),r=!0}}function v(t,e,n){var r=t[e];t[e]=t[n],t[n]=r}function g(t,e,n,r,o){if(0===t.length)return-1;if(\\\"string\\\"==typeof n?(r=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),n=+n,Q(n)&&(n=o?0:t.length-1),n<0&&(n=t.length+n),n>=t.length){if(o)return-1;n=t.length-1}else if(n<0){if(!o)return-1;n=0}if(\\\"string\\\"==typeof e&&(e=i.from(e,r)),i.isBuffer(e))return 0===e.length?-1:b(t,e,n,r,o);if(\\\"number\\\"==typeof e)return e&=255,\\\"function\\\"==typeof Uint8Array.prototype.indexOf?o?Uint8Array.prototype.indexOf.call(t,e,n):Uint8Array.prototype.lastIndexOf.call(t,e,n):b(t,[e],n,r,o);throw new TypeError(\\\"val must be string, number or Buffer\\\")}function b(t,e,n,r,i){function o(t,e){return 1===u?t[e]:t.readUInt16BE(e*u)}var u=1,a=t.length,s=e.length;if(void 0!==r&&(\\\"ucs2\\\"===(r=String(r).toLowerCase())||\\\"ucs-2\\\"===r||\\\"utf16le\\\"===r||\\\"utf-16le\\\"===r)){if(t.length<2||e.length<2)return-1;u=2,a/=2,s/=2,n/=2}var f;if(i){var c=-1;for(f=n;f<a;f++)if(o(t,f)===o(e,-1===c?0:f-c)){if(-1===c&&(c=f),f-c+1===s)return c*u}else-1!==c&&(f-=f-c),c=-1}else for(n+s>a&&(n=a-s),f=n;f>=0;f--){for(var l=!0,p=0;p<s;p++)if(o(t,f+p)!==o(e,p)){l=!1;break}if(l)return f}return-1}function m(t,e,n,r){n=Number(n)||0;var i=t.length-n;r?(r=Number(r))>i&&(r=i):r=i;var o=e.length;if(o%2!=0)throw new TypeError(\\\"Invalid hex string\\\");r>o/2&&(r=o/2);for(var u=0;u<r;++u){var a=parseInt(e.substr(2*u,2),16);if(Q(a))return u;t[n+u]=a}return u}function w(t,e,n,r){return Y(M(e,t.length-n),t,n,r)}function _(t,e,n,r){return Y(D(e),t,n,r)}function j(t,e,n,r){return _(t,e,n,r)}function x(t,e,n,r){return Y(F(e),t,n,r)}function O(t,e,n,r){return Y(z(e,t.length-n),t,n,r)}function k(t,e,n){return 0===e&&n===t.length?K.fromByteArray(t):K.fromByteArray(t.slice(e,n))}function E(t,e,n){n=Math.min(t.length,n);for(var r=[],i=e;i<n;){var o=t[i],u=null,a=o>239?4:o>223?3:o>191?2:1;if(i+a<=n){var s,f,c,l;switch(a){case 1:o<128&&(u=o);break;case 2:128==(192&(s=t[i+1]))&&(l=(31&o)<<6|63&s)>127&&(u=l);break;case 3:s=t[i+1],f=t[i+2],128==(192&s)&&128==(192&f)&&(l=(15&o)<<12|(63&s)<<6|63&f)>2047&&(l<55296||l>57343)&&(u=l);break;case 4:s=t[i+1],f=t[i+2],c=t[i+3],128==(192&s)&&128==(192&f)&&128==(192&c)&&(l=(15&o)<<18|(63&s)<<12|(63&f)<<6|63&c)>65535&&l<1114112&&(u=l)}}null===u?(u=65533,a=1):u>65535&&(u-=65536,r.push(u>>>10&1023|55296),u=56320|1023&u),r.push(u),i+=a}return A(r)}function A(t){var e=t.length;if(e<=J)return String.fromCharCode.apply(String,t);for(var n=\\\"\\\",r=0;r<e;)n+=String.fromCharCode.apply(String,t.slice(r,r+=J));return n}function S(t,e,n){var r=\\\"\\\";n=Math.min(t.length,n);for(var i=e;i<n;++i)r+=String.fromCharCode(127&t[i]);return r}function I(t,e,n){var r=\\\"\\\";n=Math.min(t.length,n);for(var i=e;i<n;++i)r+=String.fromCharCode(t[i]);return r}function T(t,e,n){var r=t.length;(!e||e<0)&&(e=0),(!n||n<0||n>r)&&(n=r);for(var i=\\\"\\\",o=e;o<n;++o)i+=N(t[o]);return i}function P(t,e,n){for(var r=t.slice(e,n),i=\\\"\\\",o=0;o<r.length;o+=2)i+=String.fromCharCode(r[o]+256*r[o+1]);return i}function B(t,e,n){if(t%1!=0||t<0)throw new RangeError(\\\"offset is not uint\\\");if(t+e>n)throw new RangeError(\\\"Trying to access beyond buffer length\\\")}function C(t,e,n,r,o,u){if(!i.isBuffer(t))throw new TypeError('\\\"buffer\\\" argument must be a Buffer instance');if(e>o||e<u)throw new RangeError('\\\"value\\\" argument is out of bounds');if(n+r>t.length)throw new RangeError(\\\"Index out of range\\\")}function L(t,e,n,r,i,o){if(n+r>t.length)throw new RangeError(\\\"Index out of range\\\");if(n<0)throw new RangeError(\\\"Index out of range\\\")}function U(t,e,n,r,i){return e=+e,n>>>=0,i||L(t,e,n,4,3.4028234663852886e38,-3.4028234663852886e38),W.write(t,e,n,r,23,4),n+4}function R(t,e,n,r,i){return e=+e,n>>>=0,i||L(t,e,n,8,1.7976931348623157e308,-1.7976931348623157e308),W.write(t,e,n,r,52,8),n+8}function $(t){if((t=t.trim().replace(G,\\\"\\\")).length<2)return\\\"\\\";for(;t.length%4!=0;)t+=\\\"=\\\";return t}function N(t){return t<16?\\\"0\\\"+t.toString(16):t.toString(16)}function M(t,e){e=e||1/0;for(var n,r=t.length,i=null,o=[],u=0;u<r;++u){if((n=t.charCodeAt(u))>55295&&n<57344){if(!i){if(n>56319){(e-=3)>-1&&o.push(239,191,189);continue}if(u+1===r){(e-=3)>-1&&o.push(239,191,189);continue}i=n;continue}if(n<56320){(e-=3)>-1&&o.push(239,191,189),i=n;continue}n=65536+(i-55296<<10|n-56320)}else i&&(e-=3)>-1&&o.push(239,191,189);if(i=null,n<128){if((e-=1)<0)break;o.push(n)}else if(n<2048){if((e-=2)<0)break;o.push(n>>6|192,63&n|128)}else if(n<65536){if((e-=3)<0)break;o.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error(\\\"Invalid code point\\\");if((e-=4)<0)break;o.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return o}function D(t){for(var e=[],n=0;n<t.length;++n)e.push(255&t.charCodeAt(n));return e}function z(t,e){for(var n,r,i,o=[],u=0;u<t.length&&!((e-=2)<0);++u)r=(n=t.charCodeAt(u))>>8,i=n%256,o.push(i),o.push(r);return o}function F(t){return K.toByteArray($(t))}function Y(t,e,n,r){for(var i=0;i<r&&!(i+n>=e.length||i>=t.length);++i)e[i+n]=t[i];return i}function q(t){return t instanceof ArrayBuffer||null!=t&&null!=t.constructor&&\\\"ArrayBuffer\\\"===t.constructor.name&&\\\"number\\\"==typeof t.byteLength}function V(t){return\\\"function\\\"==typeof ArrayBuffer.isView&&ArrayBuffer.isView(t)}function Q(t){return t!==t}var K=t(\\\"base64-js\\\"),W=t(\\\"ieee754\\\");n.Buffer=i,n.SlowBuffer=function(t){return+t!=t&&(t=0),i.alloc(+t)},n.INSPECT_MAX_BYTES=50;var H=2147483647;n.kMaxLength=H,i.TYPED_ARRAY_SUPPORT=function(){try{var t=new Uint8Array(1);return t.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===t.foo()}catch(t){return!1}}(),i.TYPED_ARRAY_SUPPORT||\\\"undefined\\\"==typeof console||\\\"function\\\"!=typeof console.error||console.error(\\\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\\\"),\\\"undefined\\\"!=typeof Symbol&&Symbol.species&&i[Symbol.species]===i&&Object.defineProperty(i,Symbol.species,{value:null,configurable:!0,enumerable:!1,writable:!1}),i.poolSize=8192,i.from=function(t,e,n){return o(t,e,n)},i.prototype.__proto__=Uint8Array.prototype,i.__proto__=Uint8Array,i.alloc=function(t,e,n){return a(t,e,n)},i.allocUnsafe=function(t){return s(t)},i.allocUnsafeSlow=function(t){return s(t)},i.isBuffer=function(t){return null!=t&&!0===t._isBuffer},i.compare=function(t,e){if(!i.isBuffer(t)||!i.isBuffer(e))throw new TypeError(\\\"Arguments must be Buffers\\\");if(t===e)return 0;for(var n=t.length,r=e.length,o=0,u=Math.min(n,r);o<u;++o)if(t[o]!==e[o]){n=t[o],r=e[o];break}return n<r?-1:r<n?1:0},i.isEncoding=function(t){switch(String(t).toLowerCase()){case\\\"hex\\\":case\\\"utf8\\\":case\\\"utf-8\\\":case\\\"ascii\\\":case\\\"latin1\\\":case\\\"binary\\\":case\\\"base64\\\":case\\\"ucs2\\\":case\\\"ucs-2\\\":case\\\"utf16le\\\":case\\\"utf-16le\\\":return!0;default:return!1}},i.concat=function(t,e){if(!Array.isArray(t))throw new TypeError('\\\"list\\\" argument must be an Array of Buffers');if(0===t.length)return i.alloc(0);var n;if(void 0===e)for(e=0,n=0;n<t.length;++n)e+=t[n].length;var r=i.allocUnsafe(e),o=0;for(n=0;n<t.length;++n){var u=t[n];if(!i.isBuffer(u))throw new TypeError('\\\"list\\\" argument must be an Array of Buffers');u.copy(r,o),o+=u.length}return r},i.byteLength=y,i.prototype._isBuffer=!0,i.prototype.swap16=function(){var t=this.length;if(t%2!=0)throw new RangeError(\\\"Buffer size must be a multiple of 16-bits\\\");for(var e=0;e<t;e+=2)v(this,e,e+1);return this},i.prototype.swap32=function(){var t=this.length;if(t%4!=0)throw new RangeError(\\\"Buffer size must be a multiple of 32-bits\\\");for(var e=0;e<t;e+=4)v(this,e,e+3),v(this,e+1,e+2);return this},i.prototype.swap64=function(){var t=this.length;if(t%8!=0)throw new RangeError(\\\"Buffer size must be a multiple of 64-bits\\\");for(var e=0;e<t;e+=8)v(this,e,e+7),v(this,e+1,e+6),v(this,e+2,e+5),v(this,e+3,e+4);return this},i.prototype.toString=function(){var t=this.length;return 0===t?\\\"\\\":0===arguments.length?E(this,0,t):d.apply(this,arguments)},i.prototype.equals=function(t){if(!i.isBuffer(t))throw new TypeError(\\\"Argument must be a Buffer\\\");return this===t||0===i.compare(this,t)},i.prototype.inspect=function(){var t=\\\"\\\",e=n.INSPECT_MAX_BYTES;return this.length>0&&(t=this.toString(\\\"hex\\\",0,e).match(/.{2}/g).join(\\\" \\\"),this.length>e&&(t+=\\\" ... \\\")),\\\"<Buffer \\\"+t+\\\">\\\"},i.prototype.compare=function(t,e,n,r,o){if(!i.isBuffer(t))throw new TypeError(\\\"Argument must be a Buffer\\\");if(void 0===e&&(e=0),void 0===n&&(n=t?t.length:0),void 0===r&&(r=0),void 0===o&&(o=this.length),e<0||n>t.length||r<0||o>this.length)throw new RangeError(\\\"out of range index\\\");if(r>=o&&e>=n)return 0;if(r>=o)return-1;if(e>=n)return 1;if(e>>>=0,n>>>=0,r>>>=0,o>>>=0,this===t)return 0;for(var u=o-r,a=n-e,s=Math.min(u,a),f=this.slice(r,o),c=t.slice(e,n),l=0;l<s;++l)if(f[l]!==c[l]){u=f[l],a=c[l];break}return u<a?-1:a<u?1:0},i.prototype.includes=function(t,e,n){return-1!==this.indexOf(t,e,n)},i.prototype.indexOf=function(t,e,n){return g(this,t,e,n,!0)},i.prototype.lastIndexOf=function(t,e,n){return g(this,t,e,n,!1)},i.prototype.write=function(t,e,n,r){if(void 0===e)r=\\\"utf8\\\",n=this.length,e=0;else if(void 0===n&&\\\"string\\\"==typeof e)r=e,n=this.length,e=0;else{if(!isFinite(e))throw new Error(\\\"Buffer.write(string, encoding, offset[, length]) is no longer supported\\\");e>>>=0,isFinite(n)?(n>>>=0,void 0===r&&(r=\\\"utf8\\\")):(r=n,n=void 0)}var i=this.length-e;if((void 0===n||n>i)&&(n=i),t.length>0&&(n<0||e<0)||e>this.length)throw new RangeError(\\\"Attempt to write outside buffer bounds\\\");r||(r=\\\"utf8\\\");for(var o=!1;;)switch(r){case\\\"hex\\\":return m(this,t,e,n);case\\\"utf8\\\":case\\\"utf-8\\\":return w(this,t,e,n);case\\\"ascii\\\":return _(this,t,e,n);case\\\"latin1\\\":case\\\"binary\\\":return j(this,t,e,n);case\\\"base64\\\":return x(this,t,e,n);case\\\"ucs2\\\":case\\\"ucs-2\\\":case\\\"utf16le\\\":case\\\"utf-16le\\\":return O(this,t,e,n);default:if(o)throw new TypeError(\\\"Unknown encoding: \\\"+r);r=(\\\"\\\"+r).toLowerCase(),o=!0}},i.prototype.toJSON=function(){return{type:\\\"Buffer\\\",data:Array.prototype.slice.call(this._arr||this,0)}};var J=4096;i.prototype.slice=function(t,e){var n=this.length;t=~~t,e=void 0===e?n:~~e,t<0?(t+=n)<0&&(t=0):t>n&&(t=n),e<0?(e+=n)<0&&(e=0):e>n&&(e=n),e<t&&(e=t);var r=this.subarray(t,e);return r.__proto__=i.prototype,r},i.prototype.readUIntLE=function(t,e,n){t>>>=0,e>>>=0,n||B(t,e,this.length);for(var r=this[t],i=1,o=0;++o<e&&(i*=256);)r+=this[t+o]*i;return r},i.prototype.readUIntBE=function(t,e,n){t>>>=0,e>>>=0,n||B(t,e,this.length);for(var r=this[t+--e],i=1;e>0&&(i*=256);)r+=this[t+--e]*i;return r},i.prototype.readUInt8=function(t,e){return t>>>=0,e||B(t,1,this.length),this[t]},i.prototype.readUInt16LE=function(t,e){return t>>>=0,e||B(t,2,this.length),this[t]|this[t+1]<<8},i.prototype.readUInt16BE=function(t,e){return t>>>=0,e||B(t,2,this.length),this[t]<<8|this[t+1]},i.prototype.readUInt32LE=function(t,e){return t>>>=0,e||B(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},i.prototype.readUInt32BE=function(t,e){return t>>>=0,e||B(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},i.prototype.readIntLE=function(t,e,n){t>>>=0,e>>>=0,n||B(t,e,this.length);for(var r=this[t],i=1,o=0;++o<e&&(i*=256);)r+=this[t+o]*i;return i*=128,r>=i&&(r-=Math.pow(2,8*e)),r},i.prototype.readIntBE=function(t,e,n){t>>>=0,e>>>=0,n||B(t,e,this.length);for(var r=e,i=1,o=this[t+--r];r>0&&(i*=256);)o+=this[t+--r]*i;return i*=128,o>=i&&(o-=Math.pow(2,8*e)),o},i.prototype.readInt8=function(t,e){return t>>>=0,e||B(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},i.prototype.readInt16LE=function(t,e){t>>>=0,e||B(t,2,this.length);var n=this[t]|this[t+1]<<8;return 32768&n?4294901760|n:n},i.prototype.readInt16BE=function(t,e){t>>>=0,e||B(t,2,this.length);var n=this[t+1]|this[t]<<8;return 32768&n?4294901760|n:n},i.prototype.readInt32LE=function(t,e){return t>>>=0,e||B(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},i.prototype.readInt32BE=function(t,e){return t>>>=0,e||B(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},i.prototype.readFloatLE=function(t,e){return t>>>=0,e||B(t,4,this.length),W.read(this,t,!0,23,4)},i.prototype.readFloatBE=function(t,e){return t>>>=0,e||B(t,4,this.length),W.read(this,t,!1,23,4)},i.prototype.readDoubleLE=function(t,e){return t>>>=0,e||B(t,8,this.length),W.read(this,t,!0,52,8)},i.prototype.readDoubleBE=function(t,e){return t>>>=0,e||B(t,8,this.length),W.read(this,t,!1,52,8)},i.prototype.writeUIntLE=function(t,e,n,r){t=+t,e>>>=0,n>>>=0,r||C(this,t,e,n,Math.pow(2,8*n)-1,0);var i=1,o=0;for(this[e]=255&t;++o<n&&(i*=256);)this[e+o]=t/i&255;return e+n},i.prototype.writeUIntBE=function(t,e,n,r){t=+t,e>>>=0,n>>>=0,r||C(this,t,e,n,Math.pow(2,8*n)-1,0);var i=n-1,o=1;for(this[e+i]=255&t;--i>=0&&(o*=256);)this[e+i]=t/o&255;return e+n},i.prototype.writeUInt8=function(t,e,n){return t=+t,e>>>=0,n||C(this,t,e,1,255,0),this[e]=255&t,e+1},i.prototype.writeUInt16LE=function(t,e,n){return t=+t,e>>>=0,n||C(this,t,e,2,65535,0),this[e]=255&t,this[e+1]=t>>>8,e+2},i.prototype.writeUInt16BE=function(t,e,n){return t=+t,e>>>=0,n||C(this,t,e,2,65535,0),this[e]=t>>>8,this[e+1]=255&t,e+2},i.prototype.writeUInt32LE=function(t,e,n){return t=+t,e>>>=0,n||C(this,t,e,4,4294967295,0),this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t,e+4},i.prototype.writeUInt32BE=function(t,e,n){return t=+t,e>>>=0,n||C(this,t,e,4,4294967295,0),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t,e+4},i.prototype.writeIntLE=function(t,e,n,r){if(t=+t,e>>>=0,!r){var i=Math.pow(2,8*n-1);C(this,t,e,n,i-1,-i)}var o=0,u=1,a=0;for(this[e]=255&t;++o<n&&(u*=256);)t<0&&0===a&&0!==this[e+o-1]&&(a=1),this[e+o]=(t/u>>0)-a&255;return e+n},i.prototype.writeIntBE=function(t,e,n,r){if(t=+t,e>>>=0,!r){var i=Math.pow(2,8*n-1);C(this,t,e,n,i-1,-i)}var o=n-1,u=1,a=0;for(this[e+o]=255&t;--o>=0&&(u*=256);)t<0&&0===a&&0!==this[e+o+1]&&(a=1),this[e+o]=(t/u>>0)-a&255;return e+n},i.prototype.writeInt8=function(t,e,n){return t=+t,e>>>=0,n||C(this,t,e,1,127,-128),t<0&&(t=255+t+1),this[e]=255&t,e+1},i.prototype.writeInt16LE=function(t,e,n){return t=+t,e>>>=0,n||C(this,t,e,2,32767,-32768),this[e]=255&t,this[e+1]=t>>>8,e+2},i.prototype.writeInt16BE=function(t,e,n){return t=+t,e>>>=0,n||C(this,t,e,2,32767,-32768),this[e]=t>>>8,this[e+1]=255&t,e+2},i.prototype.writeInt32LE=function(t,e,n){return t=+t,e>>>=0,n||C(this,t,e,4,2147483647,-2147483648),this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24,e+4},i.prototype.writeInt32BE=function(t,e,n){return t=+t,e>>>=0,n||C(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t,e+4},i.prototype.writeFloatLE=function(t,e,n){return U(this,t,e,!0,n)},i.prototype.writeFloatBE=function(t,e,n){return U(this,t,e,!1,n)},i.prototype.writeDoubleLE=function(t,e,n){return R(this,t,e,!0,n)},i.prototype.writeDoubleBE=function(t,e,n){return R(this,t,e,!1,n)},i.prototype.copy=function(t,e,n,r){if(n||(n=0),r||0===r||(r=this.length),e>=t.length&&(e=t.length),e||(e=0),r>0&&r<n&&(r=n),r===n)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError(\\\"targetStart out of bounds\\\");if(n<0||n>=this.length)throw new RangeError(\\\"sourceStart out of bounds\\\");if(r<0)throw new RangeError(\\\"sourceEnd out of bounds\\\");r>this.length&&(r=this.length),t.length-e<r-n&&(r=t.length-e+n);var i,o=r-n;if(this===t&&n<e&&e<r)for(i=o-1;i>=0;--i)t[i+e]=this[i+n];else if(o<1e3)for(i=0;i<o;++i)t[i+e]=this[i+n];else Uint8Array.prototype.set.call(t,this.subarray(n,n+o),e);return o},i.prototype.fill=function(t,e,n,r){if(\\\"string\\\"==typeof t){if(\\\"string\\\"==typeof e?(r=e,e=0,n=this.length):\\\"string\\\"==typeof n&&(r=n,n=this.length),1===t.length){var o=t.charCodeAt(0);o<256&&(t=o)}if(void 0!==r&&\\\"string\\\"!=typeof r)throw new TypeError(\\\"encoding must be a string\\\");if(\\\"string\\\"==typeof r&&!i.isEncoding(r))throw new TypeError(\\\"Unknown encoding: \\\"+r)}else\\\"number\\\"==typeof t&&(t&=255);if(e<0||this.length<e||this.length<n)throw new RangeError(\\\"Out of range index\\\");if(n<=e)return this;e>>>=0,n=void 0===n?this.length:n>>>0,t||(t=0);var u;if(\\\"number\\\"==typeof t)for(u=e;u<n;++u)this[u]=t;else{var a=i.isBuffer(t)?t:new i(t,r),s=a.length;for(u=0;u<n-e;++u)this[u+e]=a[u%s]}return this};var G=/[^+/0-9A-Za-z-_]/g},{\\\"base64-js\\\":22,ieee754:72}],24:[function(t,e,n){(function(t){var n=function(){\\\"use strict\\\";function e(t,e){return null!=e&&t instanceof e}function n(r,s,f,c,l){function p(r,f){if(null===r)return null;if(0===f)return r;var v,g;if(\\\"object\\\"!=typeof r)return r;if(e(r,o))v=new o;else if(e(r,u))v=new u;else if(e(r,a))v=new a(function(t,e){r.then(function(e){t(p(e,f-1))},function(t){e(p(t,f-1))})});else if(n.__isArray(r))v=[];else if(n.__isRegExp(r))v=new RegExp(r.source,i(r)),r.lastIndex&&(v.lastIndex=r.lastIndex);else if(n.__isDate(r))v=new Date(r.getTime());else{if(d&&t.isBuffer(r))return v=new t(r.length),r.copy(v),v;e(r,Error)?v=Object.create(r):void 0===c?(g=Object.getPrototypeOf(r),v=Object.create(g)):(v=Object.create(c),g=c)}if(s){var b=h.indexOf(r);if(-1!=b)return y[b];h.push(r),y.push(v)}e(r,o)&&r.forEach(function(t,e){var n=p(e,f-1),r=p(t,f-1);v.set(n,r)}),e(r,u)&&r.forEach(function(t){var e=p(t,f-1);v.add(e)});for(var m in r){var w;g&&(w=Object.getOwnPropertyDescriptor(g,m)),w&&null==w.set||(v[m]=p(r[m],f-1))}if(Object.getOwnPropertySymbols)for(var _=Object.getOwnPropertySymbols(r),m=0;m<_.length;m++){var j=_[m];(!(k=Object.getOwnPropertyDescriptor(r,j))||k.enumerable||l)&&(v[j]=p(r[j],f-1),k.enumerable||Object.defineProperty(v,j,{enumerable:!1}))}if(l)for(var x=Object.getOwnPropertyNames(r),m=0;m<x.length;m++){var O=x[m],k=Object.getOwnPropertyDescriptor(r,O);k&&k.enumerable||(v[O]=p(r[O],f-1),Object.defineProperty(v,O,{enumerable:!1}))}return v}\\\"object\\\"==typeof s&&(f=s.depth,c=s.prototype,l=s.includeNonEnumerable,s=s.circular);var h=[],y=[],d=void 0!==t;return void 0===s&&(s=!0),void 0===f&&(f=1/0),p(r,f)}function r(t){return Object.prototype.toString.call(t)}function i(t){var e=\\\"\\\";return t.global&&(e+=\\\"g\\\"),t.ignoreCase&&(e+=\\\"i\\\"),t.multiline&&(e+=\\\"m\\\"),e}var o;try{o=Map}catch(t){o=function(){}}var u;try{u=Set}catch(t){u=function(){}}var a;try{a=Promise}catch(t){a=function(){}}return n.clonePrototype=function(t){if(null===t)return null;var e=function(){};return e.prototype=t,new e},n.__objToStr=r,n.__isDate=function(t){return\\\"object\\\"==typeof t&&\\\"[object Date]\\\"===r(t)},n.__isArray=function(t){return\\\"object\\\"==typeof t&&\\\"[object Array]\\\"===r(t)},n.__isRegExp=function(t){return\\\"object\\\"==typeof t&&\\\"[object RegExp]\\\"===r(t)},n.__getRegExpFlags=i,n}();\\\"object\\\"==typeof e&&e.exports&&(e.exports=n)}).call(this,t(\\\"buffer\\\").Buffer)},{buffer:23}],25:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"es5-ext/object/assign\\\"),i=t(\\\"es5-ext/object/normalize-options\\\"),o=t(\\\"es5-ext/object/is-callable\\\"),u=t(\\\"es5-ext/string/#/contains\\\");(e.exports=function(t,e){var n,o,a,s,f;return arguments.length<2||\\\"string\\\"!=typeof t?(s=e,e=t,t=null):s=arguments[2],null==t?(n=a=!0,o=!1):(n=u.call(t,\\\"c\\\"),o=u.call(t,\\\"e\\\"),a=u.call(t,\\\"w\\\")),f={value:e,configurable:n,enumerable:o,writable:a},s?r(i(s),f):f}).gs=function(t,e,n){var a,s,f,c;return\\\"string\\\"!=typeof t?(f=n,n=e,e=t,t=null):f=arguments[3],null==e?e=void 0:o(e)?null==n?n=void 0:o(n)||(f=n,n=void 0):(f=e,e=n=void 0),null==t?(a=!0,s=!1):(a=u.call(t,\\\"c\\\"),s=u.call(t,\\\"e\\\")),c={get:e,set:n,configurable:a,enumerable:s},f?r(i(f),c):c}},{\\\"es5-ext/object/assign\\\":46,\\\"es5-ext/object/is-callable\\\":50,\\\"es5-ext/object/normalize-options\\\":58,\\\"es5-ext/string/#/contains\\\":61}],26:[function(t,e,n){\\\"use strict\\\";function r(t){return!!t&&\\\"object\\\"==typeof t}function i(t){var e=Object.prototype.toString.call(t);return\\\"[object RegExp]\\\"!==e&&\\\"[object Date]\\\"!==e}function o(t){return Array.isArray(t)?[]:{}}function u(t,e){return e&&!0===e.clone&&c(t)?f(o(t),t,e):t}function a(t,e,n){var r=t.slice();return e.forEach(function(e,i){void 0===r[i]?r[i]=u(e,n):c(e)?r[i]=f(t[i],e,n):-1===t.indexOf(e)&&r.push(u(e,n))}),r}function s(t,e,n){var r={};return c(t)&&Object.keys(t).forEach(function(e){r[e]=u(t[e],n)}),Object.keys(e).forEach(function(i){c(e[i])&&t[i]?r[i]=f(t[i],e[i],n):r[i]=u(e[i],n)}),r}function f(t,e,n){var r=Array.isArray(e),i=Array.isArray(t),o=n||{arrayMerge:a};return r===i?r?(o.arrayMerge||a)(t,e,n):s(t,e,n):u(e,n)}var c=function(t){return r(t)&&i(t)};f.all=function(t,e){if(!Array.isArray(t)||t.length<2)throw new Error(\\\"first argument should be an array with at least two elements\\\");return t.reduce(function(t,n){return f(t,n,e)})};var l=f;e.exports=l},{}],27:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"../../number/is-nan\\\"),i=t(\\\"../../number/to-pos-integer\\\"),o=t(\\\"../../object/valid-value\\\"),u=Array.prototype.indexOf,a=Object.prototype.hasOwnProperty,s=Math.abs,f=Math.floor;e.exports=function(t){var e,n,c,l;if(!r(t))return u.apply(this,arguments);for(n=i(o(this).length),c=arguments[1],e=c=isNaN(c)?0:c>=0?f(c):i(this.length)-f(s(c));e<n;++e)if(a.call(this,e)&&(l=this[e],r(l)))return e;return-1}},{\\\"../../number/is-nan\\\":40,\\\"../../number/to-pos-integer\\\":44,\\\"../../object/valid-value\\\":60}],28:[function(t,e,n){\\\"use strict\\\";e.exports=t(\\\"./is-implemented\\\")()?Array.from:t(\\\"./shim\\\")},{\\\"./is-implemented\\\":29,\\\"./shim\\\":30}],29:[function(t,e,n){\\\"use strict\\\";e.exports=function(){var t,e,n=Array.from;return\\\"function\\\"==typeof n&&(t=[\\\"raz\\\",\\\"dwa\\\"],e=n(t),Boolean(e&&e!==t&&\\\"dwa\\\"===e[1]))}},{}],30:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"es6-symbol\\\").iterator,i=t(\\\"../../function/is-arguments\\\"),o=t(\\\"../../function/is-function\\\"),u=t(\\\"../../number/to-pos-integer\\\"),a=t(\\\"../../object/valid-callable\\\"),s=t(\\\"../../object/valid-value\\\"),f=t(\\\"../../object/is-value\\\"),c=t(\\\"../../string/is-string\\\"),l=Array.isArray,p=Function.prototype.call,h={configurable:!0,enumerable:!0,writable:!0,value:null},y=Object.defineProperty;e.exports=function(t){var e,n,d,v,g,b,m,w,_,j,x=arguments[1],O=arguments[2];if(t=Object(s(t)),f(x)&&a(x),this&&this!==Array&&o(this))e=this;else{if(!x){if(i(t))return 1!==(g=t.length)?Array.apply(null,t):(v=new Array(1),v[0]=t[0],v);if(l(t)){for(v=new Array(g=t.length),n=0;n<g;++n)v[n]=t[n];return v}}v=[]}if(!l(t))if(void 0!==(_=t[r])){for(m=a(_).call(t),e&&(v=new e),w=m.next(),n=0;!w.done;)j=x?p.call(x,O,w.value,n):w.value,e?(h.value=j,y(v,n,h)):v[n]=j,w=m.next(),++n;g=n}else if(c(t)){for(g=t.length,e&&(v=new e),n=0,d=0;n<g;++n)j=t[n],n+1<g&&(b=j.charCodeAt(0))>=55296&&b<=56319&&(j+=t[++n]),j=x?p.call(x,O,j,d):j,e?(h.value=j,y(v,d,h)):v[d]=j,++d;g=d}if(void 0===g)for(g=u(t.length),e&&(v=new e(g)),n=0;n<g;++n)j=x?p.call(x,O,t[n],n):t[n],e?(h.value=j,y(v,n,h)):v[n]=j;return e&&(h.value=null,v.length=g),v}},{\\\"../../function/is-arguments\\\":34,\\\"../../function/is-function\\\":35,\\\"../../number/to-pos-integer\\\":44,\\\"../../object/is-value\\\":52,\\\"../../object/valid-callable\\\":59,\\\"../../object/valid-value\\\":60,\\\"../../string/is-string\\\":64,\\\"es6-symbol\\\":65}],31:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"./from\\\"),i=Array.isArray;e.exports=function(t){return i(t)?t:r(t)}},{\\\"./from\\\":28}],32:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"../object/assign\\\"),i=t(\\\"../object/is-object\\\"),o=t(\\\"../object/is-value\\\"),u=Error.captureStackTrace;n=e.exports=function(t){var e=new Error(t),a=arguments[1],s=arguments[2];return o(s)||i(a)&&(s=a,a=null),o(s)&&r(e,s),o(a)&&(e.code=a),u&&u(e,n),e}},{\\\"../object/assign\\\":46,\\\"../object/is-object\\\":51,\\\"../object/is-value\\\":52}],33:[function(t,e,n){\\\"use strict\\\";var r,i,o,u,a=t(\\\"../number/to-pos-integer\\\"),s=function(t,e){return e};try{Object.defineProperty(s,\\\"length\\\",{configurable:!0,writable:!1,enumerable:!1,value:1})}catch(t){}1===s.length?(r={configurable:!0,writable:!1,enumerable:!1},i=Object.defineProperty,e.exports=function(t,e){return e=a(e),t.length===e?t:(r.value=e,i(t,\\\"length\\\",r))}):(u=t(\\\"../object/mixin\\\"),o=function(){var t=[];return function(e){var n,r=0;if(t[e])return t[e];for(n=[];e--;)n.push(\\\"a\\\"+(++r).toString(36));return new Function(\\\"fn\\\",\\\"return function (\\\"+n.join(\\\", \\\")+\\\") { return fn.apply(this, arguments); };\\\")}}(),e.exports=function(t,e){var n;if(e=a(e),t.length===e)return t;n=o(e)(t);try{u(n,t)}catch(t){}return n})},{\\\"../number/to-pos-integer\\\":44,\\\"../object/mixin\\\":57}],34:[function(t,e,n){\\\"use strict\\\";var r=Object.prototype.toString,i=r.call(function(){return arguments}());e.exports=function(t){return r.call(t)===i}},{}],35:[function(t,e,n){\\\"use strict\\\";var r=Object.prototype.toString,i=r.call(t(\\\"./noop\\\"));e.exports=function(t){return\\\"function\\\"==typeof t&&r.call(t)===i}},{\\\"./noop\\\":36}],36:[function(t,e,n){\\\"use strict\\\";e.exports=function(){}},{}],37:[function(t,e,n){\\\"use strict\\\";e.exports=t(\\\"./is-implemented\\\")()?Math.sign:t(\\\"./shim\\\")},{\\\"./is-implemented\\\":38,\\\"./shim\\\":39}],38:[function(t,e,n){\\\"use strict\\\";e.exports=function(){var t=Math.sign;return\\\"function\\\"==typeof t&&(1===t(10)&&-1===t(-20))}},{}],39:[function(t,e,n){\\\"use strict\\\";e.exports=function(t){return t=Number(t),isNaN(t)||0===t?t:t>0?1:-1}},{}],40:[function(t,e,n){\\\"use strict\\\";e.exports=t(\\\"./is-implemented\\\")()?Number.isNaN:t(\\\"./shim\\\")},{\\\"./is-implemented\\\":41,\\\"./shim\\\":42}],41:[function(t,e,n){\\\"use strict\\\";e.exports=function(){var t=Number.isNaN;return\\\"function\\\"==typeof t&&(!t({})&&t(NaN)&&!t(34))}},{}],42:[function(t,e,n){\\\"use strict\\\";e.exports=function(t){return t!==t}},{}],43:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"../math/sign\\\"),i=Math.abs,o=Math.floor;e.exports=function(t){return isNaN(t)?0:0!==(t=Number(t))&&isFinite(t)?r(t)*o(i(t)):t}},{\\\"../math/sign\\\":37}],44:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"./to-integer\\\"),i=Math.max;e.exports=function(t){return i(0,r(t))}},{\\\"./to-integer\\\":43}],45:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"./valid-callable\\\"),i=t(\\\"./valid-value\\\"),o=Function.prototype.bind,u=Function.prototype.call,a=Object.keys,s=Object.prototype.propertyIsEnumerable;e.exports=function(t,e){return function(n,f){var c,l=arguments[2],p=arguments[3];return n=Object(i(n)),r(f),c=a(n),p&&c.sort(\\\"function\\\"==typeof p?o.call(p,n):void 0),\\\"function\\\"!=typeof t&&(t=c[t]),u.call(t,c,function(t,r){return s.call(n,t)?u.call(f,l,n[t],t,n,r):e})}}},{\\\"./valid-callable\\\":59,\\\"./valid-value\\\":60}],46:[function(t,e,n){\\\"use strict\\\";e.exports=t(\\\"./is-implemented\\\")()?Object.assign:t(\\\"./shim\\\")},{\\\"./is-implemented\\\":47,\\\"./shim\\\":48}],47:[function(t,e,n){\\\"use strict\\\";e.exports=function(){var t,e=Object.assign;return\\\"function\\\"==typeof e&&(t={foo:\\\"raz\\\"},e(t,{bar:\\\"dwa\\\"},{trzy:\\\"trzy\\\"}),t.foo+t.bar+t.trzy===\\\"razdwatrzy\\\")}},{}],48:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"../keys\\\"),i=t(\\\"../valid-value\\\"),o=Math.max;e.exports=function(t,e){var n,u,a,s=o(arguments.length,2);for(t=Object(i(t)),a=function(r){try{t[r]=e[r]}catch(t){n||(n=t)}},u=1;u<s;++u)e=arguments[u],r(e).forEach(a);if(void 0!==n)throw n;return t}},{\\\"../keys\\\":53,\\\"../valid-value\\\":60}],49:[function(t,e,n){\\\"use strict\\\";e.exports=t(\\\"./_iterate\\\")(\\\"forEach\\\")},{\\\"./_iterate\\\":45}],50:[function(t,e,n){\\\"use strict\\\";e.exports=function(t){return\\\"function\\\"==typeof t}},{}],51:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"./is-value\\\"),i={function:!0,object:!0};e.exports=function(t){return r(t)&&i[typeof t]||!1}},{\\\"./is-value\\\":52}],52:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"../function/noop\\\")();e.exports=function(t){return t!==r&&null!==t}},{\\\"../function/noop\\\":36}],53:[function(t,e,n){\\\"use strict\\\";e.exports=t(\\\"./is-implemented\\\")()?Object.keys:t(\\\"./shim\\\")},{\\\"./is-implemented\\\":54,\\\"./shim\\\":55}],54:[function(t,e,n){\\\"use strict\\\";e.exports=function(){try{return Object.keys(\\\"primitive\\\"),!0}catch(t){return!1}}},{}],55:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"../is-value\\\"),i=Object.keys;e.exports=function(t){return i(r(t)?Object(t):t)}},{\\\"../is-value\\\":52}],56:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"./valid-callable\\\"),i=t(\\\"./for-each\\\"),o=Function.prototype.call;e.exports=function(t,e){var n={},u=arguments[2];return r(e),i(t,function(t,r,i,a){n[r]=o.call(e,u,t,r,i,a)}),n}},{\\\"./for-each\\\":49,\\\"./valid-callable\\\":59}],57:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"./valid-value\\\"),i=Object.defineProperty,o=Object.getOwnPropertyDescriptor,u=Object.getOwnPropertyNames,a=Object.getOwnPropertySymbols;e.exports=function(t,e){var n,s=Object(r(e));if(t=Object(r(t)),u(s).forEach(function(r){try{i(t,r,o(e,r))}catch(t){n=t}}),\\\"function\\\"==typeof a&&a(s).forEach(function(r){try{i(t,r,o(e,r))}catch(t){n=t}}),void 0!==n)throw n;return t}},{\\\"./valid-value\\\":60}],58:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"./is-value\\\"),i=Array.prototype.forEach,o=Object.create,u=function(t,e){var n;for(n in t)e[n]=t[n]};e.exports=function(t){var e=o(null);return i.call(arguments,function(t){r(t)&&u(Object(t),e)}),e}},{\\\"./is-value\\\":52}],59:[function(t,e,n){\\\"use strict\\\";e.exports=function(t){if(\\\"function\\\"!=typeof t)throw new TypeError(t+\\\" is not a function\\\");return t}},{}],60:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"./is-value\\\");e.exports=function(t){if(!r(t))throw new TypeError(\\\"Cannot use null or undefined\\\");return t}},{\\\"./is-value\\\":52}],61:[function(t,e,n){\\\"use strict\\\";e.exports=t(\\\"./is-implemented\\\")()?String.prototype.contains:t(\\\"./shim\\\")},{\\\"./is-implemented\\\":62,\\\"./shim\\\":63}],62:[function(t,e,n){\\\"use strict\\\";var r=\\\"razdwatrzy\\\";e.exports=function(){return\\\"function\\\"==typeof r.contains&&(!0===r.contains(\\\"dwa\\\")&&!1===r.contains(\\\"foo\\\"))}},{}],63:[function(t,e,n){\\\"use strict\\\";var r=String.prototype.indexOf;e.exports=function(t){return r.call(this,t,arguments[1])>-1}},{}],64:[function(t,e,n){\\\"use strict\\\";var r=Object.prototype.toString,i=r.call(\\\"\\\");e.exports=function(t){return\\\"string\\\"==typeof t||t&&\\\"object\\\"==typeof t&&(t instanceof String||r.call(t)===i)||!1}},{}],65:[function(t,e,n){\\\"use strict\\\";e.exports=t(\\\"./is-implemented\\\")()?Symbol:t(\\\"./polyfill\\\")},{\\\"./is-implemented\\\":66,\\\"./polyfill\\\":68}],66:[function(t,e,n){\\\"use strict\\\";var r={object:!0,symbol:!0};e.exports=function(){var t;if(\\\"function\\\"!=typeof Symbol)return!1;t=Symbol(\\\"test symbol\\\");try{String(t)}catch(t){return!1}return!!r[typeof Symbol.iterator]&&(!!r[typeof Symbol.toPrimitive]&&!!r[typeof Symbol.toStringTag])}},{}],67:[function(t,e,n){\\\"use strict\\\";e.exports=function(t){return!!t&&(\\\"symbol\\\"==typeof t||!!t.constructor&&(\\\"Symbol\\\"===t.constructor.name&&\\\"Symbol\\\"===t[t.constructor.toStringTag]))}},{}],68:[function(t,e,n){\\\"use strict\\\";var r,i,o,u,a=t(\\\"d\\\"),s=t(\\\"./validate-symbol\\\"),f=Object.create,c=Object.defineProperties,l=Object.defineProperty,p=Object.prototype,h=f(null);if(\\\"function\\\"==typeof Symbol){r=Symbol;try{String(r()),u=!0}catch(t){}}var y=function(){var t=f(null);return function(e){for(var n,r,i=0;t[e+(i||\\\"\\\")];)++i;return e+=i||\\\"\\\",t[e]=!0,n=\\\"@@\\\"+e,l(p,n,a.gs(null,function(t){r||(r=!0,l(this,n,a(t)),r=!1)})),n}}();o=function(t){if(this instanceof o)throw new TypeError(\\\"Symbol is not a constructor\\\");return i(t)},e.exports=i=function t(e){var n;if(this instanceof t)throw new TypeError(\\\"Symbol is not a constructor\\\");return u?r(e):(n=f(o.prototype),e=void 0===e?\\\"\\\":String(e),c(n,{__description__:a(\\\"\\\",e),__name__:a(\\\"\\\",y(e))}))},c(i,{for:a(function(t){return h[t]?h[t]:h[t]=i(String(t))}),keyFor:a(function(t){var e;s(t);for(e in h)if(h[e]===t)return e}),hasInstance:a(\\\"\\\",r&&r.hasInstance||i(\\\"hasInstance\\\")),isConcatSpreadable:a(\\\"\\\",r&&r.isConcatSpreadable||i(\\\"isConcatSpreadable\\\")),iterator:a(\\\"\\\",r&&r.iterator||i(\\\"iterator\\\")),match:a(\\\"\\\",r&&r.match||i(\\\"match\\\")),replace:a(\\\"\\\",r&&r.replace||i(\\\"replace\\\")),search:a(\\\"\\\",r&&r.search||i(\\\"search\\\")),species:a(\\\"\\\",r&&r.species||i(\\\"species\\\")),split:a(\\\"\\\",r&&r.split||i(\\\"split\\\")),toPrimitive:a(\\\"\\\",r&&r.toPrimitive||i(\\\"toPrimitive\\\")),toStringTag:a(\\\"\\\",r&&r.toStringTag||i(\\\"toStringTag\\\")),unscopables:a(\\\"\\\",r&&r.unscopables||i(\\\"unscopables\\\"))}),c(o.prototype,{constructor:a(i),toString:a(\\\"\\\",function(){return this.__name__})}),c(i.prototype,{toString:a(function(){return\\\"Symbol (\\\"+s(this).__description__+\\\")\\\"}),valueOf:a(function(){return s(this)})}),l(i.prototype,i.toPrimitive,a(\\\"\\\",function(){var t=s(this);return\\\"symbol\\\"==typeof t?t:t.toString()})),l(i.prototype,i.toStringTag,a(\\\"c\\\",\\\"Symbol\\\")),l(o.prototype,i.toStringTag,a(\\\"c\\\",i.prototype[i.toStringTag])),l(o.prototype,i.toPrimitive,a(\\\"c\\\",i.prototype[i.toPrimitive]))},{\\\"./validate-symbol\\\":69,d:25}],69:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"./is-symbol\\\");e.exports=function(t){if(!r(t))throw new TypeError(t+\\\" is not a symbol\\\");return t}},{\\\"./is-symbol\\\":67}],70:[function(t,e,n){\\\"use strict\\\";var r,i,o,u,a,s,f,c=t(\\\"d\\\"),l=t(\\\"es5-ext/object/valid-callable\\\"),p=Function.prototype.apply,h=Function.prototype.call,y=Object.create,d=Object.defineProperty,v=Object.defineProperties,g=Object.prototype.hasOwnProperty,b={configurable:!0,enumerable:!1,writable:!0};a={on:r=function(t,e){var n;return l(e),g.call(this,\\\"__ee__\\\")?n=this.__ee__:(n=b.value=y(null),d(this,\\\"__ee__\\\",b),b.value=null),n[t]?\\\"object\\\"==typeof n[t]?n[t].push(e):n[t]=[n[t],e]:n[t]=e,this},once:i=function(t,e){var n,i;return l(e),i=this,r.call(this,t,n=function(){o.call(i,t,n),p.call(e,this,arguments)}),n.__eeOnceListener__=e,this},off:o=function(t,e){var n,r,i,o;if(l(e),!g.call(this,\\\"__ee__\\\"))return this;if(!(n=this.__ee__)[t])return this;if(\\\"object\\\"==typeof(r=n[t]))for(o=0;i=r[o];++o)i!==e&&i.__eeOnceListener__!==e||(2===r.length?n[t]=r[o?0:1]:r.splice(o,1));else r!==e&&r.__eeOnceListener__!==e||delete n[t];return this},emit:u=function(t){var e,n,r,i,o;if(g.call(this,\\\"__ee__\\\")&&(i=this.__ee__[t]))if(\\\"object\\\"==typeof i){for(n=arguments.length,o=new Array(n-1),e=1;e<n;++e)o[e-1]=arguments[e];for(i=i.slice(),e=0;r=i[e];++e)p.call(r,this,o)}else switch(arguments.length){case 1:h.call(i,this);break;case 2:h.call(i,this,arguments[1]);break;case 3:h.call(i,this,arguments[1],arguments[2]);break;default:for(n=arguments.length,o=new Array(n-1),e=1;e<n;++e)o[e-1]=arguments[e];p.call(i,this,o)}}},s={on:c(r),once:c(i),off:c(o),emit:c(u)},f=v({},s),e.exports=n=function(t){return null==t?y(f):v(Object(t),s)},n.methods=a},{d:25,\\\"es5-ext/object/valid-callable\\\":59}],71:[function(t,e,n){function r(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function i(t){return\\\"function\\\"==typeof t}function o(t){return\\\"number\\\"==typeof t}function u(t){return\\\"object\\\"==typeof t&&null!==t}function a(t){return void 0===t}e.exports=r,r.EventEmitter=r,r.prototype._events=void 0,r.prototype._maxListeners=void 0,r.defaultMaxListeners=10,r.prototype.setMaxListeners=function(t){if(!o(t)||t<0||isNaN(t))throw TypeError(\\\"n must be a positive number\\\");return this._maxListeners=t,this},r.prototype.emit=function(t){var e,n,r,o,s,f;if(this._events||(this._events={}),\\\"error\\\"===t&&(!this._events.error||u(this._events.error)&&!this._events.error.length)){if((e=arguments[1])instanceof Error)throw e;var c=new Error('Uncaught, unspecified \\\"error\\\" event. ('+e+\\\")\\\");throw c.context=e,c}if(n=this._events[t],a(n))return!1;if(i(n))switch(arguments.length){case 1:n.call(this);break;case 2:n.call(this,arguments[1]);break;case 3:n.call(this,arguments[1],arguments[2]);break;default:o=Array.prototype.slice.call(arguments,1),n.apply(this,o)}else if(u(n))for(o=Array.prototype.slice.call(arguments,1),r=(f=n.slice()).length,s=0;s<r;s++)f[s].apply(this,o);return!0},r.prototype.addListener=function(t,e){var n;if(!i(e))throw TypeError(\\\"listener must be a function\\\");return this._events||(this._events={}),this._events.newListener&&this.emit(\\\"newListener\\\",t,i(e.listener)?e.listener:e),this._events[t]?u(this._events[t])?this._events[t].push(e):this._events[t]=[this._events[t],e]:this._events[t]=e,u(this._events[t])&&!this._events[t].warned&&(n=a(this._maxListeners)?r.defaultMaxListeners:this._maxListeners)&&n>0&&this._events[t].length>n&&(this._events[t].warned=!0,console.error(\\\"(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.\\\",this._events[t].length),\\\"function\\\"==typeof console.trace&&console.trace()),this},r.prototype.on=r.prototype.addListener,r.prototype.once=function(t,e){function n(){this.removeListener(t,n),r||(r=!0,e.apply(this,arguments))}if(!i(e))throw TypeError(\\\"listener must be a function\\\");var r=!1;return n.listener=e,this.on(t,n),this},r.prototype.removeListener=function(t,e){var n,r,o,a;if(!i(e))throw TypeError(\\\"listener must be a function\\\");if(!this._events||!this._events[t])return this;if(n=this._events[t],o=n.length,r=-1,n===e||i(n.listener)&&n.listener===e)delete this._events[t],this._events.removeListener&&this.emit(\\\"removeListener\\\",t,e);else if(u(n)){for(a=o;a-- >0;)if(n[a]===e||n[a].listener&&n[a].listener===e){r=a;break}if(r<0)return this;1===n.length?(n.length=0,delete this._events[t]):n.splice(r,1),this._events.removeListener&&this.emit(\\\"removeListener\\\",t,e)}return this},r.prototype.removeAllListeners=function(t){var e,n;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[t]&&delete this._events[t],this;if(0===arguments.length){for(e in this._events)\\\"removeListener\\\"!==e&&this.removeAllListeners(e);return this.removeAllListeners(\\\"removeListener\\\"),this._events={},this}if(n=this._events[t],i(n))this.removeListener(t,n);else if(n)for(;n.length;)this.removeListener(t,n[n.length-1]);return delete this._events[t],this},r.prototype.listeners=function(t){return this._events&&this._events[t]?i(this._events[t])?[this._events[t]]:this._events[t].slice():[]},r.prototype.listenerCount=function(t){if(this._events){var e=this._events[t];if(i(e))return 1;if(e)return e.length}return 0},r.listenerCount=function(t,e){return t.listenerCount(e)}},{}],72:[function(t,e,n){n.read=function(t,e,n,r,i){var o,u,a=8*i-r-1,s=(1<<a)-1,f=s>>1,c=-7,l=n?i-1:0,p=n?-1:1,h=t[e+l];for(l+=p,o=h&(1<<-c)-1,h>>=-c,c+=a;c>0;o=256*o+t[e+l],l+=p,c-=8);for(u=o&(1<<-c)-1,o>>=-c,c+=r;c>0;u=256*u+t[e+l],l+=p,c-=8);if(0===o)o=1-f;else{if(o===s)return u?NaN:1/0*(h?-1:1);u+=Math.pow(2,r),o-=f}return(h?-1:1)*u*Math.pow(2,o-r)},n.write=function(t,e,n,r,i,o){var u,a,s,f=8*o-i-1,c=(1<<f)-1,l=c>>1,p=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,h=r?0:o-1,y=r?1:-1,d=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,u=c):(u=Math.floor(Math.log(e)/Math.LN2),e*(s=Math.pow(2,-u))<1&&(u--,s*=2),(e+=u+l>=1?p/s:p*Math.pow(2,1-l))*s>=2&&(u++,s/=2),u+l>=c?(a=0,u=c):u+l>=1?(a=(e*s-1)*Math.pow(2,i),u+=l):(a=e*Math.pow(2,l-1)*Math.pow(2,i),u=0));i>=8;t[n+h]=255&a,h+=y,a/=256,i-=8);for(u=u<<i|a,f+=i;f>0;t[n+h]=255&u,h+=y,u/=256,f-=8);t[n+h-y]|=128*d}},{}],73:[function(t,e,n){e.exports=function(t){return!!t&&(\\\"object\\\"==typeof t||\\\"function\\\"==typeof t)&&\\\"function\\\"==typeof t.then}},{}],74:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"es5-ext/number/to-pos-integer\\\"),i=Object.create,o=Object.prototype.hasOwnProperty;e.exports=function(t){var e,n=0,u=1,a=i(null),s=i(null),f=0;return t=r(t),{hit:function(r){var i=s[r],c=++f;if(a[c]=r,s[r]=c,!i){if(++n<=t)return;return r=a[u],e(r),r}if(delete a[i],u===i)for(;!o.call(a,++u);)continue},delete:e=function(t){var e=s[t];if(e&&(delete a[e],delete s[t],--n,u===e)){if(!n)return f=0,void(u=1);for(;!o.call(a,++u);)continue}},clear:function(){n=0,u=1,a=i(null),s=i(null),f=0}}}},{\\\"es5-ext/number/to-pos-integer\\\":44}],75:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"es5-ext/array/from\\\"),i=t(\\\"es5-ext/object/map\\\"),o=t(\\\"es5-ext/object/mixin\\\"),u=t(\\\"es5-ext/function/_define-length\\\"),a=t(\\\"next-tick\\\"),s=Array.prototype.slice,f=Function.prototype.apply,c=Object.create,l=Object.prototype.hasOwnProperty;t(\\\"../lib/registered-extensions\\\").async=function(t,e){var n,p,h,y=c(null),d=c(null),v=e.memoized,g=e.original;e.memoized=u(function(t){var e=arguments,r=e[e.length-1];return\\\"function\\\"==typeof r&&(n=r,e=s.call(e,0,-1)),v.apply(p=this,h=e)},v);try{o(e.memoized,v)}catch(t){}e.on(\\\"get\\\",function(t){var r,i,o;if(n){if(y[t])return\\\"function\\\"==typeof y[t]?y[t]=[y[t],n]:y[t].push(n),void(n=null);r=n,i=p,o=h,n=p=h=null,a(function(){var u;l.call(d,t)?(u=d[t],e.emit(\\\"getasync\\\",t,o,i),f.call(r,u.context,u.args)):(n=r,p=i,h=o,v.apply(i,o))})}}),e.original=function(){var t,i,o,u;return n?(t=r(arguments),i=function t(n){var i,o,s=t.id;if(null!=s){if(delete t.id,i=y[s],delete y[s],i)return o=r(arguments),e.has(s)&&(n?e.delete(s):(d[s]={context:this,args:o},e.emit(\\\"setasync\\\",s,\\\"function\\\"==typeof i?1:i.length))),\\\"function\\\"==typeof i?u=f.call(i,this,o):i.forEach(function(t){u=f.call(t,this,o)},this),u}else a(f.bind(t,this,arguments))},o=n,n=p=h=null,t.push(i),u=f.call(g,this,t),i.cb=o,n=i,u):f.call(g,this,arguments)},e.on(\\\"set\\\",function(t){n?(y[t]?\\\"function\\\"==typeof y[t]?y[t]=[y[t],n.cb]:y[t].push(n.cb):y[t]=n.cb,delete n.cb,n.id=t,n=null):e.delete(t)}),e.on(\\\"delete\\\",function(t){var n;l.call(y,t)||d[t]&&(n=d[t],delete d[t],e.emit(\\\"deleteasync\\\",t,s.call(n.args,1)))}),e.on(\\\"clear\\\",function(){var t=d;d=c(null),e.emit(\\\"clearasync\\\",i(t,function(t){return s.call(t.args,1)}))})}},{\\\"../lib/registered-extensions\\\":83,\\\"es5-ext/array/from\\\":28,\\\"es5-ext/function/_define-length\\\":33,\\\"es5-ext/object/map\\\":56,\\\"es5-ext/object/mixin\\\":57,\\\"next-tick\\\":93}],76:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"es5-ext/object/valid-callable\\\"),i=t(\\\"es5-ext/object/for-each\\\"),o=t(\\\"../lib/registered-extensions\\\"),u=Function.prototype.apply;o.dispose=function(t,e,n){var a;if(r(t),n.async&&o.async||n.promise&&o.promise)return e.on(\\\"deleteasync\\\",a=function(e,n){u.call(t,null,n)}),void e.on(\\\"clearasync\\\",function(t){i(t,function(t,e){a(e,t)})});e.on(\\\"delete\\\",a=function(e,n){t(n)}),e.on(\\\"clear\\\",function(t){i(t,function(t,e){a(e,t)})})}},{\\\"../lib/registered-extensions\\\":83,\\\"es5-ext/object/for-each\\\":49,\\\"es5-ext/object/valid-callable\\\":59}],77:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"es5-ext/array/from\\\"),i=t(\\\"es5-ext/object/for-each\\\"),o=t(\\\"next-tick\\\"),u=t(\\\"is-promise\\\"),a=t(\\\"timers-ext/valid-timeout\\\"),s=t(\\\"../lib/registered-extensions\\\"),f=Function.prototype,c=Math.max,l=Math.min,p=Object.create;s.maxAge=function(t,e,n){var h,y,d,v;(t=a(t))&&(h=p(null),y=n.async&&s.async||n.promise&&s.promise?\\\"async\\\":\\\"\\\",e.on(\\\"set\\\"+y,function(n){h[n]=setTimeout(function(){e.delete(n)},t),v&&(v[n]&&\\\"nextTick\\\"!==v[n]&&clearTimeout(v[n]),v[n]=setTimeout(function(){delete v[n]},d))}),e.on(\\\"delete\\\"+y,function(t){clearTimeout(h[t]),delete h[t],v&&(\\\"nextTick\\\"!==v[t]&&clearTimeout(v[t]),delete v[t])}),n.preFetch&&(d=!0===n.preFetch||isNaN(n.preFetch)?.333:c(l(Number(n.preFetch),1),0))&&(v={},d=(1-d)*t,e.on(\\\"get\\\"+y,function(t,i,a){v[t]||(v[t]=\\\"nextTick\\\",o(function(){var o;\\\"nextTick\\\"===v[t]&&(delete v[t],e.delete(t),n.async&&(i=r(i)).push(f),o=e.memoized.apply(a,i),n.promise&&u(o)&&(\\\"function\\\"==typeof o.done?o.done(f,f):o.then(f,f)))}))})),e.on(\\\"clear\\\"+y,function(){i(h,function(t){clearTimeout(t)}),h={},v&&(i(v,function(t){\\\"nextTick\\\"!==t&&clearTimeout(t)}),v={})}))}},{\\\"../lib/registered-extensions\\\":83,\\\"es5-ext/array/from\\\":28,\\\"es5-ext/object/for-each\\\":49,\\\"is-promise\\\":73,\\\"next-tick\\\":93,\\\"timers-ext/valid-timeout\\\":98}],78:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"es5-ext/number/to-pos-integer\\\"),i=t(\\\"lru-queue\\\"),o=t(\\\"../lib/registered-extensions\\\");o.max=function(t,e,n){var u,a,s;(t=r(t))&&(a=i(t),u=n.async&&o.async||n.promise&&o.promise?\\\"async\\\":\\\"\\\",e.on(\\\"set\\\"+u,s=function(t){void 0!==(t=a.hit(t))&&e.delete(t)}),e.on(\\\"get\\\"+u,s),e.on(\\\"delete\\\"+u,a.delete),e.on(\\\"clear\\\"+u,a.clear))}},{\\\"../lib/registered-extensions\\\":83,\\\"es5-ext/number/to-pos-integer\\\":44,\\\"lru-queue\\\":74}],79:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"es5-ext/object/map\\\"),i=t(\\\"is-promise\\\"),o=t(\\\"next-tick\\\"),u=Object.create,a=Object.prototype.hasOwnProperty;t(\\\"../lib/registered-extensions\\\").promise=function(t,e){var n=u(null),s=u(null),f=u(null);e.on(\\\"set\\\",function(r,u,a){var c=!1;if(!i(a))return s[r]=a,void e.emit(\\\"setasync\\\",r,1);n[r]=1,f[r]=a;var l=function(t){var i=n[r];if(c)throw new Error(\\\"Memoizee error: Promise resolved with both failure and success, this can be result of unordered done & finally resolution.\\\\nInstead of `promise: true` consider configuring memoization via `promise: 'then'` or `promise: 'done'\\\");i&&(delete n[r],s[r]=t,e.emit(\\\"setasync\\\",r,i))},p=function(){c=!0,n[r]&&(delete n[r],delete f[r],e.delete(r))};\\\"then\\\"!==t&&\\\"function\\\"==typeof a.done?\\\"done\\\"!==t&&\\\"function\\\"==typeof a.finally?(a.done(l),a.finally(p)):a.done(l,p):a.then(function(t){o(l.bind(this,t))},function(){o(p)})}),e.on(\\\"get\\\",function(t,r,u){var a;if(n[t])++n[t];else{a=f[t];var s=function(){e.emit(\\\"getasync\\\",t,r,u)};i(a)?\\\"function\\\"==typeof a.done?a.done(s):a.then(function(){o(s)}):s()}}),e.on(\\\"delete\\\",function(t){if(delete f[t],n[t])delete n[t];else if(a.call(s,t)){var r=s[t];delete s[t],e.emit(\\\"deleteasync\\\",t,[r])}}),e.on(\\\"clear\\\",function(){var t=s;s=u(null),n=u(null),f=u(null),e.emit(\\\"clearasync\\\",r(t,function(t){return[t]}))})}},{\\\"../lib/registered-extensions\\\":83,\\\"es5-ext/object/map\\\":56,\\\"is-promise\\\":73,\\\"next-tick\\\":93}],80:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"d\\\"),i=t(\\\"../lib/registered-extensions\\\"),o=Object.create,u=Object.defineProperties;i.refCounter=function(t,e,n){var a,s;a=o(null),s=n.async&&i.async||n.promise&&i.promise?\\\"async\\\":\\\"\\\",e.on(\\\"set\\\"+s,function(t,e){a[t]=e||1}),e.on(\\\"get\\\"+s,function(t){++a[t]}),e.on(\\\"delete\\\"+s,function(t){delete a[t]}),e.on(\\\"clear\\\"+s,function(){a={}}),u(e.memoized,{deleteRef:r(function(){var t=e.get(arguments);return null===t?null:a[t]?!--a[t]&&(e.delete(t),!0):null}),getRefCount:r(function(){var t=e.get(arguments);return null===t?0:a[t]?a[t]:0})})}},{\\\"../lib/registered-extensions\\\":83,d:25}],81:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"es5-ext/object/normalize-options\\\"),i=t(\\\"./lib/resolve-length\\\"),o=t(\\\"./plain\\\");e.exports=function(e){var n,u=r(arguments[1]);return u.normalizer||0!==(n=u.length=i(u.length,e.length,u.async))&&(u.primitive?!1===n?u.normalizer=t(\\\"./normalizers/primitive\\\"):n>1&&(u.normalizer=t(\\\"./normalizers/get-primitive-fixed\\\")(n)):u.normalizer=!1===n?t(\\\"./normalizers/get\\\")():1===n?t(\\\"./normalizers/get-1\\\")():t(\\\"./normalizers/get-fixed\\\")(n)),u.async&&t(\\\"./ext/async\\\"),u.promise&&t(\\\"./ext/promise\\\"),u.dispose&&t(\\\"./ext/dispose\\\"),u.maxAge&&t(\\\"./ext/max-age\\\"),u.max&&t(\\\"./ext/max\\\"),u.refCounter&&t(\\\"./ext/ref-counter\\\"),o(e,u)}},{\\\"./ext/async\\\":75,\\\"./ext/dispose\\\":76,\\\"./ext/max\\\":78,\\\"./ext/max-age\\\":77,\\\"./ext/promise\\\":79,\\\"./ext/ref-counter\\\":80,\\\"./lib/resolve-length\\\":84,\\\"./normalizers/get\\\":90,\\\"./normalizers/get-1\\\":87,\\\"./normalizers/get-fixed\\\":88,\\\"./normalizers/get-primitive-fixed\\\":89,\\\"./normalizers/primitive\\\":91,\\\"./plain\\\":92,\\\"es5-ext/object/normalize-options\\\":58}],82:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"es5-ext/error/custom\\\"),i=t(\\\"es5-ext/function/_define-length\\\"),o=t(\\\"d\\\"),u=t(\\\"event-emitter\\\").methods,a=t(\\\"./resolve-resolve\\\"),s=t(\\\"./resolve-normalize\\\"),f=Function.prototype.apply,c=Function.prototype.call,l=Object.create,p=Object.prototype.hasOwnProperty,h=Object.defineProperties,y=u.on,d=u.emit;e.exports=function(t,e,n){var u,v,g,b,m,w,_,j,x,O,k,E,A,S,I,T=l(null);return v=!1!==e?e:isNaN(t.length)?1:t.length,n.normalizer&&(O=s(n.normalizer),g=O.get,b=O.set,m=O.delete,w=O.clear),null!=n.resolvers&&(I=a(n.resolvers)),S=g?i(function(e){var n,i,o=arguments;if(I&&(o=I(o)),null!==(n=g(o))&&p.call(T,n))return k&&u.emit(\\\"get\\\",n,o,this),T[n];if(i=1===o.length?c.call(t,this,o[0]):f.call(t,this,o),null===n){if(null!==(n=g(o)))throw r(\\\"Circular invocation\\\",\\\"CIRCULAR_INVOCATION\\\");n=b(o)}else if(p.call(T,n))throw r(\\\"Circular invocation\\\",\\\"CIRCULAR_INVOCATION\\\");return T[n]=i,E&&u.emit(\\\"set\\\",n,null,i),i},v):0===e?function(){var e;if(p.call(T,\\\"data\\\"))return k&&u.emit(\\\"get\\\",\\\"data\\\",arguments,this),T.data;if(e=arguments.length?f.call(t,this,arguments):c.call(t,this),p.call(T,\\\"data\\\"))throw r(\\\"Circular invocation\\\",\\\"CIRCULAR_INVOCATION\\\");return T.data=e,E&&u.emit(\\\"set\\\",\\\"data\\\",null,e),e}:function(e){var n,i,o=arguments;if(I&&(o=I(arguments)),i=String(o[0]),p.call(T,i))return k&&u.emit(\\\"get\\\",i,o,this),T[i];if(n=1===o.length?c.call(t,this,o[0]):f.call(t,this,o),p.call(T,i))throw r(\\\"Circular invocation\\\",\\\"CIRCULAR_INVOCATION\\\");return T[i]=n,E&&u.emit(\\\"set\\\",i,null,n),n},u={original:t,memoized:S,get:function(t){return I&&(t=I(t)),g?g(t):String(t[0])},has:function(t){return p.call(T,t)},delete:function(t){var e;p.call(T,t)&&(m&&m(t),e=T[t],delete T[t],A&&u.emit(\\\"delete\\\",t,e))},clear:function(){var t=T;w&&w(),T=l(null),u.emit(\\\"clear\\\",t)},on:function(t,e){return\\\"get\\\"===t?k=!0:\\\"set\\\"===t?E=!0:\\\"delete\\\"===t&&(A=!0),y.call(this,t,e)},emit:d,updateEnv:function(){t=u.original}},_=g?i(function(t){var e,n=arguments;I&&(n=I(n)),null!==(e=g(n))&&u.delete(e)},v):0===e?function(){return u.delete(\\\"data\\\")}:function(t){return I&&(t=I(arguments)[0]),u.delete(t)},j=i(function(){var t,e=arguments;return I&&(e=I(e)),t=g(e),T[t]}),x=i(function(){var t,e=arguments;return I&&(e=I(e)),null!==(t=g(e))&&u.has(t)}),h(S,{__memoized__:o(!0),delete:o(_),clear:o(u.clear),_get:o(j),_has:o(x)}),u}},{\\\"./resolve-normalize\\\":85,\\\"./resolve-resolve\\\":86,d:25,\\\"es5-ext/error/custom\\\":32,\\\"es5-ext/function/_define-length\\\":33,\\\"event-emitter\\\":70}],83:[function(t,e,n){\\\"use strict\\\"},{}],84:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"es5-ext/number/to-pos-integer\\\");e.exports=function(t,e,n){var i;return isNaN(t)?(i=e)>=0?n&&i?i-1:i:1:!1!==t&&r(t)}},{\\\"es5-ext/number/to-pos-integer\\\":44}],85:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"es5-ext/object/valid-callable\\\");e.exports=function(t){var e;return\\\"function\\\"==typeof t?{set:t,get:t}:(e={get:r(t.get)},void 0!==t.set?(e.set=r(t.set),t.delete&&(e.delete=r(t.delete)),t.clear&&(e.clear=r(t.clear)),e):(e.set=e.get,e))}},{\\\"es5-ext/object/valid-callable\\\":59}],86:[function(t,e,n){\\\"use strict\\\";var r,i=t(\\\"es5-ext/array/to-array\\\"),o=t(\\\"es5-ext/object/valid-callable\\\"),u=Array.prototype.slice;r=function(t){return this.map(function(e,n){return e?e(t[n]):t[n]}).concat(u.call(t,this.length))},e.exports=function(t){return(t=i(t)).forEach(function(t){null!=t&&o(t)}),r.bind(t)}},{\\\"es5-ext/array/to-array\\\":31,\\\"es5-ext/object/valid-callable\\\":59}],87:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"es5-ext/array/#/e-index-of\\\");e.exports=function(){var t=0,e=[],n=[];return{get:function(t){var i=r.call(e,t[0]);return-1===i?null:n[i]},set:function(r){return e.push(r[0]),n.push(++t),t},delete:function(t){var i=r.call(n,t);-1!==i&&(e.splice(i,1),n.splice(i,1))},clear:function(){e=[],n=[]}}}},{\\\"es5-ext/array/#/e-index-of\\\":27}],88:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"es5-ext/array/#/e-index-of\\\"),i=Object.create;e.exports=function(t){var e=0,n=[[],[]],o=i(null);return{get:function(e){for(var i,o=0,u=n;o<t-1;){if(-1===(i=r.call(u[0],e[o])))return null;u=u[1][i],++o}return-1===(i=r.call(u[0],e[o]))?null:u[1][i]||null},set:function(i){for(var u,a=0,s=n;a<t-1;)-1===(u=r.call(s[0],i[a]))&&(u=s[0].push(i[a])-1,s[1].push([[],[]])),s=s[1][u],++a;return-1===(u=r.call(s[0],i[a]))&&(u=s[0].push(i[a])-1),s[1][u]=++e,o[e]=i,e},delete:function(e){for(var i,u=0,a=n,s=[],f=o[e];u<t-1;){if(-1===(i=r.call(a[0],f[u])))return;s.push(a,i),a=a[1][i],++u}if(-1!==(i=r.call(a[0],f[u]))){for(e=a[1][i],a[0].splice(i,1),a[1].splice(i,1);!a[0].length&&s.length;)i=s.pop(),(a=s.pop())[0].splice(i,1),a[1].splice(i,1);delete o[e]}},clear:function(){n=[[],[]],o=i(null)}}}},{\\\"es5-ext/array/#/e-index-of\\\":27}],89:[function(t,e,n){\\\"use strict\\\";e.exports=function(t){return t?function(e){for(var n=String(e[0]),r=0,i=t;--i;)n+=\\\"\\u0001\\\"+e[++r];return n}:function(){return\\\"\\\"}}},{}],90:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"es5-ext/array/#/e-index-of\\\"),i=Object.create;e.exports=function(){var t=0,e=[],n=i(null);return{get:function(t){var n,i=0,o=e,u=t.length;if(0===u)return o[u]||null;if(o=o[u]){for(;i<u-1;){if(-1===(n=r.call(o[0],t[i])))return null;o=o[1][n],++i}return-1===(n=r.call(o[0],t[i]))?null:o[1][n]||null}return null},set:function(i){var o,u=0,a=e,s=i.length;if(0===s)a[s]=++t;else{for(a[s]||(a[s]=[[],[]]),a=a[s];u<s-1;)-1===(o=r.call(a[0],i[u]))&&(o=a[0].push(i[u])-1,a[1].push([[],[]])),a=a[1][o],++u;-1===(o=r.call(a[0],i[u]))&&(o=a[0].push(i[u])-1),a[1][o]=++t}return n[t]=i,t},delete:function(t){var i,o=0,u=e,a=n[t],s=a.length,f=[];if(0===s)delete u[s];else if(u=u[s]){for(;o<s-1;){if(-1===(i=r.call(u[0],a[o])))return;f.push(u,i),u=u[1][i],++o}if(-1===(i=r.call(u[0],a[o])))return;for(t=u[1][i],u[0].splice(i,1),u[1].splice(i,1);!u[0].length&&f.length;)i=f.pop(),(u=f.pop())[0].splice(i,1),u[1].splice(i,1)}delete n[t]},clear:function(){e=[],n=i(null)}}}},{\\\"es5-ext/array/#/e-index-of\\\":27}],91:[function(t,e,n){\\\"use strict\\\";e.exports=function(t){var e,n,r=t.length;if(!r)return\\\"\\u0002\\\";for(e=String(t[n=0]);--r;)e+=\\\"\\u0001\\\"+t[++n];return e}},{}],92:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"es5-ext/object/valid-callable\\\"),i=t(\\\"es5-ext/object/for-each\\\"),o=t(\\\"./lib/registered-extensions\\\"),u=t(\\\"./lib/configure-map\\\"),a=t(\\\"./lib/resolve-length\\\"),s=Object.prototype.hasOwnProperty;e.exports=function t(e){var n,f,c;if(r(e),(n=Object(arguments[1])).async&&n.promise)throw new Error(\\\"Options 'async' and 'promise' cannot be used together\\\");return s.call(e,\\\"__memoized__\\\")&&!n.force?e:(f=a(n.length,e.length,n.async&&o.async),c=u(e,f,n),i(o,function(t,e){n[e]&&t(n[e],c,n)}),t.__profiler__&&t.__profiler__(c),c.updateEnv(),c.memoized)}},{\\\"./lib/configure-map\\\":82,\\\"./lib/registered-extensions\\\":83,\\\"./lib/resolve-length\\\":84,\\\"es5-ext/object/for-each\\\":49,\\\"es5-ext/object/valid-callable\\\":59}],93:[function(t,e,n){(function(t){\\\"use strict\\\";var n,r;n=function(t){if(\\\"function\\\"!=typeof t)throw new TypeError(t+\\\" is not a function\\\");return t},r=function(t){var e,r,i=document.createTextNode(\\\"\\\"),o=0;return new t(function(){var t;if(e)r&&(e=r.concat(e));else{if(!r)return;e=r}if(r=e,e=null,\\\"function\\\"==typeof r)return t=r,r=null,void t();for(i.data=o=++o%2;r;)t=r.shift(),r.length||(r=null),t()}).observe(i,{characterData:!0}),function(t){n(t),e?\\\"function\\\"==typeof e?e=[e,t]:e.push(t):(e=t,i.data=o=++o%2)}},e.exports=function(){if(\\\"object\\\"==typeof t&&t&&\\\"function\\\"==typeof t.nextTick)return t.nextTick;if(\\\"object\\\"==typeof document&&document){if(\\\"function\\\"==typeof MutationObserver)return r(MutationObserver);if(\\\"function\\\"==typeof WebKitMutationObserver)return r(WebKitMutationObserver)}return\\\"function\\\"==typeof setImmediate?function(t){setImmediate(n(t))}:\\\"function\\\"==typeof setTimeout||\\\"object\\\"==typeof setTimeout?function(t){setTimeout(n(t),0)}:null}()}).call(this,t(\\\"_process\\\"))},{_process:95}],94:[function(t,e,n){(function(r){!function(t){if(\\\"object\\\"==typeof n)e.exports=t();else{var i;\\\"undefined\\\"!=typeof window?i=window:void 0!==r?i=r:\\\"undefined\\\"!=typeof self&&(i=self),i.objectHash=t()}}(function(){return function e(n,r,i){function o(a,s){if(!r[a]){if(!n[a]){var f=\\\"function\\\"==typeof t&&t;if(!s&&f)return f(a,!0);if(u)return u(a,!0);throw new Error(\\\"Cannot find module '\\\"+a+\\\"'\\\")}var c=r[a]={exports:{}};n[a][0].call(c.exports,function(t){var e=n[a][1][t];return o(e||t)},c,c.exports,e,n,r,i)}return r[a].exports}for(var u=\\\"function\\\"==typeof t&&t,a=0;a<i.length;a++)o(i[a]);return o}({1:[function(t,e,n){(function(r,i,o,u,a,s,f,c,l){\\\"use strict\\\";function p(t,e){return e=h(t,e),d(t,e)}function h(t,e){if(e=e||{},e.algorithm=e.algorithm||\\\"sha1\\\",e.encoding=e.encoding||\\\"hex\\\",e.excludeValues=!!e.excludeValues,e.algorithm=e.algorithm.toLowerCase(),e.encoding=e.encoding.toLowerCase(),e.ignoreUnknown=!0===e.ignoreUnknown,e.respectType=!1!==e.respectType,e.respectFunctionNames=!1!==e.respectFunctionNames,e.respectFunctionProperties=!1!==e.respectFunctionProperties,e.unorderedArrays=!0===e.unorderedArrays,e.unorderedSets=!1!==e.unorderedSets,e.replacer=e.replacer||void 0,void 0===t)throw new Error(\\\"Object argument required.\\\");for(var n=0;n<m.length;++n)m[n].toLowerCase()===e.algorithm.toLowerCase()&&(e.algorithm=m[n]);if(-1===m.indexOf(e.algorithm))throw new Error('Algorithm \\\"'+e.algorithm+'\\\"  not supported. supported values: '+m.join(\\\", \\\"));if(-1===w.indexOf(e.encoding)&&\\\"passthrough\\\"!==e.algorithm)throw new Error('Encoding \\\"'+e.encoding+'\\\"  not supported. supported values: '+w.join(\\\", \\\"));return e}function y(t){return\\\"function\\\"==typeof t&&null!=/^function\\\\s+\\\\w*\\\\s*\\\\(\\\\s*\\\\)\\\\s*{\\\\s+\\\\[native code\\\\]\\\\s+}$/i.exec(Function.prototype.toString.call(t))}function d(t,e){var n;if(void 0===(n=\\\"passthrough\\\"!==e.algorithm?b.createHash(e.algorithm):new g).write&&(n.write=n.update,n.end=n.update),v(e,n).dispatch(t),n.update||n.end(\\\"\\\"),n.digest)return n.digest(\\\"buffer\\\"===e.encoding?void 0:e.encoding);var r=n.read();return\\\"buffer\\\"===e.encoding?r:r.toString(e.encoding)}function v(t,e,n){n=n||[];var r=function(t){return e.update?e.update(t,\\\"utf8\\\"):e.write(t,\\\"utf8\\\")};return{dispatch:function(e){t.replacer&&(e=t.replacer(e));var n=typeof e;return null===e&&(n=\\\"null\\\"),this[\\\"_\\\"+n](e)},_object:function(e){var i=/\\\\[object (.*)\\\\]/i,u=Object.prototype.toString.call(e),a=i.exec(u);a=(a=a?a[1]:\\\"unknown:[\\\"+u+\\\"]\\\").toLowerCase();var s=null;if((s=n.indexOf(e))>=0)return this.dispatch(\\\"[CIRCULAR:\\\"+s+\\\"]\\\");if(n.push(e),void 0!==o&&o.isBuffer&&o.isBuffer(e))return r(\\\"buffer:\\\"),r(e);if(\\\"object\\\"===a||\\\"function\\\"===a){var f=Object.keys(e).sort();!1===t.respectType||y(e)||f.splice(0,0,\\\"prototype\\\",\\\"__proto__\\\",\\\"constructor\\\"),r(\\\"object:\\\"+f.length+\\\":\\\");var c=this;return f.forEach(function(n){c.dispatch(n),r(\\\":\\\"),t.excludeValues||c.dispatch(e[n]),r(\\\",\\\")})}if(!this[\\\"_\\\"+a]){if(t.ignoreUnknown)return r(\\\"[\\\"+a+\\\"]\\\");throw new Error('Unknown object type \\\"'+a+'\\\"')}this[\\\"_\\\"+a](e)},_array:function(e,i){i=void 0!==i?i:!1!==t.unorderedArrays;var o=this;if(r(\\\"array:\\\"+e.length+\\\":\\\"),!i||e.length<=1)return e.forEach(function(t){return o.dispatch(t)});var u=[],a=e.map(function(e){var r=new g,i=n.slice();return v(t,r,i).dispatch(e),u=u.concat(i.slice(n.length)),r.read().toString()});return n=n.concat(u),a.sort(),this._array(a,!1)},_date:function(t){return r(\\\"date:\\\"+t.toJSON())},_symbol:function(t){return r(\\\"symbol:\\\"+t.toString())},_error:function(t){return r(\\\"error:\\\"+t.toString())},_boolean:function(t){return r(\\\"bool:\\\"+t.toString())},_string:function(t){r(\\\"string:\\\"+t.length+\\\":\\\"),r(t)},_function:function(e){r(\\\"fn:\\\"),y(e)?this.dispatch(\\\"[native]\\\"):this.dispatch(e.toString()),!1!==t.respectFunctionNames&&this.dispatch(\\\"function-name:\\\"+String(e.name)),t.respectFunctionProperties&&this._object(e)},_number:function(t){return r(\\\"number:\\\"+t.toString())},_xml:function(t){return r(\\\"xml:\\\"+t.toString())},_null:function(){return r(\\\"Null\\\")},_undefined:function(){return r(\\\"Undefined\\\")},_regexp:function(t){return r(\\\"regex:\\\"+t.toString())},_uint8array:function(t){return r(\\\"uint8array:\\\"),this.dispatch(Array.prototype.slice.call(t))},_uint8clampedarray:function(t){return r(\\\"uint8clampedarray:\\\"),this.dispatch(Array.prototype.slice.call(t))},_int8array:function(t){return r(\\\"uint8array:\\\"),this.dispatch(Array.prototype.slice.call(t))},_uint16array:function(t){return r(\\\"uint16array:\\\"),this.dispatch(Array.prototype.slice.call(t))},_int16array:function(t){return r(\\\"uint16array:\\\"),this.dispatch(Array.prototype.slice.call(t))},_uint32array:function(t){return r(\\\"uint32array:\\\"),this.dispatch(Array.prototype.slice.call(t))},_int32array:function(t){return r(\\\"uint32array:\\\"),this.dispatch(Array.prototype.slice.call(t))},_float32array:function(t){return r(\\\"float32array:\\\"),this.dispatch(Array.prototype.slice.call(t))},_float64array:function(t){return r(\\\"float64array:\\\"),this.dispatch(Array.prototype.slice.call(t))},_arraybuffer:function(t){return r(\\\"arraybuffer:\\\"),this.dispatch(new Uint8Array(t))},_url:function(t){return r(\\\"url:\\\"+t.toString())},_map:function(e){r(\\\"map:\\\");var n=Array.from(e);return this._array(n,!1!==t.unorderedSets)},_set:function(e){r(\\\"set:\\\");var n=Array.from(e);return this._array(n,!1!==t.unorderedSets)},_blob:function(){if(t.ignoreUnknown)return r(\\\"[blob]\\\");throw Error('Hashing Blob objects is currently not supported\\\\n(see https://github.com/puleos/object-hash/issues/26)\\\\nUse \\\"options.replacer\\\" or \\\"options.ignoreUnknown\\\"\\\\n')},_domwindow:function(){return r(\\\"domwindow\\\")},_process:function(){return r(\\\"process\\\")},_timer:function(){return r(\\\"timer\\\")},_pipe:function(){return r(\\\"pipe\\\")},_tcp:function(){return r(\\\"tcp\\\")},_udp:function(){return r(\\\"udp\\\")},_tty:function(){return r(\\\"tty\\\")},_statwatcher:function(){return r(\\\"statwatcher\\\")},_securecontext:function(){return r(\\\"securecontext\\\")},_connection:function(){return r(\\\"connection\\\")},_zlib:function(){return r(\\\"zlib\\\")},_context:function(){return r(\\\"context\\\")},_nodescript:function(){return r(\\\"nodescript\\\")},_httpparser:function(){return r(\\\"httpparser\\\")},_dataview:function(){return r(\\\"dataview\\\")},_signal:function(){return r(\\\"signal\\\")},_fsevent:function(){return r(\\\"fsevent\\\")},_tlswrap:function(){return r(\\\"tlswrap\\\")}}}function g(){return{buf:\\\"\\\",write:function(t){this.buf+=t},end:function(t){this.buf+=t},read:function(){return this.buf}}}var b=t(\\\"crypto\\\");(n=e.exports=p).sha1=function(t){return p(t)},n.keys=function(t){return p(t,{excludeValues:!0,algorithm:\\\"sha1\\\",encoding:\\\"hex\\\"})},n.MD5=function(t){return p(t,{algorithm:\\\"md5\\\",encoding:\\\"hex\\\"})},n.keysMD5=function(t){return p(t,{algorithm:\\\"md5\\\",encoding:\\\"hex\\\",excludeValues:!0})};var m=b.getHashes?b.getHashes().slice():[\\\"sha1\\\",\\\"md5\\\"];m.push(\\\"passthrough\\\");var w=[\\\"buffer\\\",\\\"hex\\\",\\\"binary\\\",\\\"base64\\\"];n.writeToStream=function(t,e,n){return void 0===n&&(n=e,e={}),e=h(t,e),v(e,n).dispatch(t)}}).call(this,t(\\\"lYpoI2\\\"),\\\"undefined\\\"!=typeof self?self:\\\"undefined\\\"!=typeof window?window:{},t(\\\"buffer\\\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\\\"/fake_8c3adc78.js\\\",\\\"/\\\")},{buffer:3,crypto:5,lYpoI2:10}],2:[function(t,e,n){(function(t,e,r,i,o,u,a,s,f){var c=\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";!function(t){\\\"use strict\\\";function e(t){var e=t.charCodeAt(0);return e===r||e===s?62:e===i||e===f?63:e<o?-1:e<o+10?e-o+26+26:e<a+26?e-a:e<u+26?e-u+26:void 0}var n=\\\"undefined\\\"!=typeof Uint8Array?Uint8Array:Array,r=\\\"+\\\".charCodeAt(0),i=\\\"/\\\".charCodeAt(0),o=\\\"0\\\".charCodeAt(0),u=\\\"a\\\".charCodeAt(0),a=\\\"A\\\".charCodeAt(0),s=\\\"-\\\".charCodeAt(0),f=\\\"_\\\".charCodeAt(0);t.toByteArray=function(t){function r(t){f[l++]=t}var i,o,u,a,s,f;if(t.length%4>0)throw new Error(\\\"Invalid string. Length must be a multiple of 4\\\");var c=t.length;s=\\\"=\\\"===t.charAt(c-2)?2:\\\"=\\\"===t.charAt(c-1)?1:0,f=new n(3*t.length/4-s),u=s>0?t.length-4:t.length;var l=0;for(i=0,o=0;i<u;i+=4,o+=3)a=e(t.charAt(i))<<18|e(t.charAt(i+1))<<12|e(t.charAt(i+2))<<6|e(t.charAt(i+3)),r((16711680&a)>>16),r((65280&a)>>8),r(255&a);return 2===s?(a=e(t.charAt(i))<<2|e(t.charAt(i+1))>>4,r(255&a)):1===s&&(a=e(t.charAt(i))<<10|e(t.charAt(i+1))<<4|e(t.charAt(i+2))>>2,r(a>>8&255),r(255&a)),f},t.fromByteArray=function(t){function e(t){return c.charAt(t)}var n,r,i,o=t.length%3,u=\\\"\\\";for(n=0,i=t.length-o;n<i;n+=3)r=(t[n]<<16)+(t[n+1]<<8)+t[n+2],u+=function(t){return e(t>>18&63)+e(t>>12&63)+e(t>>6&63)+e(63&t)}(r);switch(o){case 1:u+=e((r=t[t.length-1])>>2),u+=e(r<<4&63),u+=\\\"==\\\";break;case 2:u+=e((r=(t[t.length-2]<<8)+t[t.length-1])>>10),u+=e(r>>4&63),u+=e(r<<2&63),u+=\\\"=\\\"}return u}}(void 0===n?this.base64js={}:n)}).call(this,t(\\\"lYpoI2\\\"),\\\"undefined\\\"!=typeof self?self:\\\"undefined\\\"!=typeof window?window:{},t(\\\"buffer\\\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\\\"/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js\\\",\\\"/node_modules/gulp-browserify/node_modules/base64-js/lib\\\")},{buffer:3,lYpoI2:10}],3:[function(t,e,n){(function(e,r,i,o,u,a,s,f,c){function i(t,e,n){if(!(this instanceof i))return new i(t,e,n);var r=typeof t;if(\\\"base64\\\"===e&&\\\"string\\\"===r)for(t=U(t);t.length%4!=0;)t+=\\\"=\\\";var o;if(\\\"number\\\"===r)o=$(t);else if(\\\"string\\\"===r)o=i.byteLength(t,e);else{if(\\\"object\\\"!==r)throw new Error(\\\"First argument needs to be a number, array or string.\\\");o=$(t.length)}var u;i._useTypedArrays?u=i._augment(new Uint8Array(o)):(u=this,u.length=o,u._isBuffer=!0);var a;if(i._useTypedArrays&&\\\"number\\\"==typeof t.byteLength)u._set(t);else if(M(t))for(a=0;a<o;a++)i.isBuffer(t)?u[a]=t.readUInt8(a):u[a]=t[a];else if(\\\"string\\\"===r)u.write(t,0,e);else if(\\\"number\\\"===r&&!i._useTypedArrays&&!n)for(a=0;a<o;a++)u[a]=0;return u}function l(t,e,n,r){n=Number(n)||0;var o=t.length-n;r?(r=Number(r))>o&&(r=o):r=o;var u=e.length;J(u%2==0,\\\"Invalid hex string\\\"),r>u/2&&(r=u/2);for(var a=0;a<r;a++){var s=parseInt(e.substr(2*a,2),16);J(!isNaN(s),\\\"Invalid hex string\\\"),t[n+a]=s}return i._charsWritten=2*a,a}function p(t,e,n,r){return i._charsWritten=V(z(e),t,n,r)}function h(t,e,n,r){return i._charsWritten=V(F(e),t,n,r)}function y(t,e,n,r){return h(t,e,n,r)}function d(t,e,n,r){return i._charsWritten=V(q(e),t,n,r)}function v(t,e,n,r){return i._charsWritten=V(Y(e),t,n,r)}function g(t,e,n){return 0===e&&n===t.length?G.fromByteArray(t):G.fromByteArray(t.slice(e,n))}function b(t,e,n){var r=\\\"\\\",i=\\\"\\\";n=Math.min(t.length,n);for(var o=e;o<n;o++)t[o]<=127?(r+=Q(i)+String.fromCharCode(t[o]),i=\\\"\\\"):i+=\\\"%\\\"+t[o].toString(16);return r+Q(i)}function m(t,e,n){var r=\\\"\\\";n=Math.min(t.length,n);for(var i=e;i<n;i++)r+=String.fromCharCode(t[i]);return r}function w(t,e,n){return m(t,e,n)}function _(t,e,n){var r=t.length;(!e||e<0)&&(e=0),(!n||n<0||n>r)&&(n=r);for(var i=\\\"\\\",o=e;o<n;o++)i+=D(t[o]);return i}function j(t,e,n){for(var r=t.slice(e,n),i=\\\"\\\",o=0;o<r.length;o+=2)i+=String.fromCharCode(r[o]+256*r[o+1]);return i}function x(t,e,n,r){r||(J(\\\"boolean\\\"==typeof n,\\\"missing or invalid endian\\\"),J(void 0!==e&&null!==e,\\\"missing offset\\\"),J(e+1<t.length,\\\"Trying to read beyond buffer length\\\"));var i=t.length;if(!(e>=i)){var o;return n?(o=t[e],e+1<i&&(o|=t[e+1]<<8)):(o=t[e]<<8,e+1<i&&(o|=t[e+1])),o}}function O(t,e,n,r){r||(J(\\\"boolean\\\"==typeof n,\\\"missing or invalid endian\\\"),J(void 0!==e&&null!==e,\\\"missing offset\\\"),J(e+3<t.length,\\\"Trying to read beyond buffer length\\\"));var i=t.length;if(!(e>=i)){var o;return n?(e+2<i&&(o=t[e+2]<<16),e+1<i&&(o|=t[e+1]<<8),o|=t[e],e+3<i&&(o+=t[e+3]<<24>>>0)):(e+1<i&&(o=t[e+1]<<16),e+2<i&&(o|=t[e+2]<<8),e+3<i&&(o|=t[e+3]),o+=t[e]<<24>>>0),o}}function k(t,e,n,r){if(r||(J(\\\"boolean\\\"==typeof n,\\\"missing or invalid endian\\\"),J(void 0!==e&&null!==e,\\\"missing offset\\\"),J(e+1<t.length,\\\"Trying to read beyond buffer length\\\")),!(e>=t.length)){var i=x(t,e,n,!0);return 32768&i?-1*(65535-i+1):i}}function E(t,e,n,r){if(r||(J(\\\"boolean\\\"==typeof n,\\\"missing or invalid endian\\\"),J(void 0!==e&&null!==e,\\\"missing offset\\\"),J(e+3<t.length,\\\"Trying to read beyond buffer length\\\")),!(e>=t.length)){var i=O(t,e,n,!0);return 2147483648&i?-1*(4294967295-i+1):i}}function A(t,e,n,r){return r||(J(\\\"boolean\\\"==typeof n,\\\"missing or invalid endian\\\"),J(e+3<t.length,\\\"Trying to read beyond buffer length\\\")),X.read(t,e,n,23,4)}function S(t,e,n,r){return r||(J(\\\"boolean\\\"==typeof n,\\\"missing or invalid endian\\\"),J(e+7<t.length,\\\"Trying to read beyond buffer length\\\")),X.read(t,e,n,52,8)}function I(t,e,n,r,i){i||(J(void 0!==e&&null!==e,\\\"missing value\\\"),J(\\\"boolean\\\"==typeof r,\\\"missing or invalid endian\\\"),J(void 0!==n&&null!==n,\\\"missing offset\\\"),J(n+1<t.length,\\\"trying to write beyond buffer length\\\"),K(e,65535));var o=t.length;if(!(n>=o))for(var u=0,a=Math.min(o-n,2);u<a;u++)t[n+u]=(e&255<<8*(r?u:1-u))>>>8*(r?u:1-u)}function T(t,e,n,r,i){i||(J(void 0!==e&&null!==e,\\\"missing value\\\"),J(\\\"boolean\\\"==typeof r,\\\"missing or invalid endian\\\"),J(void 0!==n&&null!==n,\\\"missing offset\\\"),J(n+3<t.length,\\\"trying to write beyond buffer length\\\"),K(e,4294967295));var o=t.length;if(!(n>=o))for(var u=0,a=Math.min(o-n,4);u<a;u++)t[n+u]=e>>>8*(r?u:3-u)&255}function P(t,e,n,r,i){i||(J(void 0!==e&&null!==e,\\\"missing value\\\"),J(\\\"boolean\\\"==typeof r,\\\"missing or invalid endian\\\"),J(void 0!==n&&null!==n,\\\"missing offset\\\"),J(n+1<t.length,\\\"Trying to write beyond buffer length\\\"),W(e,32767,-32768)),n>=t.length||(e>=0?I(t,e,n,r,i):I(t,65535+e+1,n,r,i))}function B(t,e,n,r,i){i||(J(void 0!==e&&null!==e,\\\"missing value\\\"),J(\\\"boolean\\\"==typeof r,\\\"missing or invalid endian\\\"),J(void 0!==n&&null!==n,\\\"missing offset\\\"),J(n+3<t.length,\\\"Trying to write beyond buffer length\\\"),W(e,2147483647,-2147483648)),n>=t.length||(e>=0?T(t,e,n,r,i):T(t,4294967295+e+1,n,r,i))}function C(t,e,n,r,i){i||(J(void 0!==e&&null!==e,\\\"missing value\\\"),J(\\\"boolean\\\"==typeof r,\\\"missing or invalid endian\\\"),J(void 0!==n&&null!==n,\\\"missing offset\\\"),J(n+3<t.length,\\\"Trying to write beyond buffer length\\\"),H(e,3.4028234663852886e38,-3.4028234663852886e38)),n>=t.length||X.write(t,e,n,r,23,4)}function L(t,e,n,r,i){i||(J(void 0!==e&&null!==e,\\\"missing value\\\"),J(\\\"boolean\\\"==typeof r,\\\"missing or invalid endian\\\"),J(void 0!==n&&null!==n,\\\"missing offset\\\"),J(n+7<t.length,\\\"Trying to write beyond buffer length\\\"),H(e,1.7976931348623157e308,-1.7976931348623157e308)),n>=t.length||X.write(t,e,n,r,52,8)}function U(t){return t.trim?t.trim():t.replace(/^\\\\s+|\\\\s+$/g,\\\"\\\")}function R(t,e,n){return\\\"number\\\"!=typeof t?n:(t=~~t)>=e?e:t>=0?t:(t+=e)>=0?t:0}function $(t){return(t=~~Math.ceil(+t))<0?0:t}function N(t){return(Array.isArray||function(t){return\\\"[object Array]\\\"===Object.prototype.toString.call(t)})(t)}function M(t){return N(t)||i.isBuffer(t)||t&&\\\"object\\\"==typeof t&&\\\"number\\\"==typeof t.length}function D(t){return t<16?\\\"0\\\"+t.toString(16):t.toString(16)}function z(t){for(var e=[],n=0;n<t.length;n++){var r=t.charCodeAt(n);if(r<=127)e.push(t.charCodeAt(n));else{var i=n;r>=55296&&r<=57343&&n++;for(var o=encodeURIComponent(t.slice(i,n+1)).substr(1).split(\\\"%\\\"),u=0;u<o.length;u++)e.push(parseInt(o[u],16))}}return e}function F(t){for(var e=[],n=0;n<t.length;n++)e.push(255&t.charCodeAt(n));return e}function Y(t){for(var e,n,r,i=[],o=0;o<t.length;o++)e=t.charCodeAt(o),n=e>>8,r=e%256,i.push(r),i.push(n);return i}function q(t){return G.toByteArray(t)}function V(t,e,n,r){for(var i=0;i<r&&!(i+n>=e.length||i>=t.length);i++)e[i+n]=t[i];return i}function Q(t){try{return decodeURIComponent(t)}catch(t){return String.fromCharCode(65533)}}function K(t,e){J(\\\"number\\\"==typeof t,\\\"cannot write a non-number as a number\\\"),J(t>=0,\\\"specified a negative value for writing an unsigned value\\\"),J(t<=e,\\\"value is larger than maximum value for type\\\"),J(Math.floor(t)===t,\\\"value has a fractional component\\\")}function W(t,e,n){J(\\\"number\\\"==typeof t,\\\"cannot write a non-number as a number\\\"),J(t<=e,\\\"value larger than maximum allowed value\\\"),J(t>=n,\\\"value smaller than minimum allowed value\\\"),J(Math.floor(t)===t,\\\"value has a fractional component\\\")}function H(t,e,n){J(\\\"number\\\"==typeof t,\\\"cannot write a non-number as a number\\\"),J(t<=e,\\\"value larger than maximum allowed value\\\"),J(t>=n,\\\"value smaller than minimum allowed value\\\")}function J(t,e){if(!t)throw new Error(e||\\\"Failed assertion\\\")}var G=t(\\\"base64-js\\\"),X=t(\\\"ieee754\\\");n.Buffer=i,n.SlowBuffer=i,n.INSPECT_MAX_BYTES=50,i.poolSize=8192,i._useTypedArrays=function(){try{var t=new ArrayBuffer(0),e=new Uint8Array(t);return e.foo=function(){return 42},42===e.foo()&&\\\"function\\\"==typeof e.subarray}catch(t){return!1}}(),i.isEncoding=function(t){switch(String(t).toLowerCase()){case\\\"hex\\\":case\\\"utf8\\\":case\\\"utf-8\\\":case\\\"ascii\\\":case\\\"binary\\\":case\\\"base64\\\":case\\\"raw\\\":case\\\"ucs2\\\":case\\\"ucs-2\\\":case\\\"utf16le\\\":case\\\"utf-16le\\\":return!0;default:return!1}},i.isBuffer=function(t){return!(null===t||void 0===t||!t._isBuffer)},i.byteLength=function(t,e){var n;switch(t+=\\\"\\\",e||\\\"utf8\\\"){case\\\"hex\\\":n=t.length/2;break;case\\\"utf8\\\":case\\\"utf-8\\\":n=z(t).length;break;case\\\"ascii\\\":case\\\"binary\\\":case\\\"raw\\\":n=t.length;break;case\\\"base64\\\":n=q(t).length;break;case\\\"ucs2\\\":case\\\"ucs-2\\\":case\\\"utf16le\\\":case\\\"utf-16le\\\":n=2*t.length;break;default:throw new Error(\\\"Unknown encoding\\\")}return n},i.concat=function(t,e){if(J(N(t),\\\"Usage: Buffer.concat(list, [totalLength])\\\\nlist should be an Array.\\\"),0===t.length)return new i(0);if(1===t.length)return t[0];var n;if(\\\"number\\\"!=typeof e)for(e=0,n=0;n<t.length;n++)e+=t[n].length;var r=new i(e),o=0;for(n=0;n<t.length;n++){var u=t[n];u.copy(r,o),o+=u.length}return r},i.prototype.write=function(t,e,n,r){if(isFinite(e))isFinite(n)||(r=n,n=void 0);else{var i=r;r=e,e=n,n=i}e=Number(e)||0;var o=this.length-e;n?(n=Number(n))>o&&(n=o):n=o;var u;switch(r=String(r||\\\"utf8\\\").toLowerCase()){case\\\"hex\\\":u=l(this,t,e,n);break;case\\\"utf8\\\":case\\\"utf-8\\\":u=p(this,t,e,n);break;case\\\"ascii\\\":u=h(this,t,e,n);break;case\\\"binary\\\":u=y(this,t,e,n);break;case\\\"base64\\\":u=d(this,t,e,n);break;case\\\"ucs2\\\":case\\\"ucs-2\\\":case\\\"utf16le\\\":case\\\"utf-16le\\\":u=v(this,t,e,n);break;default:throw new Error(\\\"Unknown encoding\\\")}return u},i.prototype.toString=function(t,e,n){var r=this;if(t=String(t||\\\"utf8\\\").toLowerCase(),e=Number(e)||0,(n=void 0!==n?Number(n):n=r.length)===e)return\\\"\\\";var i;switch(t){case\\\"hex\\\":i=_(r,e,n);break;case\\\"utf8\\\":case\\\"utf-8\\\":i=b(r,e,n);break;case\\\"ascii\\\":i=m(r,e,n);break;case\\\"binary\\\":i=w(r,e,n);break;case\\\"base64\\\":i=g(r,e,n);break;case\\\"ucs2\\\":case\\\"ucs-2\\\":case\\\"utf16le\\\":case\\\"utf-16le\\\":i=j(r,e,n);break;default:throw new Error(\\\"Unknown encoding\\\")}return i},i.prototype.toJSON=function(){return{type:\\\"Buffer\\\",data:Array.prototype.slice.call(this._arr||this,0)}},i.prototype.copy=function(t,e,n,r){var o=this;if(n||(n=0),r||0===r||(r=this.length),e||(e=0),r!==n&&0!==t.length&&0!==o.length){J(r>=n,\\\"sourceEnd < sourceStart\\\"),J(e>=0&&e<t.length,\\\"targetStart out of bounds\\\"),J(n>=0&&n<o.length,\\\"sourceStart out of bounds\\\"),J(r>=0&&r<=o.length,\\\"sourceEnd out of bounds\\\"),r>this.length&&(r=this.length),t.length-e<r-n&&(r=t.length-e+n);var u=r-n;if(u<100||!i._useTypedArrays)for(var a=0;a<u;a++)t[a+e]=this[a+n];else t._set(this.subarray(n,n+u),e)}},i.prototype.slice=function(t,e){var n=this.length;if(t=R(t,n,0),e=R(e,n,n),i._useTypedArrays)return i._augment(this.subarray(t,e));for(var r=e-t,o=new i(r,void 0,!0),u=0;u<r;u++)o[u]=this[u+t];return o},i.prototype.get=function(t){return console.log(\\\".get() is deprecated. Access using array indexes instead.\\\"),this.readUInt8(t)},i.prototype.set=function(t,e){return console.log(\\\".set() is deprecated. Access using array indexes instead.\\\"),this.writeUInt8(t,e)},i.prototype.readUInt8=function(t,e){if(e||(J(void 0!==t&&null!==t,\\\"missing offset\\\"),J(t<this.length,\\\"Trying to read beyond buffer length\\\")),!(t>=this.length))return this[t]},i.prototype.readUInt16LE=function(t,e){return x(this,t,!0,e)},i.prototype.readUInt16BE=function(t,e){return x(this,t,!1,e)},i.prototype.readUInt32LE=function(t,e){return O(this,t,!0,e)},i.prototype.readUInt32BE=function(t,e){return O(this,t,!1,e)},i.prototype.readInt8=function(t,e){if(e||(J(void 0!==t&&null!==t,\\\"missing offset\\\"),J(t<this.length,\\\"Trying to read beyond buffer length\\\")),!(t>=this.length))return 128&this[t]?-1*(255-this[t]+1):this[t]},i.prototype.readInt16LE=function(t,e){return k(this,t,!0,e)},i.prototype.readInt16BE=function(t,e){return k(this,t,!1,e)},i.prototype.readInt32LE=function(t,e){return E(this,t,!0,e)},i.prototype.readInt32BE=function(t,e){return E(this,t,!1,e)},i.prototype.readFloatLE=function(t,e){return A(this,t,!0,e)},i.prototype.readFloatBE=function(t,e){return A(this,t,!1,e)},i.prototype.readDoubleLE=function(t,e){return S(this,t,!0,e)},i.prototype.readDoubleBE=function(t,e){return S(this,t,!1,e)},i.prototype.writeUInt8=function(t,e,n){n||(J(void 0!==t&&null!==t,\\\"missing value\\\"),J(void 0!==e&&null!==e,\\\"missing offset\\\"),J(e<this.length,\\\"trying to write beyond buffer length\\\"),K(t,255)),e>=this.length||(this[e]=t)},i.prototype.writeUInt16LE=function(t,e,n){I(this,t,e,!0,n)},i.prototype.writeUInt16BE=function(t,e,n){I(this,t,e,!1,n)},i.prototype.writeUInt32LE=function(t,e,n){T(this,t,e,!0,n)},i.prototype.writeUInt32BE=function(t,e,n){T(this,t,e,!1,n)},i.prototype.writeInt8=function(t,e,n){n||(J(void 0!==t&&null!==t,\\\"missing value\\\"),J(void 0!==e&&null!==e,\\\"missing offset\\\"),J(e<this.length,\\\"Trying to write beyond buffer length\\\"),W(t,127,-128)),e>=this.length||(t>=0?this.writeUInt8(t,e,n):this.writeUInt8(255+t+1,e,n))},i.prototype.writeInt16LE=function(t,e,n){P(this,t,e,!0,n)},i.prototype.writeInt16BE=function(t,e,n){P(this,t,e,!1,n)},i.prototype.writeInt32LE=function(t,e,n){B(this,t,e,!0,n)},i.prototype.writeInt32BE=function(t,e,n){B(this,t,e,!1,n)},i.prototype.writeFloatLE=function(t,e,n){C(this,t,e,!0,n)},i.prototype.writeFloatBE=function(t,e,n){C(this,t,e,!1,n)},i.prototype.writeDoubleLE=function(t,e,n){L(this,t,e,!0,n)},i.prototype.writeDoubleBE=function(t,e,n){L(this,t,e,!1,n)},i.prototype.fill=function(t,e,n){if(t||(t=0),e||(e=0),n||(n=this.length),\\\"string\\\"==typeof t&&(t=t.charCodeAt(0)),J(\\\"number\\\"==typeof t&&!isNaN(t),\\\"value is not a number\\\"),J(n>=e,\\\"end < start\\\"),n!==e&&0!==this.length){J(e>=0&&e<this.length,\\\"start out of bounds\\\"),J(n>=0&&n<=this.length,\\\"end out of bounds\\\");for(var r=e;r<n;r++)this[r]=t}},i.prototype.inspect=function(){for(var t=[],e=this.length,r=0;r<e;r++)if(t[r]=D(this[r]),r===n.INSPECT_MAX_BYTES){t[r+1]=\\\"...\\\";break}return\\\"<Buffer \\\"+t.join(\\\" \\\")+\\\">\\\"},i.prototype.toArrayBuffer=function(){if(\\\"undefined\\\"!=typeof Uint8Array){if(i._useTypedArrays)return new i(this).buffer;for(var t=new Uint8Array(this.length),e=0,n=t.length;e<n;e+=1)t[e]=this[e];return t.buffer}throw new Error(\\\"Buffer.toArrayBuffer not supported in this browser\\\")};var Z=i.prototype;i._augment=function(t){return t._isBuffer=!0,t._get=t.get,t._set=t.set,t.get=Z.get,t.set=Z.set,t.write=Z.write,t.toString=Z.toString,t.toLocaleString=Z.toString,t.toJSON=Z.toJSON,t.copy=Z.copy,t.slice=Z.slice,t.readUInt8=Z.readUInt8,t.readUInt16LE=Z.readUInt16LE,t.readUInt16BE=Z.readUInt16BE,t.readUInt32LE=Z.readUInt32LE,t.readUInt32BE=Z.readUInt32BE,t.readInt8=Z.readInt8,t.readInt16LE=Z.readInt16LE,t.readInt16BE=Z.readInt16BE,t.readInt32LE=Z.readInt32LE,t.readInt32BE=Z.readInt32BE,t.readFloatLE=Z.readFloatLE,t.readFloatBE=Z.readFloatBE,t.readDoubleLE=Z.readDoubleLE,t.readDoubleBE=Z.readDoubleBE,t.writeUInt8=Z.writeUInt8,t.writeUInt16LE=Z.writeUInt16LE,t.writeUInt16BE=Z.writeUInt16BE,t.writeUInt32LE=Z.writeUInt32LE,t.writeUInt32BE=Z.writeUInt32BE,t.writeInt8=Z.writeInt8,t.writeInt16LE=Z.writeInt16LE,t.writeInt16BE=Z.writeInt16BE,t.writeInt32LE=Z.writeInt32LE,t.writeInt32BE=Z.writeInt32BE,t.writeFloatLE=Z.writeFloatLE,t.writeFloatBE=Z.writeFloatBE,t.writeDoubleLE=Z.writeDoubleLE,t.writeDoubleBE=Z.writeDoubleBE,t.fill=Z.fill,t.inspect=Z.inspect,t.toArrayBuffer=Z.toArrayBuffer,t}}).call(this,t(\\\"lYpoI2\\\"),\\\"undefined\\\"!=typeof self?self:\\\"undefined\\\"!=typeof window?window:{},t(\\\"buffer\\\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\\\"/node_modules/gulp-browserify/node_modules/buffer/index.js\\\",\\\"/node_modules/gulp-browserify/node_modules/buffer\\\")},{\\\"base64-js\\\":2,buffer:3,ieee754:11,lYpoI2:10}],4:[function(t,e,n){(function(n,r,i,o,u,a,s,f,c){function l(t,e){if(t.length%h!=0){var n=t.length+(h-t.length%h);t=i.concat([t,y],n)}for(var r=[],o=e?t.readInt32BE:t.readInt32LE,u=0;u<t.length;u+=h)r.push(o.call(t,u));return r}function p(t,e,n){for(var r=new i(e),o=n?r.writeInt32BE:r.writeInt32LE,u=0;u<t.length;u++)o.call(r,t[u],4*u,!0);return r}var h=4,y=new(i=t(\\\"buffer\\\").Buffer)(h);y.fill(0);var d=8;e.exports={hash:function(t,e,n,r){return i.isBuffer(t)||(t=new i(t)),p(e(l(t,r),t.length*d),n,r)}}}).call(this,t(\\\"lYpoI2\\\"),\\\"undefined\\\"!=typeof self?self:\\\"undefined\\\"!=typeof window?window:{},t(\\\"buffer\\\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\\\"/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js\\\",\\\"/node_modules/gulp-browserify/node_modules/crypto-browserify\\\")},{buffer:3,lYpoI2:10}],5:[function(t,e,n){(function(e,r,i,o,u,a,s,f,c){function l(t,e,n){i.isBuffer(e)||(e=new i(e)),i.isBuffer(n)||(n=new i(n)),e.length>b?e=t(e):e.length<b&&(e=i.concat([e,m],b));for(var r=new i(b),o=new i(b),u=0;u<b;u++)r[u]=54^e[u],o[u]=92^e[u];var a=t(i.concat([r,n]));return t(i.concat([o,a]))}function p(t,e){var n=g[t=t||\\\"sha1\\\"],r=[],o=0;return n||h(\\\"algorithm:\\\",t,\\\"is not yet supported\\\"),{update:function(t){return i.isBuffer(t)||(t=new i(t)),r.push(t),o+=t.length,this},digest:function(t){var o=i.concat(r),u=e?l(n,e,o):n(o);return r=null,t?u.toString(t):u}}}function h(){var t=[].slice.call(arguments).join(\\\" \\\");throw new Error([t,\\\"we accept pull requests\\\",\\\"http://github.com/dominictarr/crypto-browserify\\\"].join(\\\"\\\\n\\\"))}var i=t(\\\"buffer\\\").Buffer,y=t(\\\"./sha\\\"),d=t(\\\"./sha256\\\"),v=t(\\\"./rng\\\"),g={sha1:y,sha256:d,md5:t(\\\"./md5\\\")},b=64,m=new i(b);m.fill(0),n.createHash=function(t){return p(t)},n.createHmac=function(t,e){return p(t,e)},n.randomBytes=function(t,e){if(!e||!e.call)return new i(v(t));try{e.call(this,void 0,new i(v(t)))}catch(t){e(t)}},function(t,e){for(var n in t)e(t[n],n)}([\\\"createCredentials\\\",\\\"createCipher\\\",\\\"createCipheriv\\\",\\\"createDecipher\\\",\\\"createDecipheriv\\\",\\\"createSign\\\",\\\"createVerify\\\",\\\"createDiffieHellman\\\",\\\"pbkdf2\\\"],function(t){n[t]=function(){h(\\\"sorry,\\\",t,\\\"is not implemented yet\\\")}})}).call(this,t(\\\"lYpoI2\\\"),\\\"undefined\\\"!=typeof self?self:\\\"undefined\\\"!=typeof window?window:{},t(\\\"buffer\\\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\\\"/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js\\\",\\\"/node_modules/gulp-browserify/node_modules/crypto-browserify\\\")},{\\\"./md5\\\":6,\\\"./rng\\\":7,\\\"./sha\\\":8,\\\"./sha256\\\":9,buffer:3,lYpoI2:10}],6:[function(t,e,n){(function(n,r,i,o,u,a,s,f,c){function l(t,e){t[e>>5]|=128<<e%32,t[14+(e+64>>>9<<4)]=e;for(var n=1732584193,r=-271733879,i=-1732584194,o=271733878,u=0;u<t.length;u+=16){var a=n,s=r,f=i,c=o;r=v(r=v(r=v(r=v(r=d(r=d(r=d(r=d(r=y(r=y(r=y(r=y(r=h(r=h(r=h(r=h(r,i=h(i,o=h(o,n=h(n,r,i,o,t[u+0],7,-680876936),r,i,t[u+1],12,-389564586),n,r,t[u+2],17,606105819),o,n,t[u+3],22,-1044525330),i=h(i,o=h(o,n=h(n,r,i,o,t[u+4],7,-176418897),r,i,t[u+5],12,1200080426),n,r,t[u+6],17,-1473231341),o,n,t[u+7],22,-45705983),i=h(i,o=h(o,n=h(n,r,i,o,t[u+8],7,1770035416),r,i,t[u+9],12,-1958414417),n,r,t[u+10],17,-42063),o,n,t[u+11],22,-1990404162),i=h(i,o=h(o,n=h(n,r,i,o,t[u+12],7,1804603682),r,i,t[u+13],12,-40341101),n,r,t[u+14],17,-1502002290),o,n,t[u+15],22,1236535329),i=y(i,o=y(o,n=y(n,r,i,o,t[u+1],5,-165796510),r,i,t[u+6],9,-1069501632),n,r,t[u+11],14,643717713),o,n,t[u+0],20,-373897302),i=y(i,o=y(o,n=y(n,r,i,o,t[u+5],5,-701558691),r,i,t[u+10],9,38016083),n,r,t[u+15],14,-660478335),o,n,t[u+4],20,-405537848),i=y(i,o=y(o,n=y(n,r,i,o,t[u+9],5,568446438),r,i,t[u+14],9,-1019803690),n,r,t[u+3],14,-187363961),o,n,t[u+8],20,1163531501),i=y(i,o=y(o,n=y(n,r,i,o,t[u+13],5,-1444681467),r,i,t[u+2],9,-51403784),n,r,t[u+7],14,1735328473),o,n,t[u+12],20,-1926607734),i=d(i,o=d(o,n=d(n,r,i,o,t[u+5],4,-378558),r,i,t[u+8],11,-2022574463),n,r,t[u+11],16,1839030562),o,n,t[u+14],23,-35309556),i=d(i,o=d(o,n=d(n,r,i,o,t[u+1],4,-1530992060),r,i,t[u+4],11,1272893353),n,r,t[u+7],16,-155497632),o,n,t[u+10],23,-1094730640),i=d(i,o=d(o,n=d(n,r,i,o,t[u+13],4,681279174),r,i,t[u+0],11,-358537222),n,r,t[u+3],16,-722521979),o,n,t[u+6],23,76029189),i=d(i,o=d(o,n=d(n,r,i,o,t[u+9],4,-640364487),r,i,t[u+12],11,-421815835),n,r,t[u+15],16,530742520),o,n,t[u+2],23,-995338651),i=v(i,o=v(o,n=v(n,r,i,o,t[u+0],6,-198630844),r,i,t[u+7],10,1126891415),n,r,t[u+14],15,-1416354905),o,n,t[u+5],21,-57434055),i=v(i,o=v(o,n=v(n,r,i,o,t[u+12],6,1700485571),r,i,t[u+3],10,-1894986606),n,r,t[u+10],15,-1051523),o,n,t[u+1],21,-2054922799),i=v(i,o=v(o,n=v(n,r,i,o,t[u+8],6,1873313359),r,i,t[u+15],10,-30611744),n,r,t[u+6],15,-1560198380),o,n,t[u+13],21,1309151649),i=v(i,o=v(o,n=v(n,r,i,o,t[u+4],6,-145523070),r,i,t[u+11],10,-1120210379),n,r,t[u+2],15,718787259),o,n,t[u+9],21,-343485551),n=g(n,a),r=g(r,s),i=g(i,f),o=g(o,c)}return Array(n,r,i,o)}function p(t,e,n,r,i,o){return g(b(g(g(e,t),g(r,o)),i),n)}function h(t,e,n,r,i,o,u){return p(e&n|~e&r,t,e,i,o,u)}function y(t,e,n,r,i,o,u){return p(e&r|n&~r,t,e,i,o,u)}function d(t,e,n,r,i,o,u){return p(e^n^r,t,e,i,o,u)}function v(t,e,n,r,i,o,u){return p(n^(e|~r),t,e,i,o,u)}function g(t,e){var n=(65535&t)+(65535&e);return(t>>16)+(e>>16)+(n>>16)<<16|65535&n}function b(t,e){return t<<e|t>>>32-e}var m=t(\\\"./helpers\\\");e.exports=function(t){return m.hash(t,l,16)}}).call(this,t(\\\"lYpoI2\\\"),\\\"undefined\\\"!=typeof self?self:\\\"undefined\\\"!=typeof window?window:{},t(\\\"buffer\\\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\\\"/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js\\\",\\\"/node_modules/gulp-browserify/node_modules/crypto-browserify\\\")},{\\\"./helpers\\\":4,buffer:3,lYpoI2:10}],7:[function(t,e,n){(function(t,n,r,i,o,u,a,s,f){!function(){var t,n;t=function(t){for(var e,n=new Array(t),r=0;r<t;r++)0==(3&r)&&(e=4294967296*Math.random()),n[r]=e>>>((3&r)<<3)&255;return n},this.crypto&&crypto.getRandomValues&&(n=function(t){var e=new Uint8Array(t);return crypto.getRandomValues(e),e}),e.exports=n||t}()}).call(this,t(\\\"lYpoI2\\\"),\\\"undefined\\\"!=typeof self?self:\\\"undefined\\\"!=typeof window?window:{},t(\\\"buffer\\\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\\\"/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js\\\",\\\"/node_modules/gulp-browserify/node_modules/crypto-browserify\\\")},{buffer:3,lYpoI2:10}],8:[function(t,e,n){(function(n,r,i,o,u,a,s,f,c){function l(t,e){t[e>>5]|=128<<24-e%32,t[15+(e+64>>9<<4)]=e;for(var n=Array(80),r=1732584193,i=-271733879,o=-1732584194,u=271733878,a=-1009589776,s=0;s<t.length;s+=16){for(var f=r,c=i,l=o,v=u,g=a,b=0;b<80;b++){n[b]=b<16?t[s+b]:d(n[b-3]^n[b-8]^n[b-14]^n[b-16],1);var m=y(y(d(r,5),p(b,i,o,u)),y(y(a,n[b]),h(b)));a=u,u=o,o=d(i,30),i=r,r=m}r=y(r,f),i=y(i,c),o=y(o,l),u=y(u,v),a=y(a,g)}return Array(r,i,o,u,a)}function p(t,e,n,r){return t<20?e&n|~e&r:t<40?e^n^r:t<60?e&n|e&r|n&r:e^n^r}function h(t){return t<20?1518500249:t<40?1859775393:t<60?-1894007588:-899497514}function y(t,e){var n=(65535&t)+(65535&e);return(t>>16)+(e>>16)+(n>>16)<<16|65535&n}function d(t,e){return t<<e|t>>>32-e}var v=t(\\\"./helpers\\\");e.exports=function(t){return v.hash(t,l,20,!0)}}).call(this,t(\\\"lYpoI2\\\"),\\\"undefined\\\"!=typeof self?self:\\\"undefined\\\"!=typeof window?window:{},t(\\\"buffer\\\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\\\"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js\\\",\\\"/node_modules/gulp-browserify/node_modules/crypto-browserify\\\")},{\\\"./helpers\\\":4,buffer:3,lYpoI2:10}],9:[function(t,e,n){(function(n,r,i,o,u,a,s,f,c){var l=t(\\\"./helpers\\\"),p=function(t,e){var n=(65535&t)+(65535&e);return(t>>16)+(e>>16)+(n>>16)<<16|65535&n},h=function(t,e){return t>>>e|t<<32-e},y=function(t,e){return t>>>e},d=function(t,e,n){return t&e^~t&n},v=function(t,e,n){return t&e^t&n^e&n},g=function(t){return h(t,2)^h(t,13)^h(t,22)},b=function(t){return h(t,6)^h(t,11)^h(t,25)},m=function(t){return h(t,7)^h(t,18)^y(t,3)},w=function(t){return h(t,17)^h(t,19)^y(t,10)},_=function(t,e){var n,r,i,o,u,a,s,f,c,l,h=new Array(1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298),y=new Array(1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225),_=new Array(64);t[e>>5]|=128<<24-e%32,t[15+(e+64>>9<<4)]=e;for(var j=0;j<t.length;j+=16){n=y[0],r=y[1],i=y[2],o=y[3],u=y[4],a=y[5],s=y[6],f=y[7];for(var x=0;x<64;x++)_[x]=x<16?t[x+j]:p(p(p(w(_[x-2]),_[x-7]),m(_[x-15])),_[x-16]),c=p(p(p(p(f,b(u)),d(u,a,s)),h[x]),_[x]),l=p(g(n),v(n,r,i)),f=s,s=a,a=u,u=p(o,c),o=i,i=r,r=n,n=p(c,l);y[0]=p(n,y[0]),y[1]=p(r,y[1]),y[2]=p(i,y[2]),y[3]=p(o,y[3]),y[4]=p(u,y[4]),y[5]=p(a,y[5]),y[6]=p(s,y[6]),y[7]=p(f,y[7])}return y};e.exports=function(t){return l.hash(t,_,32,!0)}}).call(this,t(\\\"lYpoI2\\\"),\\\"undefined\\\"!=typeof self?self:\\\"undefined\\\"!=typeof window?window:{},t(\\\"buffer\\\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\\\"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js\\\",\\\"/node_modules/gulp-browserify/node_modules/crypto-browserify\\\")},{\\\"./helpers\\\":4,buffer:3,lYpoI2:10}],10:[function(t,e,n){(function(t,n,r,i,o,u,a,s,f){function c(){}(t=e.exports={}).nextTick=function(){var t=\\\"undefined\\\"!=typeof window&&window.setImmediate,e=\\\"undefined\\\"!=typeof window&&window.postMessage&&window.addEventListener;if(t)return function(t){return window.setImmediate(t)};if(e){var n=[];return window.addEventListener(\\\"message\\\",function(t){var e=t.source;(e===window||null===e)&&\\\"process-tick\\\"===t.data&&(t.stopPropagation(),n.length>0)&&n.shift()()},!0),function(t){n.push(t),window.postMessage(\\\"process-tick\\\",\\\"*\\\")}}return function(t){setTimeout(t,0)}}(),t.title=\\\"browser\\\",t.browser=!0,t.env={},t.argv=[],t.on=c,t.addListener=c,t.once=c,t.off=c,t.removeListener=c,t.removeAllListeners=c,t.emit=c,t.binding=function(t){throw new Error(\\\"process.binding is not supported\\\")},t.cwd=function(){return\\\"/\\\"},t.chdir=function(t){throw new Error(\\\"process.chdir is not supported\\\")}}).call(this,t(\\\"lYpoI2\\\"),\\\"undefined\\\"!=typeof self?self:\\\"undefined\\\"!=typeof window?window:{},t(\\\"buffer\\\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\\\"/node_modules/gulp-browserify/node_modules/process/browser.js\\\",\\\"/node_modules/gulp-browserify/node_modules/process\\\")},{buffer:3,lYpoI2:10}],11:[function(t,e,n){(function(t,e,r,i,o,u,a,s,f){n.read=function(t,e,n,r,i){var o,u,a=8*i-r-1,s=(1<<a)-1,f=s>>1,c=-7,l=n?i-1:0,p=n?-1:1,h=t[e+l];for(l+=p,o=h&(1<<-c)-1,h>>=-c,c+=a;c>0;o=256*o+t[e+l],l+=p,c-=8);for(u=o&(1<<-c)-1,o>>=-c,c+=r;c>0;u=256*u+t[e+l],l+=p,c-=8);if(0===o)o=1-f;else{if(o===s)return u?NaN:1/0*(h?-1:1);u+=Math.pow(2,r),o-=f}return(h?-1:1)*u*Math.pow(2,o-r)},n.write=function(t,e,n,r,i,o){var u,a,s,f=8*o-i-1,c=(1<<f)-1,l=c>>1,p=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,h=r?0:o-1,y=r?1:-1,d=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,u=c):(u=Math.floor(Math.log(e)/Math.LN2),e*(s=Math.pow(2,-u))<1&&(u--,s*=2),(e+=u+l>=1?p/s:p*Math.pow(2,1-l))*s>=2&&(u++,s/=2),u+l>=c?(a=0,u=c):u+l>=1?(a=(e*s-1)*Math.pow(2,i),u+=l):(a=e*Math.pow(2,l-1)*Math.pow(2,i),u=0));i>=8;t[n+h]=255&a,h+=y,a/=256,i-=8);for(u=u<<i|a,f+=i;f>0;t[n+h]=255&u,h+=y,u/=256,f-=8);t[n+h-y]|=128*d}}).call(this,t(\\\"lYpoI2\\\"),\\\"undefined\\\"!=typeof self?self:\\\"undefined\\\"!=typeof window?window:{},t(\\\"buffer\\\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\\\"/node_modules/ieee754/index.js\\\",\\\"/node_modules/ieee754\\\")},{buffer:3,lYpoI2:10}]},{},[1])(1)})}).call(this,\\\"undefined\\\"!=typeof global?global:\\\"undefined\\\"!=typeof self?self:\\\"undefined\\\"!=typeof window?window:{})},{}],95:[function(t,e,n){function r(){throw new Error(\\\"setTimeout has not been defined\\\")}function i(){throw new Error(\\\"clearTimeout has not been defined\\\")}function o(t){if(l===setTimeout)return setTimeout(t,0);if((l===r||!l)&&setTimeout)return l=setTimeout,setTimeout(t,0);try{return l(t,0)}catch(e){try{return l.call(null,t,0)}catch(e){return l.call(this,t,0)}}}function u(t){if(p===clearTimeout)return clearTimeout(t);if((p===i||!p)&&clearTimeout)return p=clearTimeout,clearTimeout(t);try{return p(t)}catch(e){try{return p.call(null,t)}catch(e){return p.call(this,t)}}}function a(){v&&y&&(v=!1,y.length?d=y.concat(d):g=-1,d.length&&s())}function s(){if(!v){var t=o(a);v=!0;for(var e=d.length;e;){for(y=d,d=[];++g<e;)y&&y[g].run();g=-1,e=d.length}y=null,v=!1,u(t)}}function f(t,e){this.fun=t,this.array=e}function c(){}var l,p,h=e.exports={};!function(){try{l=\\\"function\\\"==typeof setTimeout?setTimeout:r}catch(t){l=r}try{p=\\\"function\\\"==typeof clearTimeout?clearTimeout:i}catch(t){p=i}}();var y,d=[],v=!1,g=-1;h.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];d.push(new f(t,e)),1!==d.length||v||o(s)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title=\\\"browser\\\",h.browser=!0,h.env={},h.argv=[],h.version=\\\"\\\",h.versions={},h.on=c,h.addListener=c,h.once=c,h.off=c,h.removeListener=c,h.removeAllListeners=c,h.emit=c,h.prependListener=c,h.prependOnceListener=c,h.listeners=function(t){return[]},h.binding=function(t){throw new Error(\\\"process.binding is not supported\\\")},h.cwd=function(){return\\\"/\\\"},h.chdir=function(t){throw new Error(\\\"process.chdir is not supported\\\")},h.umask=function(){return 0}},{}],96:[function(t,e,n){(function(t){!function(t){\\\"use strict\\\";if(\\\"function\\\"==typeof bootstrap)bootstrap(\\\"promise\\\",t);else if(\\\"object\\\"==typeof n&&\\\"object\\\"==typeof e)e.exports=t();else if(\\\"undefined\\\"!=typeof ses){if(!ses.ok())return;ses.makeQ=t}else{if(\\\"undefined\\\"==typeof window&&\\\"undefined\\\"==typeof self)throw new Error(\\\"This environment was not anticipated by Q. Please file a bug.\\\");var r=\\\"undefined\\\"!=typeof window?window:self,i=r.Q;r.Q=t(),r.Q.noConflict=function(){return r.Q=i,this}}}(function(){\\\"use strict\\\";function e(t){return function(){return R.apply(t,arguments)}}function n(t){return t===Object(t)}function r(t){return\\\"[object StopIteration]\\\"===V(t)||t instanceof B}function i(t,e){if(T&&e.stack&&\\\"object\\\"==typeof t&&null!==t&&t.stack){for(var n=[],r=e;r;r=r.source)r.stack&&(!t.__minimumStackCounter__||t.__minimumStackCounter__>r.stackCounter)&&(F(t,\\\"__minimumStackCounter__\\\",{value:r.stackCounter,configurable:!0}),n.unshift(r.stack));n.unshift(t.stack);var i=o(n.join(\\\"\\\\n\\\"+Q+\\\"\\\\n\\\"));F(t,\\\"stack\\\",{value:i,configurable:!0})}}function o(t){for(var e=t.split(\\\"\\\\n\\\"),n=[],r=0;r<e.length;++r){var i=e[r];s(i)||u(i)||!i||n.push(i)}return n.join(\\\"\\\\n\\\")}function u(t){return-1!==t.indexOf(\\\"(module.js:\\\")||-1!==t.indexOf(\\\"(node.js:\\\")}function a(t){var e=/at .+ \\\\((.+):(\\\\d+):(?:\\\\d+)\\\\)$/.exec(t);if(e)return[e[1],Number(e[2])];var n=/at ([^ ]+):(\\\\d+):(?:\\\\d+)$/.exec(t);if(n)return[n[1],Number(n[2])];var r=/.*@(.+):(\\\\d+)$/.exec(t);return r?[r[1],Number(r[2])]:void 0}function s(t){var e=a(t);if(!e)return!1;var n=e[0],r=e[1];return n===P&&r>=C&&r<=X}function f(){if(T)try{throw new Error}catch(n){var t=n.stack.split(\\\"\\\\n\\\"),e=a(t[0].indexOf(\\\"@\\\")>0?t[1]:t[2]);if(!e)return;return P=e[0],e[1]}}function c(t){return t instanceof y?t:b(t)?O(t):x(t)}function l(){function t(t){e=t,c.longStackSupport&&T&&(o.source=t),N(n,function(e,n){c.nextTick(function(){t.promiseDispatch.apply(t,n)})},void 0),n=void 0,r=void 0}var e,n=[],r=[],i=z(l.prototype),o=z(y.prototype);if(o.promiseDispatch=function(t,i,o){var u=$(arguments);n?(n.push(u),\\\"when\\\"===i&&o[1]&&r.push(o[1])):c.nextTick(function(){e.promiseDispatch.apply(e,u)})},o.valueOf=function(){if(n)return o;var t=v(e);return g(t)&&(e=t),t},o.inspect=function(){return e?e.inspect():{state:\\\"pending\\\"}},c.longStackSupport&&T)try{throw new Error}catch(t){o.stack=t.stack.substring(t.stack.indexOf(\\\"\\\\n\\\")+1),o.stackCounter=K++}return i.promise=o,i.resolve=function(n){e||t(c(n))},i.fulfill=function(n){e||t(x(n))},i.reject=function(n){e||t(j(n))},i.notify=function(t){e||N(r,function(e,n){c.nextTick(function(){n(t)})},void 0)},i}function p(t){if(\\\"function\\\"!=typeof t)throw new TypeError(\\\"resolver must be a function.\\\");var e=l();try{t(e.resolve,e.reject,e.notify)}catch(t){e.reject(t)}return e.promise}function h(t){return p(function(e,n){for(var r=0,i=t.length;r<i;r++)c(t[r]).then(e,n)})}function y(t,e,n){void 0===e&&(e=function(t){return j(new Error(\\\"Promise does not support operation: \\\"+t))}),void 0===n&&(n=function(){return{state:\\\"unknown\\\"}});var r=z(y.prototype);if(r.promiseDispatch=function(n,i,o){var u;try{u=t[i]?t[i].apply(r,o):e.call(r,i,o)}catch(t){u=j(t)}n&&n(u)},r.inspect=n,n){var i=n();\\\"rejected\\\"===i.state&&(r.exception=i.reason),r.valueOf=function(){var t=n();return\\\"pending\\\"===t.state||\\\"rejected\\\"===t.state?r:t.value}}return r}function d(t,e,n,r){return c(t).then(e,n,r)}function v(t){if(g(t)){var e=t.inspect();if(\\\"fulfilled\\\"===e.state)return e.value}return t}function g(t){return t instanceof y}function b(t){return n(t)&&\\\"function\\\"==typeof t.then}function m(){W.length=0,H.length=0,G||(G=!0)}function w(e,n){G&&(\\\"object\\\"==typeof t&&\\\"function\\\"==typeof t.emit&&c.nextTick.runAfter(function(){-1!==M(H,e)&&(t.emit(\\\"unhandledRejection\\\",n,e),J.push(e))}),H.push(e),n&&void 0!==n.stack?W.push(n.stack):W.push(\\\"(no stack) \\\"+n))}function _(e){if(G){var n=M(H,e);-1!==n&&(\\\"object\\\"==typeof t&&\\\"function\\\"==typeof t.emit&&c.nextTick.runAfter(function(){var r=M(J,e);-1!==r&&(t.emit(\\\"rejectionHandled\\\",W[n],e),J.splice(r,1))}),H.splice(n,1),W.splice(n,1))}}function j(t){var e=y({when:function(e){return e&&_(this),e?e(t):this}},function(){return this},function(){return{state:\\\"rejected\\\",reason:t}});return w(e,t),e}function x(t){return y({when:function(){return t},get:function(e){return t[e]},set:function(e,n){t[e]=n},delete:function(e){delete t[e]},post:function(e,n){return null===e||void 0===e?t.apply(void 0,n):t[e].apply(t,n)},apply:function(e,n){return t.apply(e,n)},keys:function(){return q(t)}},void 0,function(){return{state:\\\"fulfilled\\\",value:t}})}function O(t){var e=l();return c.nextTick(function(){try{t.then(e.resolve,e.reject,e.notify)}catch(t){e.reject(t)}}),e.promise}function k(t,e,n){return c(t).spread(e,n)}function E(t,e,n){return c(t).dispatch(e,n)}function A(t){return d(t,function(t){var e=0,n=l();return N(t,function(r,i,o){var u;g(i)&&\\\"fulfilled\\\"===(u=i.inspect()).state?t[o]=u.value:(++e,d(i,function(r){t[o]=r,0==--e&&n.resolve(t)},n.reject,function(t){n.notify({index:o,value:t})}))},void 0),0===e&&n.resolve(t),n.promise})}function S(t){if(0===t.length)return c.resolve();var e=c.defer(),n=0;return N(t,function(r,i,o){var u=t[o];n++,d(u,function(t){e.resolve(t)},function(t){0==--n&&(t.message=\\\"Q can't get fulfillment value from any promise, all promises were rejected. Last error message: \\\"+t.message,e.reject(t))},function(t){e.notify({index:o,value:t})})},void 0),e.promise}function I(t){return d(t,function(t){return t=D(t,c),d(A(D(t,function(t){return d(t,L,L)})),function(){return t})})}var T=!1;try{throw new Error}catch(t){T=!!t.stack}var P,B,C=f(),L=function(){},U=function(){function e(){for(var t,e;r.next;)t=(r=r.next).task,r.task=void 0,(e=r.domain)&&(r.domain=void 0,e.enter()),n(t,e);for(;s.length;)n(t=s.pop());o=!1}function n(t,n){try{t()}catch(t){if(a)throw n&&n.exit(),setTimeout(e,0),n&&n.enter(),t;setTimeout(function(){throw t},0)}n&&n.exit()}var r={task:void 0,next:null},i=r,o=!1,u=void 0,a=!1,s=[];if(U=function(e){i=i.next={task:e,domain:a&&t.domain,next:null},o||(o=!0,u())},\\\"object\\\"==typeof t&&\\\"[object process]\\\"===t.toString()&&t.nextTick)a=!0,u=function(){t.nextTick(e)};else if(\\\"function\\\"==typeof setImmediate)u=\\\"undefined\\\"!=typeof window?setImmediate.bind(window,e):function(){setImmediate(e)};else if(\\\"undefined\\\"!=typeof MessageChannel){var f=new MessageChannel;f.port1.onmessage=function(){u=c,f.port1.onmessage=e,e()};var c=function(){f.port2.postMessage(0)};u=function(){setTimeout(e,0),c()}}else u=function(){setTimeout(e,0)};return U.runAfter=function(t){s.push(t),o||(o=!0,u())},U}(),R=Function.call,$=e(Array.prototype.slice),N=e(Array.prototype.reduce||function(t,e){var n=0,r=this.length;if(1===arguments.length)for(;;){if(n in this){e=this[n++];break}if(++n>=r)throw new TypeError}for(;n<r;n++)n in this&&(e=t(e,this[n],n));return e}),M=e(Array.prototype.indexOf||function(t){for(var e=0;e<this.length;e++)if(this[e]===t)return e;return-1}),D=e(Array.prototype.map||function(t,e){var n=this,r=[];return N(n,function(i,o,u){r.push(t.call(e,o,u,n))},void 0),r}),z=Object.create||function(t){function e(){}return e.prototype=t,new e},F=Object.defineProperty||function(t,e,n){return t[e]=n.value,t},Y=e(Object.prototype.hasOwnProperty),q=Object.keys||function(t){var e=[];for(var n in t)Y(t,n)&&e.push(n);return e},V=e(Object.prototype.toString);B=\\\"undefined\\\"!=typeof ReturnValue?ReturnValue:function(t){this.value=t};var Q=\\\"From previous event:\\\";c.resolve=c,c.nextTick=U,c.longStackSupport=!1;var K=1;\\\"object\\\"==typeof t&&t&&t.env&&t.env.Q_DEBUG&&(c.longStackSupport=!0),c.defer=l,l.prototype.makeNodeResolver=function(){var t=this;return function(e,n){e?t.reject(e):arguments.length>2?t.resolve($(arguments,1)):t.resolve(n)}},c.Promise=p,c.promise=p,p.race=h,p.all=A,p.reject=j,p.resolve=c,c.passByCopy=function(t){return t},y.prototype.passByCopy=function(){return this},c.join=function(t,e){return c(t).join(e)},y.prototype.join=function(t){return c([this,t]).spread(function(t,e){if(t===e)return t;throw new Error(\\\"Q can't join: not the same: \\\"+t+\\\" \\\"+e)})},c.race=h,y.prototype.race=function(){return this.then(c.race)},c.makePromise=y,y.prototype.toString=function(){return\\\"[object Promise]\\\"},y.prototype.then=function(t,e,n){function r(e){try{return\\\"function\\\"==typeof t?t(e):e}catch(t){return j(t)}}function o(t){if(\\\"function\\\"==typeof e){i(t,a);try{return e(t)}catch(t){return j(t)}}return j(t)}function u(t){return\\\"function\\\"==typeof n?n(t):t}var a=this,s=l(),f=!1;return c.nextTick(function(){a.promiseDispatch(function(t){f||(f=!0,s.resolve(r(t)))},\\\"when\\\",[function(t){f||(f=!0,s.resolve(o(t)))}])}),a.promiseDispatch(void 0,\\\"when\\\",[void 0,function(t){var e,n=!1;try{e=u(t)}catch(t){if(n=!0,!c.onerror)throw t;c.onerror(t)}n||s.notify(e)}]),s.promise},c.tap=function(t,e){return c(t).tap(e)},y.prototype.tap=function(t){return t=c(t),this.then(function(e){return t.fcall(e).thenResolve(e)})},c.when=d,y.prototype.thenResolve=function(t){return this.then(function(){return t})},c.thenResolve=function(t,e){return c(t).thenResolve(e)},y.prototype.thenReject=function(t){return this.then(function(){throw t})},c.thenReject=function(t,e){return c(t).thenReject(e)},c.nearer=v,c.isPromise=g,c.isPromiseAlike=b,c.isPending=function(t){return g(t)&&\\\"pending\\\"===t.inspect().state},y.prototype.isPending=function(){return\\\"pending\\\"===this.inspect().state},c.isFulfilled=function(t){return!g(t)||\\\"fulfilled\\\"===t.inspect().state},y.prototype.isFulfilled=function(){return\\\"fulfilled\\\"===this.inspect().state},c.isRejected=function(t){return g(t)&&\\\"rejected\\\"===t.inspect().state},y.prototype.isRejected=function(){return\\\"rejected\\\"===this.inspect().state};var W=[],H=[],J=[],G=!0;c.resetUnhandledRejections=m,c.getUnhandledReasons=function(){return W.slice()},c.stopUnhandledRejectionTracking=function(){m(),G=!1},m(),c.reject=j,c.fulfill=x,c.master=function(t){return y({isDef:function(){}},function(e,n){return E(t,e,n)},function(){return c(t).inspect()})},c.spread=k,y.prototype.spread=function(t,e){return this.all().then(function(e){return t.apply(void 0,e)},e)},c.async=function(t){return function(){function e(t,e){var u;if(\\\"undefined\\\"==typeof StopIteration){try{u=n[t](e)}catch(t){return j(t)}return u.done?c(u.value):d(u.value,i,o)}try{u=n[t](e)}catch(t){return r(t)?c(t.value):j(t)}return d(u,i,o)}var n=t.apply(this,arguments),i=e.bind(e,\\\"next\\\"),o=e.bind(e,\\\"throw\\\");return i()}},c.spawn=function(t){c.done(c.async(t)())},c.return=function(t){throw new B(t)},c.promised=function(t){return function(){return k([this,A(arguments)],function(e,n){return t.apply(e,n)})}},c.dispatch=E,y.prototype.dispatch=function(t,e){var n=this,r=l();return c.nextTick(function(){n.promiseDispatch(r.resolve,t,e)}),r.promise},c.get=function(t,e){return c(t).dispatch(\\\"get\\\",[e])},y.prototype.get=function(t){return this.dispatch(\\\"get\\\",[t])},c.set=function(t,e,n){return c(t).dispatch(\\\"set\\\",[e,n])},y.prototype.set=function(t,e){return this.dispatch(\\\"set\\\",[t,e])},c.del=c.delete=function(t,e){return c(t).dispatch(\\\"delete\\\",[e])},y.prototype.del=y.prototype.delete=function(t){return this.dispatch(\\\"delete\\\",[t])},c.mapply=c.post=function(t,e,n){return c(t).dispatch(\\\"post\\\",[e,n])},y.prototype.mapply=y.prototype.post=function(t,e){return this.dispatch(\\\"post\\\",[t,e])},c.send=c.mcall=c.invoke=function(t,e){return c(t).dispatch(\\\"post\\\",[e,$(arguments,2)])},y.prototype.send=y.prototype.mcall=y.prototype.invoke=function(t){return this.dispatch(\\\"post\\\",[t,$(arguments,1)])},c.fapply=function(t,e){return c(t).dispatch(\\\"apply\\\",[void 0,e])},y.prototype.fapply=function(t){return this.dispatch(\\\"apply\\\",[void 0,t])},c.try=c.fcall=function(t){return c(t).dispatch(\\\"apply\\\",[void 0,$(arguments,1)])},y.prototype.fcall=function(){return this.dispatch(\\\"apply\\\",[void 0,$(arguments)])},c.fbind=function(t){var e=c(t),n=$(arguments,1);return function(){return e.dispatch(\\\"apply\\\",[this,n.concat($(arguments))])}},y.prototype.fbind=function(){var t=this,e=$(arguments);return function(){return t.dispatch(\\\"apply\\\",[this,e.concat($(arguments))])}},c.keys=function(t){return c(t).dispatch(\\\"keys\\\",[])},y.prototype.keys=function(){return this.dispatch(\\\"keys\\\",[])},c.all=A,y.prototype.all=function(){return A(this)},c.any=S,y.prototype.any=function(){return S(this)},c.allResolved=function(t,e,n){return function(){return\\\"undefined\\\"!=typeof console&&\\\"function\\\"==typeof console.warn&&console.warn(e+\\\" is deprecated, use \\\"+n+\\\" instead.\\\",new Error(\\\"\\\").stack),t.apply(t,arguments)}}(I,\\\"allResolved\\\",\\\"allSettled\\\"),y.prototype.allResolved=function(){return I(this)},c.allSettled=function(t){return c(t).allSettled()},y.prototype.allSettled=function(){return this.then(function(t){return A(D(t,function(t){function e(){return t.inspect()}return(t=c(t)).then(e,e)}))})},c.fail=c.catch=function(t,e){return c(t).then(void 0,e)},y.prototype.fail=y.prototype.catch=function(t){return this.then(void 0,t)},c.progress=function(t,e){return c(t).then(void 0,void 0,e)},y.prototype.progress=function(t){return this.then(void 0,void 0,t)},c.fin=c.finally=function(t,e){return c(t).finally(e)},y.prototype.fin=y.prototype.finally=function(t){if(!t||\\\"function\\\"!=typeof t.apply)throw new Error(\\\"Q can't apply finally callback\\\");return t=c(t),this.then(function(e){return t.fcall().then(function(){return e})},function(e){return t.fcall().then(function(){throw e})})},c.done=function(t,e,n,r){return c(t).done(e,n,r)},y.prototype.done=function(e,n,r){var o=function(t){c.nextTick(function(){if(i(t,u),!c.onerror)throw t;c.onerror(t)})},u=e||n||r?this.then(e,n,r):this;\\\"object\\\"==typeof t&&t&&t.domain&&(o=t.domain.bind(o)),u.then(void 0,o)},c.timeout=function(t,e,n){return c(t).timeout(e,n)},y.prototype.timeout=function(t,e){var n=l(),r=setTimeout(function(){e&&\\\"string\\\"!=typeof e||((e=new Error(e||\\\"Timed out after \\\"+t+\\\" ms\\\")).code=\\\"ETIMEDOUT\\\"),n.reject(e)},t);return this.then(function(t){clearTimeout(r),n.resolve(t)},function(t){clearTimeout(r),n.reject(t)},n.notify),n.promise},c.delay=function(t,e){return void 0===e&&(e=t,t=void 0),c(t).delay(e)},y.prototype.delay=function(t){return this.then(function(e){var n=l();return setTimeout(function(){n.resolve(e)},t),n.promise})},c.nfapply=function(t,e){return c(t).nfapply(e)},y.prototype.nfapply=function(t){var e=l(),n=$(t);return n.push(e.makeNodeResolver()),this.fapply(n).fail(e.reject),e.promise},c.nfcall=function(t){var e=$(arguments,1);return c(t).nfapply(e)},y.prototype.nfcall=function(){var t=$(arguments),e=l();return t.push(e.makeNodeResolver()),this.fapply(t).fail(e.reject),e.promise},c.nfbind=c.denodeify=function(t){if(void 0===t)throw new Error(\\\"Q can't wrap an undefined function\\\");var e=$(arguments,1);return function(){var n=e.concat($(arguments)),r=l();return n.push(r.makeNodeResolver()),c(t).fapply(n).fail(r.reject),r.promise}},y.prototype.nfbind=y.prototype.denodeify=function(){var t=$(arguments);return t.unshift(this),c.denodeify.apply(void 0,t)},c.nbind=function(t,e){var n=$(arguments,2);return function(){var r=n.concat($(arguments)),i=l();return r.push(i.makeNodeResolver()),c(function(){return t.apply(e,arguments)}).fapply(r).fail(i.reject),i.promise}},y.prototype.nbind=function(){var t=$(arguments,0);return t.unshift(this),c.nbind.apply(void 0,t)},c.nmapply=c.npost=function(t,e,n){return c(t).npost(e,n)},y.prototype.nmapply=y.prototype.npost=function(t,e){var n=$(e||[]),r=l();return n.push(r.makeNodeResolver()),this.dispatch(\\\"post\\\",[t,n]).fail(r.reject),r.promise},c.nsend=c.nmcall=c.ninvoke=function(t,e){var n=$(arguments,2),r=l();return n.push(r.makeNodeResolver()),c(t).dispatch(\\\"post\\\",[e,n]).fail(r.reject),r.promise},y.prototype.nsend=y.prototype.nmcall=y.prototype.ninvoke=function(t){var e=$(arguments,1),n=l();return e.push(n.makeNodeResolver()),this.dispatch(\\\"post\\\",[t,e]).fail(n.reject),n.promise},c.nodeify=function(t,e){return c(t).nodeify(e)},y.prototype.nodeify=function(t){if(!t)return this;this.then(function(e){c.nextTick(function(){t(null,e)})},function(e){c.nextTick(function(){t(e)})})},c.noConflict=function(){throw new Error(\\\"Q.noConflict only works when Q is used as a global\\\")};var X=f();return c})}).call(this,t(\\\"_process\\\"))},{_process:95}],97:[function(t,e,n){\\\"use strict\\\";e.exports=2147483647},{}],98:[function(t,e,n){\\\"use strict\\\";var r=t(\\\"es5-ext/number/to-pos-integer\\\"),i=t(\\\"./max-timeout\\\");e.exports=function(t){if((t=r(t))>i)throw new TypeError(t+\\\" exceeds maximum possible timeout\\\");return t}},{\\\"./max-timeout\\\":97,\\\"es5-ext/number/to-pos-integer\\\":44}]},{},[8])(8)});\\r\\n//# sourceMappingURL=zangodb.min.js.map\\r\\n\""
		},
		{
			"name": "signals.min.js",
			"source": "\"/*\\r\\n     JS Signals <http://millermedeiros.github.com/js-signals/>\\r\\n     Released under the MIT license\\r\\n     Author: Miller Medeiros\\r\\n     Version: 1.0.0 - Build: 268 (2012/11/29 05:48 PM)\\r\\n*/\\r\\n\\r\\n(function(i){function h(a,b,c,d,e){this._listener=b;this._isOnce=c;this.context=d;this._signal=a;this._priority=e||0}function g(a,b){if(typeof a!==\\\"function\\\")throw Error(\\\"listener is a required param of {fn}() and should be a Function.\\\".replace(\\\"{fn}\\\",b));}function e(){this._bindings=[];this._prevParams=null;var a=this;this.dispatch=function(){e.prototype.dispatch.apply(a,arguments)}}h.prototype={active:!0,params:null,execute:function(a){var b;this.active&&this._listener&&(a=this.params?this.params.concat(a):a,b=this._listener.apply(this.context,a),this._isOnce&&this.detach());return b},detach:function(){return this.isBound()?this._signal.remove(this._listener,this.context):null},isBound:function(){return!!this._signal&&!!this._listener},isOnce:function(){return this._isOnce},getListener:function(){return this._listener},getSignal:function(){return this._signal},_destroy:function(){delete this._signal;delete this._listener;delete this.context},toString:function(){return\\\"[SignalBinding isOnce:\\\"+this._isOnce+\\\", isBound:\\\"+this.isBound()+\\\", active:\\\"+this.active+\\\"]\\\"}};e.prototype={VERSION:\\\"1.0.0\\\",memorize:!1,_shouldPropagate:!0,active:!0,_registerListener:function(a,b,c,d){var e=this._indexOfListener(a,c);if(e!==-1){if(a=this._bindings[e],a.isOnce()!==b)throw Error(\\\"You cannot add\\\"+(b?\\\"\\\":\\\"Once\\\")+\\\"() then add\\\"+(!b?\\\"\\\":\\\"Once\\\")+\\\"() the same listener without removing the relationship first.\\\");}else a=new h(this,a,b,c,d),this._addBinding(a);this.memorize&&this._prevParams&&a.execute(this._prevParams);return a},_addBinding:function(a){var b=this._bindings.length;do--b;while(this._bindings[b]&&a._priority<=this._bindings[b]._priority);this._bindings.splice(b+1,0,a)},_indexOfListener:function(a,b){for(var c=this._bindings.length,d;c--;)if(d=this._bindings[c],d._listener===a&&d.context===b)return c;return-1},has:function(a,b){return this._indexOfListener(a,b)!==-1},add:function(a,b,c){g(a,\\\"add\\\");return this._registerListener(a,!1,b,c)},addOnce:function(a,b,c){g(a,\\\"addOnce\\\");return this._registerListener(a,!0,b,c)},remove:function(a,b){g(a,\\\"remove\\\");var c=this._indexOfListener(a,b);c!==-1&&(this._bindings[c]._destroy(),this._bindings.splice(c,1));return a},removeAll:function(){for(var a=this._bindings.length;a--;)this._bindings[a]._destroy();this._bindings.length=0},getNumListeners:function(){return this._bindings.length},halt:function(){this._shouldPropagate=!1},dispatch:function(a){if(this.active){var b=Array.prototype.slice.call(arguments),c=this._bindings.length,d;if(this.memorize)this._prevParams=b;if(c){d=this._bindings.slice();this._shouldPropagate=!0;do c--;while(d[c]&&this._shouldPropagate&&d[c].execute(b)!==!1)}}},forget:function(){this._prevParams=null},dispose:function(){this.removeAll();delete this._bindings;delete this._prevParams},toString:function(){return\\\"[Signal active:\\\"+this.active+\\\" numListeners:\\\"+this.getNumListeners()+\\\"]\\\"}};var f=e;f.Signal=e;typeof define===\\\"function\\\"&&define.amd?define(function(){return f}):typeof module!==\\\"undefined\\\"&&module.exports?module.exports=f:i.signals=f})(this);\\r\\n\""
		},
		{
			"name": "validator.min.js",
			"source": "\"/*!\\r\\n * Copyright (c) 2016 Chris O'Hara <cohara87@gmail.com>\\r\\n * \\r\\n * Permission is hereby granted, free of charge, to any person obtaining\\r\\n * a copy of this software and associated documentation files (the\\r\\n * \\\"Software\\\"), to deal in the Software without restriction, including\\r\\n * without limitation the rights to use, copy, modify, merge, publish,\\r\\n * distribute, sublicense, and/or sell copies of the Software, and to\\r\\n * permit persons to whom the Software is furnished to do so, subject to\\r\\n * the following conditions:\\r\\n * \\r\\n * The above copyright notice and this permission notice shall be\\r\\n * included in all copies or substantial portions of the Software.\\r\\n * \\r\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND,\\r\\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\r\\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\\r\\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\\r\\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\\r\\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\\r\\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\r\\n */\\r\\n!function(e,t){\\\"object\\\"==typeof exports&&\\\"undefined\\\"!=typeof module?module.exports=t():\\\"function\\\"==typeof define&&define.amd?define(t):e.validator=t()}(this,function(){\\\"use strict\\\";function f(e){if(!(\\\"string\\\"==typeof e||e instanceof String))throw new TypeError(\\\"This library (validator.js) validates strings only\\\")}function i(e){return f(e),e=Date.parse(e),isNaN(e)?null:new Date(e)}function r(e){return f(e),parseFloat(e)}var a=\\\"function\\\"==typeof Symbol&&\\\"symbol\\\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\\\"function\\\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\\\"symbol\\\":typeof e};function n(e){return\\\"object\\\"===(void 0===e?\\\"undefined\\\":a(e))&&null!==e?e=\\\"function\\\"==typeof e.toString?e.toString():\\\"[object Object]\\\":(null==e||isNaN(e)&&!e.length)&&(e=\\\"\\\"),String(e)}function c(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=arguments[1];for(var r in t)void 0===e[r]&&(e[r]=t[r]);return e}function d(e,t){f(e);var r=void 0,o=void 0;\\\"object\\\"===(void 0===t?\\\"undefined\\\":a(t))?(r=t.min||0,o=t.max):(r=t,o=arguments[2]);var i=encodeURI(e).split(/%..|./).length-1;return r<=i&&(void 0===o||i<=o)}var l={require_tld:!0,allow_underscores:!1,allow_trailing_dot:!1};function p(e,t){f(e),(t=c(t,l)).allow_trailing_dot&&\\\".\\\"===e[e.length-1]&&(e=e.substring(0,e.length-1));for(var r=e.split(\\\".\\\"),o=0;o<r.length;o++)if(63<r[o].length)return!1;if(t.require_tld){var i=r.pop();if(!r.length||!/^([a-z\\\\u00a1-\\\\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(i))return!1;if(/[\\\\s\\\\u2002-\\\\u200B\\\\u202F\\\\u205F\\\\u3000\\\\uFEFF\\\\uDB40\\\\uDC20]/.test(i))return!1}for(var n,a=0;a<r.length;a++){if(n=r[a],t.allow_underscores&&(n=n.replace(/_/g,\\\"\\\")),!/^[a-z\\\\u00a1-\\\\uffff0-9-]+$/i.test(n))return!1;if(/[\\\\uff01-\\\\uff5e]/.test(n))return!1;if(\\\"-\\\"===n[0]||\\\"-\\\"===n[n.length-1])return!1}return!0}var g={allow_display_name:!1,require_display_name:!1,allow_utf8_local_part:!0,require_tld:!0},A=/^[a-z\\\\d!#\\\\$%&'\\\\*\\\\+\\\\-\\\\/=\\\\?\\\\^_`{\\\\|}~\\\\.\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]+[a-z\\\\d!#\\\\$%&'\\\\*\\\\+\\\\-\\\\/=\\\\?\\\\^_`{\\\\|}~\\\\,\\\\.\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\\\\s]*<(.+)>$/i,h=/^[a-z\\\\d!#\\\\$%&'\\\\*\\\\+\\\\-\\\\/=\\\\?\\\\^_`{\\\\|}~]+$/i,v=/^([\\\\s\\\\x01-\\\\x08\\\\x0b\\\\x0c\\\\x0e-\\\\x1f\\\\x7f\\\\x21\\\\x23-\\\\x5b\\\\x5d-\\\\x7e]|(\\\\\\\\[\\\\x01-\\\\x09\\\\x0b\\\\x0c\\\\x0d-\\\\x7f]))*$/i,m=/^[a-z\\\\d!#\\\\$%&'\\\\*\\\\+\\\\-\\\\/=\\\\?\\\\^_`{\\\\|}~\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]+$/i,_=/^([\\\\s\\\\x01-\\\\x08\\\\x0b\\\\x0c\\\\x0e-\\\\x1f\\\\x7f\\\\x21\\\\x23-\\\\x5b\\\\x5d-\\\\x7e\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]|(\\\\\\\\[\\\\x01-\\\\x09\\\\x0b\\\\x0c\\\\x0d-\\\\x7f\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]))*$/i;var s=/^(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})$/,u=/^[0-9A-F]{1,4}$/i;function F(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:\\\"\\\";if(f(e),!(t=String(t)))return F(e,4)||F(e,6);if(\\\"4\\\"===t)return!!s.test(e)&&e.split(\\\".\\\").sort(function(e,t){return e-t})[3]<=255;if(\\\"6\\\"===t){var r=e.split(\\\":\\\"),o=!1,i=F(r[r.length-1],4),n=i?7:8;if(r.length>n)return!1;if(\\\"::\\\"===e)return!0;\\\"::\\\"===e.substr(0,2)?(r.shift(),r.shift(),o=!0):\\\"::\\\"===e.substr(e.length-2)&&(r.pop(),r.pop(),o=!0);for(var a=0;a<r.length;++a)if(\\\"\\\"===r[a]&&0<a&&a<r.length-1){if(o)return!1;o=!0}else if(i&&a===r.length-1);else if(!u.test(r[a]))return!1;return o?1<=r.length:r.length===n}return!1}var $={protocols:[\\\"http\\\",\\\"https\\\",\\\"ftp\\\"],require_tld:!0,require_protocol:!1,require_host:!0,require_valid_protocol:!0,allow_underscores:!1,allow_trailing_dot:!1,allow_protocol_relative_urls:!1},S=/^\\\\[([^\\\\]]+)\\\\](?::([0-9]+))?$/;function R(e,t){for(var r=0;r<t.length;r++){var o=t[r];if(e===o||(i=o,\\\"[object RegExp]\\\"===Object.prototype.toString.call(i)&&o.test(e)))return!0}var i;return!1}var t=/^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$/;for(var e,o={\\\"en-US\\\":/^[A-Z]+$/i,\\\"bg-BG\\\":/^[А-Я]+$/i,\\\"cs-CZ\\\":/^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,\\\"da-DK\\\":/^[A-ZÆØÅ]+$/i,\\\"de-DE\\\":/^[A-ZÄÖÜß]+$/i,\\\"el-GR\\\":/^[Α-ω]+$/i,\\\"es-ES\\\":/^[A-ZÁÉÍÑÓÚÜ]+$/i,\\\"fr-FR\\\":/^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,\\\"it-IT\\\":/^[A-ZÀÉÈÌÎÓÒÙ]+$/i,\\\"nb-NO\\\":/^[A-ZÆØÅ]+$/i,\\\"nl-NL\\\":/^[A-ZÁÉËÏÓÖÜÚ]+$/i,\\\"nn-NO\\\":/^[A-ZÆØÅ]+$/i,\\\"hu-HU\\\":/^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,\\\"pl-PL\\\":/^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,\\\"pt-PT\\\":/^[A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]+$/i,\\\"ru-RU\\\":/^[А-ЯЁ]+$/i,\\\"sk-SK\\\":/^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,\\\"sr-RS@latin\\\":/^[A-ZČĆŽŠĐ]+$/i,\\\"sr-RS\\\":/^[А-ЯЂЈЉЊЋЏ]+$/i,\\\"sv-SE\\\":/^[A-ZÅÄÖ]+$/i,\\\"tr-TR\\\":/^[A-ZÇĞİıÖŞÜ]+$/i,\\\"uk-UA\\\":/^[А-ЩЬЮЯЄIЇҐі]+$/i,ar:/^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/},E={\\\"en-US\\\":/^[0-9A-Z]+$/i,\\\"bg-BG\\\":/^[0-9А-Я]+$/i,\\\"cs-CZ\\\":/^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,\\\"da-DK\\\":/^[0-9A-ZÆØÅ]+$/i,\\\"de-DE\\\":/^[0-9A-ZÄÖÜß]+$/i,\\\"el-GR\\\":/^[0-9Α-ω]+$/i,\\\"es-ES\\\":/^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,\\\"fr-FR\\\":/^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,\\\"it-IT\\\":/^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i,\\\"hu-HU\\\":/^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,\\\"nb-NO\\\":/^[0-9A-ZÆØÅ]+$/i,\\\"nl-NL\\\":/^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i,\\\"nn-NO\\\":/^[0-9A-ZÆØÅ]+$/i,\\\"pl-PL\\\":/^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,\\\"pt-PT\\\":/^[0-9A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]+$/i,\\\"ru-RU\\\":/^[0-9А-ЯЁ]+$/i,\\\"sk-SK\\\":/^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,\\\"sr-RS@latin\\\":/^[0-9A-ZČĆŽŠĐ]+$/i,\\\"sr-RS\\\":/^[0-9А-ЯЂЈЉЊЋЏ]+$/i,\\\"sv-SE\\\":/^[0-9A-ZÅÄÖ]+$/i,\\\"tr-TR\\\":/^[0-9A-ZÇĞİıÖŞÜ]+$/i,\\\"uk-UA\\\":/^[0-9А-ЩЬЮЯЄIЇҐі]+$/i,ar:/^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/},x={\\\"en-US\\\":\\\".\\\",ar:\\\"٫\\\"},M=[\\\"AU\\\",\\\"GB\\\",\\\"HK\\\",\\\"IN\\\",\\\"NZ\\\",\\\"ZA\\\",\\\"ZM\\\"],C=0;C<M.length;C++)o[e=\\\"en-\\\"+M[C]]=o[\\\"en-US\\\"],E[e]=E[\\\"en-US\\\"],x[e]=x[\\\"en-US\\\"];for(var N,w=[\\\"AE\\\",\\\"BH\\\",\\\"DZ\\\",\\\"EG\\\",\\\"IQ\\\",\\\"JO\\\",\\\"KW\\\",\\\"LB\\\",\\\"LY\\\",\\\"MA\\\",\\\"QM\\\",\\\"QA\\\",\\\"SA\\\",\\\"SD\\\",\\\"SY\\\",\\\"TN\\\",\\\"YE\\\"],T=0;T<w.length;T++)o[N=\\\"ar-\\\"+w[T]]=o.ar,E[N]=E.ar,x[N]=x.ar;for(var Z=[],B=[\\\"bg-BG\\\",\\\"cs-CZ\\\",\\\"da-DK\\\",\\\"de-DE\\\",\\\"el-GR\\\",\\\"es-ES\\\",\\\"fr-FR\\\",\\\"it-IT\\\",\\\"hu-HU\\\",\\\"nb-NO\\\",\\\"nn-NO\\\",\\\"nl-NL\\\",\\\"pl-Pl\\\",\\\"pt-PT\\\",\\\"ru-RU\\\",\\\"sr-RS@latin\\\",\\\"sr-RS\\\",\\\"sv-SE\\\",\\\"tr-TR\\\",\\\"uk-UA\\\"],I=0;I<Z.length;I++)x[Z[I]]=x[\\\"en-US\\\"];for(var L=0;L<B.length;L++)x[B[L]]=\\\",\\\";o[\\\"pt-BR\\\"]=o[\\\"pt-PT\\\"],E[\\\"pt-BR\\\"]=E[\\\"pt-PT\\\"],x[\\\"pt-BR\\\"]=x[\\\"pt-PT\\\"];var y=/^[+-]?([0-9]*[.])?[0-9]+$/;var G=/^(?:[-+]?(?:0|[1-9][0-9]*))$/,D=/^[-+]?[0-9]+$/;function O(e,t){f(e);var r=(t=t||{}).hasOwnProperty(\\\"allow_leading_zeroes\\\")&&!t.allow_leading_zeroes?G:D,o=!t.hasOwnProperty(\\\"min\\\")||e>=t.min,i=!t.hasOwnProperty(\\\"max\\\")||e<=t.max,n=!t.hasOwnProperty(\\\"lt\\\")||e<t.lt,a=!t.hasOwnProperty(\\\"gt\\\")||e>t.gt;return r.test(e)&&o&&i&&n&&a}var U=/^[\\\\x00-\\\\x7F]+$/;var b=/[^\\\\u0020-\\\\u007E\\\\uFF61-\\\\uFF9F\\\\uFFA0-\\\\uFFDC\\\\uFFE8-\\\\uFFEE0-9a-zA-Z]/;var P=/[\\\\u0020-\\\\u007E\\\\uFF61-\\\\uFF9F\\\\uFFA0-\\\\uFFDC\\\\uFFE8-\\\\uFFEE0-9a-zA-Z]/;var K=/[^\\\\x00-\\\\x7F]/;var k=/[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]/;var H={force_decimal:!1,decimal_digits:\\\"1,\\\",locale:\\\"en-US\\\"},z=[\\\"\\\",\\\"-\\\",\\\"+\\\"];var V=/^[0-9A-F]+$/i;function W(e){return f(e),V.test(e)}var Y=/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i;var j=/^[A-Z]{2}[0-9A-Z]{3}\\\\d{2}\\\\d{5}$/;var J=/^[a-f0-9]{32}$/;var q={md5:32,md4:32,sha1:40,sha256:64,sha384:96,sha512:128,ripemd128:32,ripemd160:40,tiger128:32,tiger160:40,tiger192:48,crc32:8,crc32b:8};var Q={3:/^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,4:/^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,5:/^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,all:/^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i};var X=/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\\\d{3})\\\\d{11}|6[27][0-9]{14})$/;var ee=/^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;var te=/^(?:[0-9]{9}X|[0-9]{10})$/,re=/^(?:[0-9]{13})$/,oe=[1,3];var ie=\\\"^\\\\\\\\d{4}-?\\\\\\\\d{3}[\\\\\\\\dX]$\\\";var ne={\\\"ar-AE\\\":/^((\\\\+?971)|0)?5[024568]\\\\d{7}$/,\\\"ar-DZ\\\":/^(\\\\+?213|0)(5|6|7)\\\\d{8}$/,\\\"ar-EG\\\":/^((\\\\+?20)|0)?1[012]\\\\d{8}$/,\\\"ar-JO\\\":/^(\\\\+?962|0)?7[789]\\\\d{7}$/,\\\"ar-SA\\\":/^(!?(\\\\+?966)|0)?5\\\\d{8}$/,\\\"ar-SY\\\":/^(!?(\\\\+?963)|0)?9\\\\d{8}$/,\\\"be-BY\\\":/^(\\\\+?375)?(24|25|29|33|44)\\\\d{7}$/,\\\"bg-BG\\\":/^(\\\\+?359|0)?8[789]\\\\d{7}$/,\\\"cs-CZ\\\":/^(\\\\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,\\\"da-DK\\\":/^(\\\\+?45)?\\\\s?\\\\d{2}\\\\s?\\\\d{2}\\\\s?\\\\d{2}\\\\s?\\\\d{2}$/,\\\"de-DE\\\":/^(\\\\+?49[ \\\\.\\\\-])?([\\\\(]{1}[0-9]{1,6}[\\\\)])?([0-9 \\\\.\\\\-\\\\/]{3,20})((x|ext|extension)[ ]?[0-9]{1,4})?$/,\\\"el-GR\\\":/^(\\\\+?30|0)?(69\\\\d{8})$/,\\\"en-AU\\\":/^(\\\\+?61|0)4\\\\d{8}$/,\\\"en-GB\\\":/^(\\\\+?44|0)7\\\\d{9}$/,\\\"en-HK\\\":/^(\\\\+?852\\\\-?)?[456789]\\\\d{3}\\\\-?\\\\d{4}$/,\\\"en-IN\\\":/^(\\\\+?91|0)?[6789]\\\\d{9}$/,\\\"en-KE\\\":/^(\\\\+?254|0)?[7]\\\\d{8}$/,\\\"en-NG\\\":/^(\\\\+?234|0)?[789]\\\\d{9}$/,\\\"en-NZ\\\":/^(\\\\+?64|0)2\\\\d{7,9}$/,\\\"en-PK\\\":/^((\\\\+92)|(0092))-{0,1}\\\\d{3}-{0,1}\\\\d{7}$|^\\\\d{11}$|^\\\\d{4}-\\\\d{7}$/,\\\"en-RW\\\":/^(\\\\+?250|0)?[7]\\\\d{8}$/,\\\"en-SG\\\":/^(\\\\+65)?[89]\\\\d{7}$/,\\\"en-TZ\\\":/^(\\\\+?255|0)?[67]\\\\d{8}$/,\\\"en-UG\\\":/^(\\\\+?256|0)?[7]\\\\d{8}$/,\\\"en-US\\\":/^(\\\\+?1)?[2-9]\\\\d{2}[2-9](?!11)\\\\d{6}$/,\\\"en-ZA\\\":/^(\\\\+?27|0)\\\\d{9}$/,\\\"en-ZM\\\":/^(\\\\+?26)?09[567]\\\\d{7}$/,\\\"es-ES\\\":/^(\\\\+?34)?(6\\\\d{1}|7[1234])\\\\d{7}$/,\\\"et-EE\\\":/^(\\\\+?372)?\\\\s?(5|8[1-4])\\\\s?([0-9]\\\\s?){6,7}$/,\\\"fa-IR\\\":/^(\\\\+?98[\\\\-\\\\s]?|0)9[0-39]\\\\d[\\\\-\\\\s]?\\\\d{3}[\\\\-\\\\s]?\\\\d{4}$/,\\\"fi-FI\\\":/^(\\\\+?358|0)\\\\s?(4(0|1|2|4|5|6)?|50)\\\\s?(\\\\d\\\\s?){4,8}\\\\d$/,\\\"fo-FO\\\":/^(\\\\+?298)?\\\\s?\\\\d{2}\\\\s?\\\\d{2}\\\\s?\\\\d{2}$/,\\\"fr-FR\\\":/^(\\\\+?33|0)[67]\\\\d{8}$/,\\\"he-IL\\\":/^(\\\\+972|0)([23489]|5[012345689]|77)[1-9]\\\\d{6}/,\\\"hu-HU\\\":/^(\\\\+?36)(20|30|70)\\\\d{7}$/,\\\"id-ID\\\":/^(\\\\+?62|0[1-9])[\\\\s|\\\\d]+$/,\\\"it-IT\\\":/^(\\\\+?39)?\\\\s?3\\\\d{2} ?\\\\d{6,7}$/,\\\"ja-JP\\\":/^(\\\\+?81|0)[789]0[ \\\\-]?[1-9]\\\\d{2}[ \\\\-]?\\\\d{5}$/,\\\"kk-KZ\\\":/^(\\\\+?7|8)?7\\\\d{9}$/,\\\"kl-GL\\\":/^(\\\\+?299)?\\\\s?\\\\d{2}\\\\s?\\\\d{2}\\\\s?\\\\d{2}$/,\\\"ko-KR\\\":/^((\\\\+?82)[ \\\\-]?)?0?1([0|1|6|7|8|9]{1})[ \\\\-]?\\\\d{3,4}[ \\\\-]?\\\\d{4}$/,\\\"lt-LT\\\":/^(\\\\+370|8)\\\\d{8}$/,\\\"ms-MY\\\":/^(\\\\+?6?01){1}(([145]{1}(\\\\-|\\\\s)?\\\\d{7,8})|([236789]{1}(\\\\s|\\\\-)?\\\\d{7}))$/,\\\"nb-NO\\\":/^(\\\\+?47)?[49]\\\\d{7}$/,\\\"nl-BE\\\":/^(\\\\+?32|0)4?\\\\d{8}$/,\\\"nn-NO\\\":/^(\\\\+?47)?[49]\\\\d{7}$/,\\\"pl-PL\\\":/^(\\\\+?48)? ?[5-8]\\\\d ?\\\\d{3} ?\\\\d{2} ?\\\\d{2}$/,\\\"pt-BR\\\":/^(\\\\+?55|0)\\\\-?[1-9]{2}\\\\-?[2-9]{1}\\\\d{3,4}\\\\-?\\\\d{4}$/,\\\"pt-PT\\\":/^(\\\\+?351)?9[1236]\\\\d{7}$/,\\\"ro-RO\\\":/^(\\\\+?4?0)\\\\s?7\\\\d{2}(\\\\/|\\\\s|\\\\.|\\\\-)?\\\\d{3}(\\\\s|\\\\.|\\\\-)?\\\\d{3}$/,\\\"ru-RU\\\":/^(\\\\+?7|8)?9\\\\d{9}$/,\\\"sk-SK\\\":/^(\\\\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,\\\"sr-RS\\\":/^(\\\\+3816|06)[- \\\\d]{5,9}$/,\\\"th-TH\\\":/^(\\\\+66|66|0)\\\\d{9}$/,\\\"tr-TR\\\":/^(\\\\+?90|0)?5\\\\d{9}$/,\\\"uk-UA\\\":/^(\\\\+?38|8)?0\\\\d{9}$/,\\\"vi-VN\\\":/^(\\\\+?84|0)?((1(2([0-9])|6([2-9])|88|99))|(9((?!5)[0-9])))([0-9]{7})$/,\\\"zh-CN\\\":/^(\\\\+?0?86\\\\-?)?1[3456789]\\\\d{9}$/,\\\"zh-TW\\\":/^(\\\\+?886\\\\-?|0)?9\\\\d{8}$/};ne[\\\"en-CA\\\"]=ne[\\\"en-US\\\"],ne[\\\"fr-BE\\\"]=ne[\\\"nl-BE\\\"],ne[\\\"zh-HK\\\"]=ne[\\\"en-HK\\\"];var ae={symbol:\\\"$\\\",require_symbol:!1,allow_space_after_symbol:!1,symbol_after_digits:!1,allow_negatives:!0,parens_for_negatives:!1,negative_sign_before_digits:!1,negative_sign_after_digits:!1,allow_negative_sign_placeholder:!1,thousands_separator:\\\",\\\",decimal_separator:\\\".\\\",allow_decimal:!0,require_decimal:!1,digits_after_decimal:[2],allow_space_after_digits:!1};var le=/^([\\\\+-]?\\\\d{4}(?!\\\\d{2}\\\\b))((-?)((0[1-9]|1[0-2])(\\\\3([12]\\\\d|0[1-9]|3[01]))?|W([0-4]\\\\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\\\\d|[12]\\\\d{2}|3([0-5]\\\\d|6[1-6])))([T\\\\s]((([01]\\\\d|2[0-3])((:?)[0-5]\\\\d)?|24:?00)([\\\\.,]\\\\d+(?!:))?)?(\\\\17[0-5]\\\\d([\\\\.,]\\\\d+)?)?([zZ]|([\\\\+-])([01]\\\\d|2[0-3]):?([0-5]\\\\d)?)?)?)?$/;var se=/([01][0-9]|2[0-3])/,ue=/[0-5][0-9]/,de=new RegExp(\\\"[-+]\\\"+se.source+\\\":\\\"+ue.source),ce=new RegExp(\\\"([zZ]|\\\"+de.source+\\\")\\\"),fe=new RegExp(se.source+\\\":\\\"+ue.source+\\\":\\\"+/([0-5][0-9]|60)/.source+/(\\\\.[0-9]+)?/.source),pe=new RegExp(/[0-9]{4}/.source+\\\"-\\\"+/(0[1-9]|1[0-2])/.source+\\\"-\\\"+/([12]\\\\d|0[1-9]|3[01])/.source),ge=new RegExp(\\\"\\\"+fe.source+ce.source),Ae=new RegExp(pe.source+\\\"[ tT]\\\"+ge.source);var he=[\\\"AD\\\",\\\"AE\\\",\\\"AF\\\",\\\"AG\\\",\\\"AI\\\",\\\"AL\\\",\\\"AM\\\",\\\"AO\\\",\\\"AQ\\\",\\\"AR\\\",\\\"AS\\\",\\\"AT\\\",\\\"AU\\\",\\\"AW\\\",\\\"AX\\\",\\\"AZ\\\",\\\"BA\\\",\\\"BB\\\",\\\"BD\\\",\\\"BE\\\",\\\"BF\\\",\\\"BG\\\",\\\"BH\\\",\\\"BI\\\",\\\"BJ\\\",\\\"BL\\\",\\\"BM\\\",\\\"BN\\\",\\\"BO\\\",\\\"BQ\\\",\\\"BR\\\",\\\"BS\\\",\\\"BT\\\",\\\"BV\\\",\\\"BW\\\",\\\"BY\\\",\\\"BZ\\\",\\\"CA\\\",\\\"CC\\\",\\\"CD\\\",\\\"CF\\\",\\\"CG\\\",\\\"CH\\\",\\\"CI\\\",\\\"CK\\\",\\\"CL\\\",\\\"CM\\\",\\\"CN\\\",\\\"CO\\\",\\\"CR\\\",\\\"CU\\\",\\\"CV\\\",\\\"CW\\\",\\\"CX\\\",\\\"CY\\\",\\\"CZ\\\",\\\"DE\\\",\\\"DJ\\\",\\\"DK\\\",\\\"DM\\\",\\\"DO\\\",\\\"DZ\\\",\\\"EC\\\",\\\"EE\\\",\\\"EG\\\",\\\"EH\\\",\\\"ER\\\",\\\"ES\\\",\\\"ET\\\",\\\"FI\\\",\\\"FJ\\\",\\\"FK\\\",\\\"FM\\\",\\\"FO\\\",\\\"FR\\\",\\\"GA\\\",\\\"GB\\\",\\\"GD\\\",\\\"GE\\\",\\\"GF\\\",\\\"GG\\\",\\\"GH\\\",\\\"GI\\\",\\\"GL\\\",\\\"GM\\\",\\\"GN\\\",\\\"GP\\\",\\\"GQ\\\",\\\"GR\\\",\\\"GS\\\",\\\"GT\\\",\\\"GU\\\",\\\"GW\\\",\\\"GY\\\",\\\"HK\\\",\\\"HM\\\",\\\"HN\\\",\\\"HR\\\",\\\"HT\\\",\\\"HU\\\",\\\"ID\\\",\\\"IE\\\",\\\"IL\\\",\\\"IM\\\",\\\"IN\\\",\\\"IO\\\",\\\"IQ\\\",\\\"IR\\\",\\\"IS\\\",\\\"IT\\\",\\\"JE\\\",\\\"JM\\\",\\\"JO\\\",\\\"JP\\\",\\\"KE\\\",\\\"KG\\\",\\\"KH\\\",\\\"KI\\\",\\\"KM\\\",\\\"KN\\\",\\\"KP\\\",\\\"KR\\\",\\\"KW\\\",\\\"KY\\\",\\\"KZ\\\",\\\"LA\\\",\\\"LB\\\",\\\"LC\\\",\\\"LI\\\",\\\"LK\\\",\\\"LR\\\",\\\"LS\\\",\\\"LT\\\",\\\"LU\\\",\\\"LV\\\",\\\"LY\\\",\\\"MA\\\",\\\"MC\\\",\\\"MD\\\",\\\"ME\\\",\\\"MF\\\",\\\"MG\\\",\\\"MH\\\",\\\"MK\\\",\\\"ML\\\",\\\"MM\\\",\\\"MN\\\",\\\"MO\\\",\\\"MP\\\",\\\"MQ\\\",\\\"MR\\\",\\\"MS\\\",\\\"MT\\\",\\\"MU\\\",\\\"MV\\\",\\\"MW\\\",\\\"MX\\\",\\\"MY\\\",\\\"MZ\\\",\\\"NA\\\",\\\"NC\\\",\\\"NE\\\",\\\"NF\\\",\\\"NG\\\",\\\"NI\\\",\\\"NL\\\",\\\"NO\\\",\\\"NP\\\",\\\"NR\\\",\\\"NU\\\",\\\"NZ\\\",\\\"OM\\\",\\\"PA\\\",\\\"PE\\\",\\\"PF\\\",\\\"PG\\\",\\\"PH\\\",\\\"PK\\\",\\\"PL\\\",\\\"PM\\\",\\\"PN\\\",\\\"PR\\\",\\\"PS\\\",\\\"PT\\\",\\\"PW\\\",\\\"PY\\\",\\\"QA\\\",\\\"RE\\\",\\\"RO\\\",\\\"RS\\\",\\\"RU\\\",\\\"RW\\\",\\\"SA\\\",\\\"SB\\\",\\\"SC\\\",\\\"SD\\\",\\\"SE\\\",\\\"SG\\\",\\\"SH\\\",\\\"SI\\\",\\\"SJ\\\",\\\"SK\\\",\\\"SL\\\",\\\"SM\\\",\\\"SN\\\",\\\"SO\\\",\\\"SR\\\",\\\"SS\\\",\\\"ST\\\",\\\"SV\\\",\\\"SX\\\",\\\"SY\\\",\\\"SZ\\\",\\\"TC\\\",\\\"TD\\\",\\\"TF\\\",\\\"TG\\\",\\\"TH\\\",\\\"TJ\\\",\\\"TK\\\",\\\"TL\\\",\\\"TM\\\",\\\"TN\\\",\\\"TO\\\",\\\"TR\\\",\\\"TT\\\",\\\"TV\\\",\\\"TW\\\",\\\"TZ\\\",\\\"UA\\\",\\\"UG\\\",\\\"UM\\\",\\\"US\\\",\\\"UY\\\",\\\"UZ\\\",\\\"VA\\\",\\\"VC\\\",\\\"VE\\\",\\\"VG\\\",\\\"VI\\\",\\\"VN\\\",\\\"VU\\\",\\\"WF\\\",\\\"WS\\\",\\\"YE\\\",\\\"YT\\\",\\\"ZA\\\",\\\"ZM\\\",\\\"ZW\\\"];var ve=[\\\"AFG\\\",\\\"ALA\\\",\\\"ALB\\\",\\\"DZA\\\",\\\"ASM\\\",\\\"AND\\\",\\\"AGO\\\",\\\"AIA\\\",\\\"ATA\\\",\\\"ATG\\\",\\\"ARG\\\",\\\"ARM\\\",\\\"ABW\\\",\\\"AUS\\\",\\\"AUT\\\",\\\"AZE\\\",\\\"BHS\\\",\\\"BHR\\\",\\\"BGD\\\",\\\"BRB\\\",\\\"BLR\\\",\\\"BEL\\\",\\\"BLZ\\\",\\\"BEN\\\",\\\"BMU\\\",\\\"BTN\\\",\\\"BOL\\\",\\\"BES\\\",\\\"BIH\\\",\\\"BWA\\\",\\\"BVT\\\",\\\"BRA\\\",\\\"IOT\\\",\\\"BRN\\\",\\\"BGR\\\",\\\"BFA\\\",\\\"BDI\\\",\\\"KHM\\\",\\\"CMR\\\",\\\"CAN\\\",\\\"CPV\\\",\\\"CYM\\\",\\\"CAF\\\",\\\"TCD\\\",\\\"CHL\\\",\\\"CHN\\\",\\\"CXR\\\",\\\"CCK\\\",\\\"COL\\\",\\\"COM\\\",\\\"COG\\\",\\\"COD\\\",\\\"COK\\\",\\\"CRI\\\",\\\"CIV\\\",\\\"HRV\\\",\\\"CUB\\\",\\\"CUW\\\",\\\"CYP\\\",\\\"CZE\\\",\\\"DNK\\\",\\\"DJI\\\",\\\"DMA\\\",\\\"DOM\\\",\\\"ECU\\\",\\\"EGY\\\",\\\"SLV\\\",\\\"GNQ\\\",\\\"ERI\\\",\\\"EST\\\",\\\"ETH\\\",\\\"FLK\\\",\\\"FRO\\\",\\\"FJI\\\",\\\"FIN\\\",\\\"FRA\\\",\\\"GUF\\\",\\\"PYF\\\",\\\"ATF\\\",\\\"GAB\\\",\\\"GMB\\\",\\\"GEO\\\",\\\"DEU\\\",\\\"GHA\\\",\\\"GIB\\\",\\\"GRC\\\",\\\"GRL\\\",\\\"GRD\\\",\\\"GLP\\\",\\\"GUM\\\",\\\"GTM\\\",\\\"GGY\\\",\\\"GIN\\\",\\\"GNB\\\",\\\"GUY\\\",\\\"HTI\\\",\\\"HMD\\\",\\\"VAT\\\",\\\"HND\\\",\\\"HKG\\\",\\\"HUN\\\",\\\"ISL\\\",\\\"IND\\\",\\\"IDN\\\",\\\"IRN\\\",\\\"IRQ\\\",\\\"IRL\\\",\\\"IMN\\\",\\\"ISR\\\",\\\"ITA\\\",\\\"JAM\\\",\\\"JPN\\\",\\\"JEY\\\",\\\"JOR\\\",\\\"KAZ\\\",\\\"KEN\\\",\\\"KIR\\\",\\\"PRK\\\",\\\"KOR\\\",\\\"KWT\\\",\\\"KGZ\\\",\\\"LAO\\\",\\\"LVA\\\",\\\"LBN\\\",\\\"LSO\\\",\\\"LBR\\\",\\\"LBY\\\",\\\"LIE\\\",\\\"LTU\\\",\\\"LUX\\\",\\\"MAC\\\",\\\"MKD\\\",\\\"MDG\\\",\\\"MWI\\\",\\\"MYS\\\",\\\"MDV\\\",\\\"MLI\\\",\\\"MLT\\\",\\\"MHL\\\",\\\"MTQ\\\",\\\"MRT\\\",\\\"MUS\\\",\\\"MYT\\\",\\\"MEX\\\",\\\"FSM\\\",\\\"MDA\\\",\\\"MCO\\\",\\\"MNG\\\",\\\"MNE\\\",\\\"MSR\\\",\\\"MAR\\\",\\\"MOZ\\\",\\\"MMR\\\",\\\"NAM\\\",\\\"NRU\\\",\\\"NPL\\\",\\\"NLD\\\",\\\"NCL\\\",\\\"NZL\\\",\\\"NIC\\\",\\\"NER\\\",\\\"NGA\\\",\\\"NIU\\\",\\\"NFK\\\",\\\"MNP\\\",\\\"NOR\\\",\\\"OMN\\\",\\\"PAK\\\",\\\"PLW\\\",\\\"PSE\\\",\\\"PAN\\\",\\\"PNG\\\",\\\"PRY\\\",\\\"PER\\\",\\\"PHL\\\",\\\"PCN\\\",\\\"POL\\\",\\\"PRT\\\",\\\"PRI\\\",\\\"QAT\\\",\\\"REU\\\",\\\"ROU\\\",\\\"RUS\\\",\\\"RWA\\\",\\\"BLM\\\",\\\"SHN\\\",\\\"KNA\\\",\\\"LCA\\\",\\\"MAF\\\",\\\"SPM\\\",\\\"VCT\\\",\\\"WSM\\\",\\\"SMR\\\",\\\"STP\\\",\\\"SAU\\\",\\\"SEN\\\",\\\"SRB\\\",\\\"SYC\\\",\\\"SLE\\\",\\\"SGP\\\",\\\"SXM\\\",\\\"SVK\\\",\\\"SVN\\\",\\\"SLB\\\",\\\"SOM\\\",\\\"ZAF\\\",\\\"SGS\\\",\\\"SSD\\\",\\\"ESP\\\",\\\"LKA\\\",\\\"SDN\\\",\\\"SUR\\\",\\\"SJM\\\",\\\"SWZ\\\",\\\"SWE\\\",\\\"CHE\\\",\\\"SYR\\\",\\\"TWN\\\",\\\"TJK\\\",\\\"TZA\\\",\\\"THA\\\",\\\"TLS\\\",\\\"TGO\\\",\\\"TKL\\\",\\\"TON\\\",\\\"TTO\\\",\\\"TUN\\\",\\\"TUR\\\",\\\"TKM\\\",\\\"TCA\\\",\\\"TUV\\\",\\\"UGA\\\",\\\"UKR\\\",\\\"ARE\\\",\\\"GBR\\\",\\\"USA\\\",\\\"UMI\\\",\\\"URY\\\",\\\"UZB\\\",\\\"VUT\\\",\\\"VEN\\\",\\\"VNM\\\",\\\"VGB\\\",\\\"VIR\\\",\\\"WLF\\\",\\\"ESH\\\",\\\"YEM\\\",\\\"ZMB\\\",\\\"ZWE\\\"];var me=/[^A-Z0-9+\\\\/=]/i;var _e=/^[a-z]+\\\\/[a-z0-9\\\\-\\\\+]+$/i,Fe=/^[a-z\\\\-]+=[a-z0-9\\\\-]+$/i,$e=/^[a-z0-9!\\\\$&'\\\\(\\\\)\\\\*\\\\+,;=\\\\-\\\\._~:@\\\\/\\\\?%\\\\s]*$/i;var Se=/^(application|audio|font|image|message|model|multipart|text|video)\\\\/[a-zA-Z0-9\\\\.\\\\-\\\\+]{1,100}$/i,Re=/^text\\\\/[a-zA-Z0-9\\\\.\\\\-\\\\+]{1,100};\\\\s?charset=(\\\"[a-zA-Z0-9\\\\.\\\\-\\\\+\\\\s]{0,70}\\\"|[a-zA-Z0-9\\\\.\\\\-\\\\+]{0,70})(\\\\s?\\\\([a-zA-Z0-9\\\\.\\\\-\\\\+\\\\s]{1,20}\\\\))?$/i,Ee=/^multipart\\\\/[a-zA-Z0-9\\\\.\\\\-\\\\+]{1,100}(;\\\\s?(boundary|charset)=(\\\"[a-zA-Z0-9\\\\.\\\\-\\\\+\\\\s]{0,70}\\\"|[a-zA-Z0-9\\\\.\\\\-\\\\+]{0,70})(\\\\s?\\\\([a-zA-Z0-9\\\\.\\\\-\\\\+\\\\s]{1,20}\\\\))?){0,2}$/i;var xe=/^\\\\(?[+-]?(90(\\\\.0+)?|[1-8]?\\\\d(\\\\.\\\\d+)?)$/,Me=/^\\\\s?[+-]?(180(\\\\.0+)?|1[0-7]\\\\d(\\\\.\\\\d+)?|\\\\d{1,2}(\\\\.\\\\d+)?)\\\\)?$/,Ce=/^\\\\d{4}$/,Ne=/^\\\\d{5}$/,we=/^\\\\d{6}$/,Te={AT:Ce,AU:Ce,BE:Ce,BG:Ce,CA:/^[ABCEGHJKLMNPRSTVXY]\\\\d[ABCEGHJ-NPRSTV-Z][\\\\s\\\\-]?\\\\d[ABCEGHJ-NPRSTV-Z]\\\\d$/i,CH:Ce,CZ:/^\\\\d{3}\\\\s?\\\\d{2}$/,DE:Ne,DK:Ce,DZ:Ne,ES:Ne,FI:Ne,FR:/^\\\\d{2}\\\\s?\\\\d{3}$/,GB:/^(gir\\\\s?0aa|[a-z]{1,2}\\\\d[\\\\da-z]?\\\\s?(\\\\d[a-z]{2})?)$/i,GR:/^\\\\d{3}\\\\s?\\\\d{2}$/,IL:Ne,IN:we,IS:/^\\\\d{3}$/,IT:Ne,JP:/^\\\\d{3}\\\\-\\\\d{4}$/,KE:Ne,LI:/^(948[5-9]|949[0-7])$/,MX:Ne,NL:/^\\\\d{4}\\\\s?[a-z]{2}$/i,NO:Ce,PL:/^\\\\d{2}\\\\-\\\\d{3}$/,PT:/^\\\\d{4}\\\\-\\\\d{3}?$/,RO:we,RU:we,SA:Ne,SE:/^\\\\d{3}\\\\s?\\\\d{2}$/,SK:/^\\\\d{3}\\\\s?\\\\d{2}$/,TW:/^\\\\d{3}(\\\\d{2})?$/,US:/^\\\\d{5}(-\\\\d{4})?$/,ZA:Ce,ZM:Ne};function Ze(e,t){f(e);var r=t?new RegExp(\\\"^[\\\"+t+\\\"]+\\\",\\\"g\\\"):/^\\\\s+/g;return e.replace(r,\\\"\\\")}function Be(e,t){f(e);for(var r=t?new RegExp(\\\"[\\\"+t+\\\"]\\\"):/\\\\s/,o=e.length-1;0<=o&&r.test(e[o]);)o--;return o<e.length?e.substr(0,o+1):e}function Ie(e,t){return f(e),e.replace(new RegExp(\\\"[\\\"+t+\\\"]+\\\",\\\"g\\\"),\\\"\\\")}var Le={all_lowercase:!0,gmail_lowercase:!0,gmail_remove_dots:!0,gmail_remove_subaddress:!0,gmail_convert_googlemaildotcom:!0,outlookdotcom_lowercase:!0,outlookdotcom_remove_subaddress:!0,yahoo_lowercase:!0,yahoo_remove_subaddress:!0,yandex_lowercase:!0,icloud_lowercase:!0,icloud_remove_subaddress:!0},ye=[\\\"icloud.com\\\",\\\"me.com\\\"],Ge=[\\\"hotmail.at\\\",\\\"hotmail.be\\\",\\\"hotmail.ca\\\",\\\"hotmail.cl\\\",\\\"hotmail.co.il\\\",\\\"hotmail.co.nz\\\",\\\"hotmail.co.th\\\",\\\"hotmail.co.uk\\\",\\\"hotmail.com\\\",\\\"hotmail.com.ar\\\",\\\"hotmail.com.au\\\",\\\"hotmail.com.br\\\",\\\"hotmail.com.gr\\\",\\\"hotmail.com.mx\\\",\\\"hotmail.com.pe\\\",\\\"hotmail.com.tr\\\",\\\"hotmail.com.vn\\\",\\\"hotmail.cz\\\",\\\"hotmail.de\\\",\\\"hotmail.dk\\\",\\\"hotmail.es\\\",\\\"hotmail.fr\\\",\\\"hotmail.hu\\\",\\\"hotmail.id\\\",\\\"hotmail.ie\\\",\\\"hotmail.in\\\",\\\"hotmail.it\\\",\\\"hotmail.jp\\\",\\\"hotmail.kr\\\",\\\"hotmail.lv\\\",\\\"hotmail.my\\\",\\\"hotmail.ph\\\",\\\"hotmail.pt\\\",\\\"hotmail.sa\\\",\\\"hotmail.sg\\\",\\\"hotmail.sk\\\",\\\"live.be\\\",\\\"live.co.uk\\\",\\\"live.com\\\",\\\"live.com.ar\\\",\\\"live.com.mx\\\",\\\"live.de\\\",\\\"live.es\\\",\\\"live.eu\\\",\\\"live.fr\\\",\\\"live.it\\\",\\\"live.nl\\\",\\\"msn.com\\\",\\\"outlook.at\\\",\\\"outlook.be\\\",\\\"outlook.cl\\\",\\\"outlook.co.il\\\",\\\"outlook.co.nz\\\",\\\"outlook.co.th\\\",\\\"outlook.com\\\",\\\"outlook.com.ar\\\",\\\"outlook.com.au\\\",\\\"outlook.com.br\\\",\\\"outlook.com.gr\\\",\\\"outlook.com.pe\\\",\\\"outlook.com.tr\\\",\\\"outlook.com.vn\\\",\\\"outlook.cz\\\",\\\"outlook.de\\\",\\\"outlook.dk\\\",\\\"outlook.es\\\",\\\"outlook.fr\\\",\\\"outlook.hu\\\",\\\"outlook.id\\\",\\\"outlook.ie\\\",\\\"outlook.in\\\",\\\"outlook.it\\\",\\\"outlook.jp\\\",\\\"outlook.kr\\\",\\\"outlook.lv\\\",\\\"outlook.my\\\",\\\"outlook.ph\\\",\\\"outlook.pt\\\",\\\"outlook.sa\\\",\\\"outlook.sg\\\",\\\"outlook.sk\\\",\\\"passport.com\\\"],De=[\\\"rocketmail.com\\\",\\\"yahoo.ca\\\",\\\"yahoo.co.uk\\\",\\\"yahoo.com\\\",\\\"yahoo.de\\\",\\\"yahoo.fr\\\",\\\"yahoo.in\\\",\\\"yahoo.it\\\",\\\"ymail.com\\\"],Oe=[\\\"yandex.ru\\\",\\\"yandex.ua\\\",\\\"yandex.kz\\\",\\\"yandex.com\\\",\\\"yandex.by\\\",\\\"ya.ru\\\"];function Ue(e){return 1<e.length?e:\\\"\\\"}return{version:\\\"10.1.0\\\",toDate:i,toFloat:r,toInt:function(e,t){return f(e),parseInt(e,t||10)},toBoolean:function(e,t){return f(e),t?\\\"1\\\"===e||\\\"true\\\"===e:\\\"0\\\"!==e&&\\\"false\\\"!==e&&\\\"\\\"!==e},equals:function(e,t){return f(e),e===t},contains:function(e,t){return f(e),0<=e.indexOf(n(t))},matches:function(e,t,r){return f(e),\\\"[object RegExp]\\\"!==Object.prototype.toString.call(t)&&(t=new RegExp(t,r)),t.test(e)},isEmail:function(e,t){if(f(e),(t=c(t,g)).require_display_name||t.allow_display_name){var r=e.match(A);if(r)e=r[1];else if(t.require_display_name)return!1}var o=e.split(\\\"@\\\"),i=o.pop(),n=o.join(\\\"@\\\"),a=i.toLowerCase();if(\\\"gmail.com\\\"!==a&&\\\"googlemail.com\\\"!==a||(n=n.toLowerCase()),!d(n,{max:64})||!d(i,{max:254}))return!1;if(!p(i,{require_tld:t.require_tld}))return!1;if('\\\"'===n[0])return n=n.slice(1,n.length-1),t.allow_utf8_local_part?_.test(n):v.test(n);for(var l=t.allow_utf8_local_part?m:h,s=n.split(\\\".\\\"),u=0;u<s.length;u++)if(!l.test(s[u]))return!1;return!0},isURL:function(e,t){if(f(e),!e||2083<=e.length||/[\\\\s<>]/.test(e))return!1;if(0===e.indexOf(\\\"mailto:\\\"))return!1;t=c(t,$);var r=void 0,o=void 0,i=void 0,n=void 0,a=void 0,l=void 0,s=void 0,u=void 0;if(1<(s=(e=(s=(e=(s=e.split(\\\"#\\\")).shift()).split(\\\"?\\\")).shift()).split(\\\"://\\\")).length){if(r=s.shift(),t.require_valid_protocol&&-1===t.protocols.indexOf(r))return!1}else{if(t.require_protocol)return!1;t.allow_protocol_relative_urls&&\\\"//\\\"===e.substr(0,2)&&(s[0]=e.substr(2))}if(\\\"\\\"===(e=s.join(\\\"://\\\")))return!1;if(\\\"\\\"===(e=(s=e.split(\\\"/\\\")).shift())&&!t.require_host)return!0;if(1<(s=e.split(\\\"@\\\")).length&&0<=(o=s.shift()).indexOf(\\\":\\\")&&2<o.split(\\\":\\\").length)return!1;u=l=null;var d=(n=s.join(\\\"@\\\")).match(S);return d?(i=\\\"\\\",u=d[1],l=d[2]||null):(i=(s=n.split(\\\":\\\")).shift(),s.length&&(l=s.join(\\\":\\\"))),!(null!==l&&(a=parseInt(l,10),!/^[0-9]+$/.test(l)||a<=0||65535<a)||!(F(i)||p(i,t)||u&&F(u,6))||(i=i||u,t.host_whitelist&&!R(i,t.host_whitelist)||t.host_blacklist&&R(i,t.host_blacklist)))},isMACAddress:function(e){return f(e),t.test(e)},isIP:F,isFQDN:p,isBoolean:function(e){return f(e),0<=[\\\"true\\\",\\\"false\\\",\\\"1\\\",\\\"0\\\"].indexOf(e)},isAlpha:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:\\\"en-US\\\";if(f(e),t in o)return o[t].test(e);throw new Error(\\\"Invalid locale '\\\"+t+\\\"'\\\")},isAlphanumeric:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:\\\"en-US\\\";if(f(e),t in E)return E[t].test(e);throw new Error(\\\"Invalid locale '\\\"+t+\\\"'\\\")},isNumeric:function(e){return f(e),y.test(e)},isPort:function(e){return O(e,{min:0,max:65535})},isLowercase:function(e){return f(e),e===e.toLowerCase()},isUppercase:function(e){return f(e),e===e.toUpperCase()},isAscii:function(e){return f(e),U.test(e)},isFullWidth:function(e){return f(e),b.test(e)},isHalfWidth:function(e){return f(e),P.test(e)},isVariableWidth:function(e){return f(e),b.test(e)&&P.test(e)},isMultibyte:function(e){return f(e),K.test(e)},isSurrogatePair:function(e){return f(e),k.test(e)},isInt:O,isFloat:function(e,t){f(e),t=t||{};var r=new RegExp(\\\"^(?:[-+])?(?:[0-9]+)?(?:\\\\\\\\\\\"+(t.locale?x[t.locale]:\\\".\\\")+\\\"[0-9]*)?(?:[eE][\\\\\\\\+\\\\\\\\-]?(?:[0-9]+))?$\\\");if(\\\"\\\"===e||\\\".\\\"===e||\\\"-\\\"===e||\\\"+\\\"===e)return!1;var o=parseFloat(e.replace(\\\",\\\",\\\".\\\"));return r.test(e)&&(!t.hasOwnProperty(\\\"min\\\")||o>=t.min)&&(!t.hasOwnProperty(\\\"max\\\")||o<=t.max)&&(!t.hasOwnProperty(\\\"lt\\\")||o<t.lt)&&(!t.hasOwnProperty(\\\"gt\\\")||o>t.gt)},isDecimal:function(e,t){if(f(e),(t=c(t,H)).locale in x)return!z.includes(e.replace(/ /g,\\\"\\\"))&&(r=t,new RegExp(\\\"^[-+]?([0-9]+)?(\\\\\\\\\\\"+x[r.locale]+\\\"[0-9]{\\\"+r.decimal_digits+\\\"})\\\"+(r.force_decimal?\\\"\\\":\\\"?\\\")+\\\"$\\\")).test(e);var r;throw new Error(\\\"Invalid locale '\\\"+t.locale+\\\"'\\\")},isHexadecimal:W,isDivisibleBy:function(e,t){return f(e),r(e)%parseInt(t,10)==0},isHexColor:function(e){return f(e),Y.test(e)},isISRC:function(e){return f(e),j.test(e)},isMD5:function(e){return f(e),J.test(e)},isHash:function(e,t){return f(e),new RegExp(\\\"^[a-f0-9]{\\\"+q[t]+\\\"}$\\\").test(e)},isJSON:function(e){f(e);try{var t=JSON.parse(e);return!!t&&\\\"object\\\"===(void 0===t?\\\"undefined\\\":a(t))}catch(e){}return!1},isEmpty:function(e){return f(e),0===e.length},isLength:function(e,t){f(e);var r=void 0,o=void 0;\\\"object\\\"===(void 0===t?\\\"undefined\\\":a(t))?(r=t.min||0,o=t.max):(r=t,o=arguments[2]);var i=e.match(/[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]/g)||[],n=e.length-i.length;return r<=n&&(void 0===o||n<=o)},isByteLength:d,isUUID:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:\\\"all\\\";f(e);var r=Q[t];return r&&r.test(e)},isMongoId:function(e){return f(e),W(e)&&24===e.length},isAfter:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:String(new Date);f(e);var r=i(t),o=i(e);return!!(o&&r&&r<o)},isBefore:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:String(new Date);f(e);var r=i(t),o=i(e);return!!(o&&r&&o<r)},isIn:function(e,t){f(e);var r=void 0;if(\\\"[object Array]\\\"===Object.prototype.toString.call(t)){var o=[];for(r in t)({}).hasOwnProperty.call(t,r)&&(o[r]=n(t[r]));return 0<=o.indexOf(e)}return\\\"object\\\"===(void 0===t?\\\"undefined\\\":a(t))?t.hasOwnProperty(e):!(!t||\\\"function\\\"!=typeof t.indexOf)&&0<=t.indexOf(e)},isCreditCard:function(e){f(e);var t=e.replace(/[- ]+/g,\\\"\\\");if(!X.test(t))return!1;for(var r=0,o=void 0,i=void 0,n=void 0,a=t.length-1;0<=a;a--)o=t.substring(a,a+1),i=parseInt(o,10),r+=n&&10<=(i*=2)?i%10+1:i,n=!n;return!(r%10!=0||!t)},isISIN:function(e){if(f(e),!ee.test(e))return!1;for(var t=e.replace(/[A-Z]/g,function(e){return parseInt(e,36)}),r=0,o=void 0,i=void 0,n=!0,a=t.length-2;0<=a;a--)o=t.substring(a,a+1),i=parseInt(o,10),r+=n&&10<=(i*=2)?i+1:i,n=!n;return parseInt(e.substr(e.length-1),10)===(1e4-r)%10},isISBN:function e(t){var r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:\\\"\\\";if(f(t),!(r=String(r)))return e(t,10)||e(t,13);var o=t.replace(/[\\\\s-]+/g,\\\"\\\"),i=0,n=void 0;if(\\\"10\\\"===r){if(!te.test(o))return!1;for(n=0;n<9;n++)i+=(n+1)*o.charAt(n);if(\\\"X\\\"===o.charAt(9)?i+=100:i+=10*o.charAt(9),i%11==0)return!!o}else if(\\\"13\\\"===r){if(!re.test(o))return!1;for(n=0;n<12;n++)i+=oe[n%2]*o.charAt(n);if(o.charAt(12)-(10-i%10)%10==0)return!!o}return!1},isISSN:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};f(e);var r=ie;if(r=t.require_hyphen?r.replace(\\\"?\\\",\\\"\\\"):r,!(r=t.case_sensitive?new RegExp(r):new RegExp(r,\\\"i\\\")).test(e))return!1;var o=e.replace(\\\"-\\\",\\\"\\\"),i=8,n=0,a=!0,l=!1,s=void 0;try{for(var u,d=o[Symbol.iterator]();!(a=(u=d.next()).done);a=!0){var c=u.value;n+=(\\\"X\\\"===c.toUpperCase()?10:+c)*i,--i}}catch(e){l=!0,s=e}finally{try{!a&&d.return&&d.return()}finally{if(l)throw s}}return n%11==0},isMobilePhone:function(e,t,r){if(f(e),r&&r.strictMode&&!e.startsWith(\\\"+\\\"))return!1;if(t in ne)return ne[t].test(e);if(\\\"any\\\"===t){for(var o in ne)if(ne.hasOwnProperty(o)&&ne[o].test(e))return!0;return!1}throw new Error(\\\"Invalid locale '\\\"+t+\\\"'\\\")},isPostalCode:function(e,t){if(f(e),t in Te)return Te[t].test(e);if(\\\"any\\\"===t){for(var r in Te)if(Te.hasOwnProperty(r)&&Te[r].test(e))return!0;return!1}throw new Error(\\\"Invalid locale '\\\"+t+\\\"'\\\")},isCurrency:function(e,t){return f(e),function(e){var r=\\\"\\\\\\\\d{\\\"+e.digits_after_decimal[0]+\\\"}\\\";e.digits_after_decimal.forEach(function(e,t){0!==t&&(r=r+\\\"|\\\\\\\\d{\\\"+e+\\\"}\\\")});var t=\\\"(\\\\\\\\\\\"+e.symbol.replace(/\\\\./g,\\\"\\\\\\\\.\\\")+\\\")\\\"+(e.require_symbol?\\\"\\\":\\\"?\\\"),o=\\\"(\\\"+[\\\"0\\\",\\\"[1-9]\\\\\\\\d*\\\",\\\"[1-9]\\\\\\\\d{0,2}(\\\\\\\\\\\"+e.thousands_separator+\\\"\\\\\\\\d{3})*\\\"].join(\\\"|\\\")+\\\")?\\\",i=\\\"(\\\\\\\\\\\"+e.decimal_separator+\\\"(\\\"+r+\\\"))\\\"+(e.require_decimal?\\\"\\\":\\\"?\\\"),n=o+(e.allow_decimal||e.require_decimal?i:\\\"\\\");return e.allow_negatives&&!e.parens_for_negatives&&(e.negative_sign_after_digits?n+=\\\"-?\\\":e.negative_sign_before_digits&&(n=\\\"-?\\\"+n)),e.allow_negative_sign_placeholder?n=\\\"( (?!\\\\\\\\-))?\\\"+n:e.allow_space_after_symbol?n=\\\" ?\\\"+n:e.allow_space_after_digits&&(n+=\\\"( (?!$))?\\\"),e.symbol_after_digits?n+=t:n=t+n,e.allow_negatives&&(e.parens_for_negatives?n=\\\"(\\\\\\\\(\\\"+n+\\\"\\\\\\\\)|\\\"+n+\\\")\\\":e.negative_sign_before_digits||e.negative_sign_after_digits||(n=\\\"-?\\\"+n)),new RegExp(\\\"^(?!-? )(?=.*\\\\\\\\d)\\\"+n+\\\"$\\\")}(t=c(t,ae)).test(e)},isISO8601:function(e){return f(e),le.test(e)},isRFC3339:function(e){return f(e),Ae.test(e)},isISO31661Alpha2:function(e){return f(e),he.includes(e.toUpperCase())},isISO31661Alpha3:function(e){return f(e),ve.includes(e.toUpperCase())},isBase64:function(e){f(e);var t=e.length;if(!t||t%4!=0||me.test(e))return!1;var r=e.indexOf(\\\"=\\\");return-1===r||r===t-1||r===t-2&&\\\"=\\\"===e[t-1]},isDataURI:function(e){f(e);var t=e.split(\\\",\\\");if(t.length<2)return!1;var r=t.shift().trim().split(\\\";\\\"),o=r.shift();if(\\\"data:\\\"!==o.substr(0,5))return!1;var i=o.substr(5);if(\\\"\\\"!==i&&!_e.test(i))return!1;for(var n=0;n<r.length;n++)if(n===r.length-1&&\\\"base64\\\"===r[n].toLowerCase());else if(!Fe.test(r[n]))return!1;for(var a=0;a<t.length;a++)if(!$e.test(t[a]))return!1;return!0},isMimeType:function(e){return f(e),Se.test(e)||Re.test(e)||Ee.test(e)},isLatLong:function(e){if(f(e),!e.includes(\\\",\\\"))return!1;var t=e.split(\\\",\\\");return xe.test(t[0])&&Me.test(t[1])},ltrim:Ze,rtrim:Be,trim:function(e,t){return Be(Ze(e,t),t)},escape:function(e){return f(e),e.replace(/&/g,\\\"&amp;\\\").replace(/\\\"/g,\\\"&quot;\\\").replace(/'/g,\\\"&#x27;\\\").replace(/</g,\\\"&lt;\\\").replace(/>/g,\\\"&gt;\\\").replace(/\\\\//g,\\\"&#x2F;\\\").replace(/\\\\\\\\/g,\\\"&#x5C;\\\").replace(/`/g,\\\"&#96;\\\")},unescape:function(e){return f(e),e.replace(/&amp;/g,\\\"&\\\").replace(/&quot;/g,'\\\"').replace(/&#x27;/g,\\\"'\\\").replace(/&lt;/g,\\\"<\\\").replace(/&gt;/g,\\\">\\\").replace(/&#x2F;/g,\\\"/\\\").replace(/&#x5C;/g,\\\"\\\\\\\\\\\").replace(/&#96;/g,\\\"`\\\")},stripLow:function(e,t){return f(e),Ie(e,t?\\\"\\\\\\\\x00-\\\\\\\\x09\\\\\\\\x0B\\\\\\\\x0C\\\\\\\\x0E-\\\\\\\\x1F\\\\\\\\x7F\\\":\\\"\\\\\\\\x00-\\\\\\\\x1F\\\\\\\\x7F\\\")},whitelist:function(e,t){return f(e),e.replace(new RegExp(\\\"[^\\\"+t+\\\"]+\\\",\\\"g\\\"),\\\"\\\")},blacklist:Ie,isWhitelisted:function(e,t){f(e);for(var r=e.length-1;0<=r;r--)if(-1===t.indexOf(e[r]))return!1;return!0},normalizeEmail:function(e,t){t=c(t,Le);var r=e.split(\\\"@\\\"),o=r.pop(),i=[r.join(\\\"@\\\"),o];if(i[1]=i[1].toLowerCase(),\\\"gmail.com\\\"===i[1]||\\\"googlemail.com\\\"===i[1]){if(t.gmail_remove_subaddress&&(i[0]=i[0].split(\\\"+\\\")[0]),t.gmail_remove_dots&&(i[0]=i[0].replace(/\\\\.+/g,Ue)),!i[0].length)return!1;(t.all_lowercase||t.gmail_lowercase)&&(i[0]=i[0].toLowerCase()),i[1]=t.gmail_convert_googlemaildotcom?\\\"gmail.com\\\":i[1]}else if(~ye.indexOf(i[1])){if(t.icloud_remove_subaddress&&(i[0]=i[0].split(\\\"+\\\")[0]),!i[0].length)return!1;(t.all_lowercase||t.icloud_lowercase)&&(i[0]=i[0].toLowerCase())}else if(~Ge.indexOf(i[1])){if(t.outlookdotcom_remove_subaddress&&(i[0]=i[0].split(\\\"+\\\")[0]),!i[0].length)return!1;(t.all_lowercase||t.outlookdotcom_lowercase)&&(i[0]=i[0].toLowerCase())}else if(~De.indexOf(i[1])){if(t.yahoo_remove_subaddress){var n=i[0].split(\\\"-\\\");i[0]=1<n.length?n.slice(0,-1).join(\\\"-\\\"):n[0]}if(!i[0].length)return!1;(t.all_lowercase||t.yahoo_lowercase)&&(i[0]=i[0].toLowerCase())}else~Oe.indexOf(i[1])?((t.all_lowercase||t.yandex_lowercase)&&(i[0]=i[0].toLowerCase()),i[1]=\\\"yandex.ru\\\"):t.all_lowercase&&(i[0]=i[0].toLowerCase());return i.join(\\\"@\\\")},toString:n}});\""
		},
		{
			"name": "DeviceDetector.js",
			"source": "\"//  Device Detector.\\r\\n\\r\\n    isMobile = ( function () {\\r\\n        var ua = navigator.userAgent,\\r\\n            apple_phone      = /iPhone/i,\\r\\n            apple_ipod       = /iPod/i,\\r\\n            apple_tablet     = /iPad/i,\\r\\n            android_phone    = /(?=.*\\\\bAndroid\\\\b)(?=.*\\\\bMobile\\\\b)/i, // Match 'Android' AND 'Mobile'\\r\\n            android_tablet   = /Android/i,\\r\\n            windows_phone    = /IEMobile/i,\\r\\n            windows_tablet   = /(?=.*\\\\bWindows\\\\b)(?=.*\\\\bARM\\\\b)/i, // Match 'Windows' AND 'ARM'\\r\\n            other_blackberry = /BlackBerry/i,\\r\\n            other_opera      = /Opera Mini/i,\\r\\n            other_firefox    = /(?=.*\\\\bFirefox\\\\b)(?=.*\\\\bMobile\\\\b)/i; // Match 'Firefox' AND 'Mobile'\\r\\n\\r\\n        if (\\r\\n\\t\\t\\tapple_phone.test( ua )      ||\\r\\n\\t\\t\\tapple_phone.test( ua )      ||\\r\\n\\t\\t\\tapple_ipod.test( ua )       ||\\r\\n\\t\\t\\tapple_tablet.test( ua )     ||\\r\\n\\t\\t\\tandroid_phone.test( ua )    ||\\r\\n\\t\\t\\tandroid_tablet.test( ua )   ||\\r\\n\\t\\t\\twindows_phone.test( ua )    ||\\r\\n\\t\\t\\twindows_tablet.test( ua )   ||\\r\\n\\t\\t\\tother_blackberry.test( ua ) ||\\r\\n\\t\\t\\tother_opera.test( ua )      ||\\r\\n\\t\\t\\tother_firefox.test( ua )\\r\\n        ){\\r\\n\\r\\n            return true;\\r\\n\\r\\n        } else {\\r\\n\\r\\n            return false;\\r\\n\\r\\n        }\\r\\n    })();\\r\\n\""
		},
		{
			"name": "MathDecimalAdjustment.js",
			"source": "\"// MathDecimalAdjustment.js\\r\\n// Closure\\r\\n(function() {\\r\\n  /**\\r\\n   * Decimal adjustment of a number.\\r\\n   *\\r\\n   * @param {String}  type  The type of adjustment.\\r\\n   * @param {Number}  value The number.\\r\\n   * @param {Integer} exp   The exponent (the 10 logarithm of the adjustment base).\\r\\n   * @returns {Number} The adjusted value.\\r\\n   */\\r\\n  function decimalAdjust(type, value, exp) {\\r\\n    // If the exp is undefined or zero...\\r\\n    if (typeof exp === 'undefined' || +exp === 0) {\\r\\n      return Math[type](value);\\r\\n    }\\r\\n    value = +value;\\r\\n    exp = +exp;\\r\\n    // If the value is not a number or the exp is not an integer...\\r\\n    if (value === null || isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {\\r\\n      return NaN;\\r\\n    }\\r\\n    // Shift\\r\\n    value = value.toString().split('e');\\r\\n    value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));\\r\\n    // Shift back\\r\\n    value = value.toString().split('e');\\r\\n    return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));\\r\\n  }\\r\\n\\r\\n  // Decimal round\\r\\n  if (!Math.round10) {\\r\\n    Math.round10 = function(value, exp) {\\r\\n      return decimalAdjust('round', value, exp);\\r\\n    };\\r\\n  }\\r\\n  // Decimal floor\\r\\n  if (!Math.floor10) {\\r\\n    Math.floor10 = function(value, exp) {\\r\\n      return decimalAdjust('floor', value, exp);\\r\\n    };\\r\\n  }\\r\\n  // Decimal ceil\\r\\n  if (!Math.ceil10) {\\r\\n    Math.ceil10 = function(value, exp) {\\r\\n      return decimalAdjust('ceil', value, exp);\\r\\n    };\\r\\n  }\\r\\n})();\\r\\n/*\\r\\n//  Round\\r\\n    Math.round10(55.55, -1);   // 55.6\\r\\n    Math.round10(55.549, -1);  // 55.5\\r\\n    Math.round10(55, 1);       // 60\\r\\n    Math.round10(54.9, 1);     // 50\\r\\n    Math.round10(-55.55, -1);  // -55.5 -- round works towards +8 when in-between two values\\r\\n    Math.round10(-55.551, -1); // -55.6\\r\\n    Math.round10(-55, 1);      // -50 -- round works towards +8 when in-between two values\\r\\n    Math.round10(-55.1, 1);    // -60\\r\\n    Math.round10(1.005, -2);   // 1.01 -- compare this with Math.round(1.005*100)/100 above\\r\\n    Math.round10(-1.005, -2);  // -1.0 -- round works towards +8 when exactly in-between two values\\r\\n    // Floor\\r\\n    Math.floor10(55.59, -1);   // 55.5\\r\\n    Math.floor10(59, 1);       // 50\\r\\n    Math.floor10(-55.51, -1);  // -55.6 -- floor is always lower than or equal to floored number: -55.6 < -55.51\\r\\n    Math.floor10(-51, 1);      // -60 -- ditto\\r\\n    // Ceil\\r\\n    Math.ceil10(55.51, -1);    // 55.6\\r\\n    Math.ceil10(51, 1);        // 60\\r\\n    Math.ceil10(-55.59, -1);   // -55.5 -- ceil is always equal or above ceiled number: -55.5 > -55.59\\r\\n    Math.ceil10(-59, 1);       // -59 -- ditto\\r\\n*/\\r\\n\""
		},
		{
			"name": "socketcluster.js",
			"source": "\"/**\\r\\n * SocketCluster JavaScript client v14.2.2\\r\\n */\\r\\n(function(f){if(typeof exports===\\\"object\\\"&&typeof module!==\\\"undefined\\\"){module.exports=f()}else if(typeof define===\\\"function\\\"&&define.amd){define([],f)}else{var g;if(typeof window!==\\\"undefined\\\"){g=window}else if(typeof global!==\\\"undefined\\\"){g=global}else if(typeof self!==\\\"undefined\\\"){g=self}else{g=this}g.socketCluster = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\\\"function\\\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\\\"Cannot find module '\\\"+i+\\\"'\\\");throw a.code=\\\"MODULE_NOT_FOUND\\\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\\\"function\\\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(_dereq_,module,exports){\\r\\nvar SCClientSocket = _dereq_('./lib/scclientsocket');\\r\\nvar factory = _dereq_('./lib/factory');\\r\\n\\r\\nmodule.exports.factory = factory;\\r\\nmodule.exports.SCClientSocket = SCClientSocket;\\r\\n\\r\\nmodule.exports.Emitter = _dereq_('component-emitter');\\r\\n\\r\\nmodule.exports.create = function (options) {\\r\\n  return factory.create(options);\\r\\n};\\r\\n\\r\\nmodule.exports.connect = module.exports.create;\\r\\n\\r\\nmodule.exports.destroy = function (socket) {\\r\\n  return factory.destroy(socket);\\r\\n};\\r\\n\\r\\nmodule.exports.clients = factory.clients;\\r\\n\\r\\nmodule.exports.version = '14.2.2';\\r\\n\\r\\n},{\\\"./lib/factory\\\":3,\\\"./lib/scclientsocket\\\":5,\\\"component-emitter\\\":11}],2:[function(_dereq_,module,exports){\\r\\n(function (global){\\r\\nvar AuthEngine = function () {\\r\\n  this._internalStorage = {};\\r\\n  this.isLocalStorageEnabled = this._checkLocalStorageEnabled();\\r\\n};\\r\\n\\r\\nAuthEngine.prototype._checkLocalStorageEnabled = function () {\\r\\n  var err;\\r\\n  try {\\r\\n    // Some browsers will throw an error here if localStorage is disabled.\\r\\n    global.localStorage;\\r\\n\\r\\n    // Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem\\r\\n    // throw QuotaExceededError. We're going to detect this and avoid hard to debug edge cases.\\r\\n    global.localStorage.setItem('__scLocalStorageTest', 1);\\r\\n    global.localStorage.removeItem('__scLocalStorageTest');\\r\\n  } catch (e) {\\r\\n    err = e;\\r\\n  }\\r\\n  return !err;\\r\\n};\\r\\n\\r\\nAuthEngine.prototype.saveToken = function (name, token, options, callback) {\\r\\n  if (this.isLocalStorageEnabled && global.localStorage) {\\r\\n    global.localStorage.setItem(name, token);\\r\\n  } else {\\r\\n    this._internalStorage[name] = token;\\r\\n  }\\r\\n  callback && callback(null, token);\\r\\n};\\r\\n\\r\\nAuthEngine.prototype.removeToken = function (name, callback) {\\r\\n  var token;\\r\\n\\r\\n  this.loadToken(name, function (err, authToken) {\\r\\n    token = authToken;\\r\\n  });\\r\\n\\r\\n  if (this.isLocalStorageEnabled && global.localStorage) {\\r\\n    global.localStorage.removeItem(name);\\r\\n  } else {\\r\\n    delete this._internalStorage[name];\\r\\n  }\\r\\n\\r\\n  callback && callback(null, token);\\r\\n};\\r\\n\\r\\nAuthEngine.prototype.loadToken = function (name, callback) {\\r\\n  var token;\\r\\n\\r\\n  if (this.isLocalStorageEnabled && global.localStorage) {\\r\\n    token = global.localStorage.getItem(name);\\r\\n  } else {\\r\\n    token = this._internalStorage[name] || null;\\r\\n  }\\r\\n  callback(null, token);\\r\\n};\\r\\n\\r\\nmodule.exports.AuthEngine = AuthEngine;\\r\\n\\r\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n},{}],3:[function(_dereq_,module,exports){\\r\\n(function (global){\\r\\nvar SCClientSocket = _dereq_('./scclientsocket');\\r\\nvar scErrors = _dereq_('sc-errors');\\r\\nvar uuid = _dereq_('uuid');\\r\\nvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\\r\\n\\r\\nvar _clients = {};\\r\\n\\r\\nfunction getMultiplexId(options) {\\r\\n  var protocolPrefix = options.secure ? 'https://' : 'http://';\\r\\n  var queryString = '';\\r\\n  if (options.query) {\\r\\n    if (typeof options.query === 'string') {\\r\\n      queryString = options.query;\\r\\n    } else {\\r\\n      var queryArray = [];\\r\\n      var queryMap = options.query;\\r\\n      for (var key in queryMap) {\\r\\n        if (queryMap.hasOwnProperty(key)) {\\r\\n          queryArray.push(key + '=' + queryMap[key]);\\r\\n        }\\r\\n      }\\r\\n      if (queryArray.length) {\\r\\n        queryString = '?' + queryArray.join('&');\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  var host;\\r\\n  if (options.host) {\\r\\n    host = options.host;\\r\\n  } else {\\r\\n    host = options.hostname + ':' + options.port;\\r\\n  }\\r\\n  return protocolPrefix + host + options.path + queryString;\\r\\n}\\r\\n\\r\\nfunction isUrlSecure() {\\r\\n  return global.location && location.protocol === 'https:';\\r\\n}\\r\\n\\r\\nfunction getPort(options, isSecureDefault) {\\r\\n  var isSecure = options.secure == null ? isSecureDefault : options.secure;\\r\\n  return options.port || (global.location && location.port ? location.port : isSecure ? 443 : 80);\\r\\n}\\r\\n\\r\\nfunction create(options) {\\r\\n  var self = this;\\r\\n\\r\\n  options = options || {};\\r\\n\\r\\n  if (options.host && !options.host.match(/[^:]+:\\\\d{2,5}/)) {\\r\\n    throw new InvalidArgumentsError('The host option should include both' +\\r\\n      ' the hostname and the port number in the format \\\"hostname:port\\\"');\\r\\n  }\\r\\n\\r\\n  if (options.host && options.hostname) {\\r\\n    throw new InvalidArgumentsError('The host option should already include' +\\r\\n      ' the hostname and the port number in the format \\\"hostname:port\\\"' +\\r\\n      ' - Because of this, you should never use host and hostname options together');\\r\\n  }\\r\\n\\r\\n  if (options.host && options.port) {\\r\\n    throw new InvalidArgumentsError('The host option should already include' +\\r\\n      ' the hostname and the port number in the format \\\"hostname:port\\\"' +\\r\\n      ' - Because of this, you should never use host and port options together');\\r\\n  }\\r\\n\\r\\n  var isSecureDefault = isUrlSecure();\\r\\n\\r\\n  var opts = {\\r\\n    port: getPort(options, isSecureDefault),\\r\\n    hostname: global.location && location.hostname || 'localhost',\\r\\n    path: '/socketcluster/',\\r\\n    secure: isSecureDefault,\\r\\n    autoConnect: true,\\r\\n    autoReconnect: true,\\r\\n    autoSubscribeOnConnect: true,\\r\\n    connectTimeout: 20000,\\r\\n    ackTimeout: 10000,\\r\\n    timestampRequests: false,\\r\\n    timestampParam: 't',\\r\\n    authEngine: null,\\r\\n    authTokenName: 'socketCluster.authToken',\\r\\n    binaryType: 'arraybuffer',\\r\\n    multiplex: true,\\r\\n    pubSubBatchDuration: null,\\r\\n    cloneData: false\\r\\n  };\\r\\n  for (var i in options) {\\r\\n    if (options.hasOwnProperty(i)) {\\r\\n      opts[i] = options[i];\\r\\n    }\\r\\n  }\\r\\n  opts.clientMap = _clients;\\r\\n\\r\\n  if (opts.multiplex === false) {\\r\\n    opts.clientId = uuid.v4();\\r\\n    var socket = new SCClientSocket(opts);\\r\\n    _clients[opts.clientId] = socket;\\r\\n    return socket;\\r\\n  }\\r\\n  opts.clientId = getMultiplexId(opts);\\r\\n\\r\\n  if (_clients[opts.clientId]) {\\r\\n    if (opts.autoConnect) {\\r\\n      _clients[opts.clientId].connect();\\r\\n    }\\r\\n  } else {\\r\\n    _clients[opts.clientId] = new SCClientSocket(opts);\\r\\n  }\\r\\n  return _clients[opts.clientId];\\r\\n}\\r\\n\\r\\nfunction destroy(socket) {\\r\\n  socket.destroy();\\r\\n}\\r\\n\\r\\nmodule.exports = {\\r\\n  create: create,\\r\\n  destroy: destroy,\\r\\n  clients: _clients\\r\\n};\\r\\n\\r\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n},{\\\"./scclientsocket\\\":5,\\\"sc-errors\\\":20,\\\"uuid\\\":22}],4:[function(_dereq_,module,exports){\\r\\nvar scErrors = _dereq_('sc-errors');\\r\\nvar InvalidActionError = scErrors.InvalidActionError;\\r\\n\\r\\nvar Response = function (socket, id) {\\r\\n  this.socket = socket;\\r\\n  this.id = id;\\r\\n  this.sent = false;\\r\\n};\\r\\n\\r\\nResponse.prototype._respond = function (responseData) {\\r\\n  if (this.sent) {\\r\\n    throw new InvalidActionError('Response ' + this.id + ' has already been sent');\\r\\n  } else {\\r\\n    this.sent = true;\\r\\n    this.socket.send(this.socket.encode(responseData));\\r\\n  }\\r\\n};\\r\\n\\r\\nResponse.prototype.end = function (data) {\\r\\n  if (this.id) {\\r\\n    var responseData = {\\r\\n      rid: this.id\\r\\n    };\\r\\n    if (data !== undefined) {\\r\\n      responseData.data = data;\\r\\n    }\\r\\n    this._respond(responseData);\\r\\n  }\\r\\n};\\r\\n\\r\\nResponse.prototype.error = function (error, data) {\\r\\n  if (this.id) {\\r\\n    var err = scErrors.dehydrateError(error);\\r\\n\\r\\n    var responseData = {\\r\\n      rid: this.id,\\r\\n      error: err\\r\\n    };\\r\\n    if (data !== undefined) {\\r\\n      responseData.data = data;\\r\\n    }\\r\\n\\r\\n    this._respond(responseData);\\r\\n  }\\r\\n};\\r\\n\\r\\nResponse.prototype.callback = function (error, data) {\\r\\n  if (error) {\\r\\n    this.error(error, data);\\r\\n  } else {\\r\\n    this.end(data);\\r\\n  }\\r\\n};\\r\\n\\r\\nmodule.exports.Response = Response;\\r\\n\\r\\n},{\\\"sc-errors\\\":20}],5:[function(_dereq_,module,exports){\\r\\n(function (global){\\r\\nvar Emitter = _dereq_('component-emitter');\\r\\nvar SCChannel = _dereq_('sc-channel').SCChannel;\\r\\nvar Response = _dereq_('./response').Response;\\r\\nvar AuthEngine = _dereq_('./auth').AuthEngine;\\r\\nvar formatter = _dereq_('sc-formatter');\\r\\nvar SCTransport = _dereq_('./sctransport').SCTransport;\\r\\nvar querystring = _dereq_('querystring');\\r\\nvar LinkedList = _dereq_('linked-list');\\r\\nvar Buffer = _dereq_('buffer/').Buffer;\\r\\nvar clone = _dereq_('clone');\\r\\n\\r\\nvar scErrors = _dereq_('sc-errors');\\r\\nvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\\r\\nvar InvalidMessageError = scErrors.InvalidMessageError;\\r\\nvar InvalidActionError = scErrors.InvalidActionError;\\r\\nvar SocketProtocolError = scErrors.SocketProtocolError;\\r\\nvar TimeoutError = scErrors.TimeoutError;\\r\\nvar BadConnectionError = scErrors.BadConnectionError;\\r\\n\\r\\nvar isBrowser = typeof window !== 'undefined';\\r\\n\\r\\n\\r\\nvar SCClientSocket = function (opts) {\\r\\n  var self = this;\\r\\n\\r\\n  Emitter.call(this);\\r\\n\\r\\n  this.id = null;\\r\\n  this.state = this.CLOSED;\\r\\n  this.authState = this.UNAUTHENTICATED;\\r\\n  this.signedAuthToken = null;\\r\\n  this.authToken = null;\\r\\n  this.pendingReconnect = false;\\r\\n  this.pendingReconnectTimeout = null;\\r\\n  this.preparingPendingSubscriptions = false;\\r\\n  this.clientId = opts.clientId;\\r\\n\\r\\n  this.connectTimeout = opts.connectTimeout;\\r\\n  this.ackTimeout = opts.ackTimeout;\\r\\n  this.channelPrefix = opts.channelPrefix || null;\\r\\n  this.disconnectOnUnload = opts.disconnectOnUnload == null ? true : opts.disconnectOnUnload;\\r\\n  this.authTokenName = opts.authTokenName;\\r\\n\\r\\n  // pingTimeout will be ackTimeout at the start, but it will\\r\\n  // be updated with values provided by the 'connect' event\\r\\n  this.pingTimeout = this.ackTimeout;\\r\\n  this.pingTimeoutDisabled = !!opts.pingTimeoutDisabled;\\r\\n  this.active = true;\\r\\n\\r\\n  this._clientMap = opts.clientMap || {};\\r\\n\\r\\n  var maxTimeout = Math.pow(2, 31) - 1;\\r\\n\\r\\n  var verifyDuration = function (propertyName) {\\r\\n    if (self[propertyName] > maxTimeout) {\\r\\n      throw new InvalidArgumentsError('The ' + propertyName +\\r\\n        ' value provided exceeded the maximum amount allowed');\\r\\n    }\\r\\n  };\\r\\n\\r\\n  verifyDuration('connectTimeout');\\r\\n  verifyDuration('ackTimeout');\\r\\n\\r\\n  this._localEvents = {\\r\\n    'connect': 1,\\r\\n    'connectAbort': 1,\\r\\n    'close': 1,\\r\\n    'disconnect': 1,\\r\\n    'message': 1,\\r\\n    'error': 1,\\r\\n    'raw': 1,\\r\\n    'kickOut': 1,\\r\\n    'subscribe': 1,\\r\\n    'unsubscribe': 1,\\r\\n    'subscribeStateChange': 1,\\r\\n    'authStateChange': 1,\\r\\n    'authenticate': 1,\\r\\n    'deauthenticate': 1,\\r\\n    'removeAuthToken': 1,\\r\\n    'subscribeRequest': 1\\r\\n  };\\r\\n\\r\\n  this.connectAttempts = 0;\\r\\n\\r\\n  this._emitBuffer = new LinkedList();\\r\\n  this.channels = {};\\r\\n\\r\\n  this.options = opts;\\r\\n\\r\\n  this._cid = 1;\\r\\n\\r\\n  this.options.callIdGenerator = function () {\\r\\n    return self._cid++;\\r\\n  };\\r\\n\\r\\n  if (this.options.autoReconnect) {\\r\\n    if (this.options.autoReconnectOptions == null) {\\r\\n      this.options.autoReconnectOptions = {};\\r\\n    }\\r\\n\\r\\n    // Add properties to the this.options.autoReconnectOptions object.\\r\\n    // We assign the reference to a reconnectOptions variable to avoid repetition.\\r\\n    var reconnectOptions = this.options.autoReconnectOptions;\\r\\n    if (reconnectOptions.initialDelay == null) {\\r\\n      reconnectOptions.initialDelay = 10000;\\r\\n    }\\r\\n    if (reconnectOptions.randomness == null) {\\r\\n      reconnectOptions.randomness = 10000;\\r\\n    }\\r\\n    if (reconnectOptions.multiplier == null) {\\r\\n      reconnectOptions.multiplier = 1.5;\\r\\n    }\\r\\n    if (reconnectOptions.maxDelay == null) {\\r\\n      reconnectOptions.maxDelay = 60000;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (this.options.subscriptionRetryOptions == null) {\\r\\n    this.options.subscriptionRetryOptions = {};\\r\\n  }\\r\\n\\r\\n  if (this.options.authEngine) {\\r\\n    this.auth = this.options.authEngine;\\r\\n  } else {\\r\\n    this.auth = new AuthEngine();\\r\\n  }\\r\\n\\r\\n  if (this.options.codecEngine) {\\r\\n    this.codec = this.options.codecEngine;\\r\\n  } else {\\r\\n    // Default codec engine\\r\\n    this.codec = formatter;\\r\\n  }\\r\\n\\r\\n  if (this.options.protocol) {\\r\\n    var protocolOptionError = new InvalidArgumentsError('The \\\"protocol\\\" option' +\\r\\n      ' does not affect socketcluster-client. If you want to utilize SSL/TLS' +\\r\\n      ' - use \\\"secure\\\" option instead');\\r\\n    this._onSCError(protocolOptionError);\\r\\n  }\\r\\n\\r\\n  this.options.path = this.options.path.replace(/\\\\/$/, '') + '/';\\r\\n\\r\\n  this.options.query = opts.query || {};\\r\\n  if (typeof this.options.query === 'string') {\\r\\n    this.options.query = querystring.parse(this.options.query);\\r\\n  }\\r\\n\\r\\n  this._channelEmitter = new Emitter();\\r\\n\\r\\n  this._unloadHandler = function () {\\r\\n    self.disconnect();\\r\\n  };\\r\\n\\r\\n  if (isBrowser && this.disconnectOnUnload && global.addEventListener) {\\r\\n    global.addEventListener('beforeunload', this._unloadHandler, false);\\r\\n  }\\r\\n  this._clientMap[this.clientId] = this;\\r\\n\\r\\n  if (this.options.autoConnect) {\\r\\n    this.connect();\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype = Object.create(Emitter.prototype);\\r\\n\\r\\nSCClientSocket.CONNECTING = SCClientSocket.prototype.CONNECTING = SCTransport.prototype.CONNECTING;\\r\\nSCClientSocket.OPEN = SCClientSocket.prototype.OPEN = SCTransport.prototype.OPEN;\\r\\nSCClientSocket.CLOSED = SCClientSocket.prototype.CLOSED = SCTransport.prototype.CLOSED;\\r\\n\\r\\nSCClientSocket.AUTHENTICATED = SCClientSocket.prototype.AUTHENTICATED = 'authenticated';\\r\\nSCClientSocket.UNAUTHENTICATED = SCClientSocket.prototype.UNAUTHENTICATED = 'unauthenticated';\\r\\n\\r\\nSCClientSocket.PENDING = SCClientSocket.prototype.PENDING = 'pending';\\r\\n\\r\\nSCClientSocket.ignoreStatuses = scErrors.socketProtocolIgnoreStatuses;\\r\\nSCClientSocket.errorStatuses = scErrors.socketProtocolErrorStatuses;\\r\\n\\r\\nSCClientSocket.prototype._privateEventHandlerMap = {\\r\\n  '#publish': function (data) {\\r\\n    var undecoratedChannelName = this._undecorateChannelName(data.channel);\\r\\n    var isSubscribed = this.isSubscribed(undecoratedChannelName, true);\\r\\n\\r\\n    if (isSubscribed) {\\r\\n      this._channelEmitter.emit(undecoratedChannelName, data.data);\\r\\n    }\\r\\n  },\\r\\n  '#kickOut': function (data) {\\r\\n    var undecoratedChannelName = this._undecorateChannelName(data.channel);\\r\\n    var channel = this.channels[undecoratedChannelName];\\r\\n    if (channel) {\\r\\n      Emitter.prototype.emit.call(this, 'kickOut', data.message, undecoratedChannelName);\\r\\n      channel.emit('kickOut', data.message, undecoratedChannelName);\\r\\n      this._triggerChannelUnsubscribe(channel);\\r\\n    }\\r\\n  },\\r\\n  '#setAuthToken': function (data, response) {\\r\\n    var self = this;\\r\\n\\r\\n    if (data) {\\r\\n      var triggerAuthenticate = function (err) {\\r\\n        if (err) {\\r\\n          // This is a non-fatal error, we don't want to close the connection\\r\\n          // because of this but we do want to notify the server and throw an error\\r\\n          // on the client.\\r\\n          response.error(err);\\r\\n          self._onSCError(err);\\r\\n        } else {\\r\\n          self._changeToAuthenticatedState(data.token);\\r\\n          response.end();\\r\\n        }\\r\\n      };\\r\\n\\r\\n      this.auth.saveToken(this.authTokenName, data.token, {}, triggerAuthenticate);\\r\\n    } else {\\r\\n      response.error(new InvalidMessageError('No token data provided by #setAuthToken event'));\\r\\n    }\\r\\n  },\\r\\n  '#removeAuthToken': function (data, response) {\\r\\n    var self = this;\\r\\n\\r\\n    this.auth.removeToken(this.authTokenName, function (err, oldToken) {\\r\\n      if (err) {\\r\\n        // Non-fatal error - Do not close the connection\\r\\n        response.error(err);\\r\\n        self._onSCError(err);\\r\\n      } else {\\r\\n        Emitter.prototype.emit.call(self, 'removeAuthToken', oldToken);\\r\\n        self._changeToUnauthenticatedStateAndClearTokens();\\r\\n        response.end();\\r\\n      }\\r\\n    });\\r\\n  },\\r\\n  '#disconnect': function (data) {\\r\\n    this.transport.close(data.code, data.data);\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.getState = function () {\\r\\n  return this.state;\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.getBytesReceived = function () {\\r\\n  return this.transport.getBytesReceived();\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.deauthenticate = function (callback) {\\r\\n  var self = this;\\r\\n\\r\\n  this.auth.removeToken(this.authTokenName, function (err, oldToken) {\\r\\n    if (err) {\\r\\n      // Non-fatal error - Do not close the connection\\r\\n      self._onSCError(err);\\r\\n    } else {\\r\\n      Emitter.prototype.emit.call(self, 'removeAuthToken', oldToken);\\r\\n      if (self.state !== self.CLOSED) {\\r\\n        self.emit('#removeAuthToken');\\r\\n      }\\r\\n      self._changeToUnauthenticatedStateAndClearTokens();\\r\\n    }\\r\\n    callback && callback(err);\\r\\n  });\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.connect = SCClientSocket.prototype.open = function () {\\r\\n  var self = this;\\r\\n\\r\\n  if (!this.active) {\\r\\n    var error = new InvalidActionError('Cannot connect a destroyed client');\\r\\n    this._onSCError(error);\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  if (this.state === this.CLOSED) {\\r\\n    this.pendingReconnect = false;\\r\\n    this.pendingReconnectTimeout = null;\\r\\n    clearTimeout(this._reconnectTimeoutRef);\\r\\n\\r\\n    this.state = this.CONNECTING;\\r\\n    Emitter.prototype.emit.call(this, 'connecting');\\r\\n\\r\\n    if (this.transport) {\\r\\n      this.transport.off();\\r\\n    }\\r\\n\\r\\n    this.transport = new SCTransport(this.auth, this.codec, this.options);\\r\\n\\r\\n    this.transport.on('open', function (status) {\\r\\n      self.state = self.OPEN;\\r\\n      self._onSCOpen(status);\\r\\n    });\\r\\n\\r\\n    this.transport.on('error', function (err) {\\r\\n      self._onSCError(err);\\r\\n    });\\r\\n\\r\\n    this.transport.on('close', function (code, data) {\\r\\n      self.state = self.CLOSED;\\r\\n      self._onSCClose(code, data);\\r\\n    });\\r\\n\\r\\n    this.transport.on('openAbort', function (code, data) {\\r\\n      self.state = self.CLOSED;\\r\\n      self._onSCClose(code, data, true);\\r\\n    });\\r\\n\\r\\n    this.transport.on('event', function (event, data, res) {\\r\\n      self._onSCEvent(event, data, res);\\r\\n    });\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.reconnect = function (code, data) {\\r\\n  this.disconnect(code, data);\\r\\n  this.connect();\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.disconnect = function (code, data) {\\r\\n  code = code || 1000;\\r\\n\\r\\n  if (typeof code !== 'number') {\\r\\n    throw new InvalidArgumentsError('If specified, the code argument must be a number');\\r\\n  }\\r\\n\\r\\n  if (this.state === this.OPEN || this.state === this.CONNECTING) {\\r\\n    this.transport.close(code, data);\\r\\n  } else {\\r\\n    this.pendingReconnect = false;\\r\\n    this.pendingReconnectTimeout = null;\\r\\n    clearTimeout(this._reconnectTimeoutRef);\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.destroy = function (code, data) {\\r\\n  if (isBrowser && global.removeEventListener) {\\r\\n    global.removeEventListener('beforeunload', this._unloadHandler, false);\\r\\n  }\\r\\n  this.active = false;\\r\\n  this.disconnect(code, data);\\r\\n  delete this._clientMap[this.clientId];\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._changeToUnauthenticatedStateAndClearTokens = function () {\\r\\n  if (this.authState !== this.UNAUTHENTICATED) {\\r\\n    var oldState = this.authState;\\r\\n    var oldSignedToken = this.signedAuthToken;\\r\\n    this.authState = this.UNAUTHENTICATED;\\r\\n    this.signedAuthToken = null;\\r\\n    this.authToken = null;\\r\\n\\r\\n    var stateChangeData = {\\r\\n      oldState: oldState,\\r\\n      newState: this.authState\\r\\n    };\\r\\n    Emitter.prototype.emit.call(this, 'authStateChange', stateChangeData);\\r\\n    Emitter.prototype.emit.call(this, 'deauthenticate', oldSignedToken);\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._changeToAuthenticatedState = function (signedAuthToken) {\\r\\n  this.signedAuthToken = signedAuthToken;\\r\\n  this.authToken = this._extractAuthTokenData(signedAuthToken);\\r\\n\\r\\n  if (this.authState !== this.AUTHENTICATED) {\\r\\n    var oldState = this.authState;\\r\\n    this.authState = this.AUTHENTICATED;\\r\\n    var stateChangeData = {\\r\\n      oldState: oldState,\\r\\n      newState: this.authState,\\r\\n      signedAuthToken: signedAuthToken,\\r\\n      authToken: this.authToken\\r\\n    };\\r\\n    if (!this.preparingPendingSubscriptions) {\\r\\n      this.processPendingSubscriptions();\\r\\n    }\\r\\n\\r\\n    Emitter.prototype.emit.call(this, 'authStateChange', stateChangeData);\\r\\n  }\\r\\n  Emitter.prototype.emit.call(this, 'authenticate', signedAuthToken);\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.decodeBase64 = function (encodedString) {\\r\\n  return Buffer.from(encodedString, 'base64').toString('utf8');\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.encodeBase64 = function (decodedString) {\\r\\n  return Buffer.from(decodedString, 'utf8').toString('base64');\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._extractAuthTokenData = function (signedAuthToken) {\\r\\n  var tokenParts = (signedAuthToken || '').split('.');\\r\\n  var encodedTokenData = tokenParts[1];\\r\\n  if (encodedTokenData != null) {\\r\\n    var tokenData = encodedTokenData;\\r\\n    try {\\r\\n      tokenData = this.decodeBase64(tokenData);\\r\\n      return JSON.parse(tokenData);\\r\\n    } catch (e) {\\r\\n      return tokenData;\\r\\n    }\\r\\n  }\\r\\n  return null;\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.getAuthToken = function () {\\r\\n  return this.authToken;\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.getSignedAuthToken = function () {\\r\\n  return this.signedAuthToken;\\r\\n};\\r\\n\\r\\n// Perform client-initiated authentication by providing an encrypted token string.\\r\\nSCClientSocket.prototype.authenticate = function (signedAuthToken, callback) {\\r\\n  var self = this;\\r\\n\\r\\n  this.emit('#authenticate', signedAuthToken, function (err, authStatus) {\\r\\n    if (authStatus && authStatus.isAuthenticated != null) {\\r\\n      // If authStatus is correctly formatted (has an isAuthenticated property),\\r\\n      // then we will rehydrate the authError.\\r\\n      if (authStatus.authError) {\\r\\n        authStatus.authError = scErrors.hydrateError(authStatus.authError);\\r\\n      }\\r\\n    } else {\\r\\n      // Some errors like BadConnectionError and TimeoutError will not pass a valid\\r\\n      // authStatus object to the current function, so we need to create it ourselves.\\r\\n      authStatus = {\\r\\n        isAuthenticated: self.authState,\\r\\n        authError: null\\r\\n      };\\r\\n    }\\r\\n    if (err) {\\r\\n      if (err.name !== 'BadConnectionError' && err.name !== 'TimeoutError') {\\r\\n        // In case of a bad/closed connection or a timeout, we maintain the last\\r\\n        // known auth state since those errors don't mean that the token is invalid.\\r\\n\\r\\n        self._changeToUnauthenticatedStateAndClearTokens();\\r\\n      }\\r\\n      callback && callback(err, authStatus);\\r\\n    } else {\\r\\n      self.auth.saveToken(self.authTokenName, signedAuthToken, {}, function (err) {\\r\\n        if (err) {\\r\\n          self._onSCError(err);\\r\\n        }\\r\\n        if (authStatus.isAuthenticated) {\\r\\n          self._changeToAuthenticatedState(signedAuthToken);\\r\\n        } else {\\r\\n          self._changeToUnauthenticatedStateAndClearTokens();\\r\\n        }\\r\\n        callback && callback(err, authStatus);\\r\\n      });\\r\\n    }\\r\\n  });\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._tryReconnect = function (initialDelay) {\\r\\n  var self = this;\\r\\n\\r\\n  var exponent = this.connectAttempts++;\\r\\n  var reconnectOptions = this.options.autoReconnectOptions;\\r\\n  var timeout;\\r\\n\\r\\n  if (initialDelay == null || exponent > 0) {\\r\\n    var initialTimeout = Math.round(reconnectOptions.initialDelay + (reconnectOptions.randomness || 0) * Math.random());\\r\\n\\r\\n    timeout = Math.round(initialTimeout * Math.pow(reconnectOptions.multiplier, exponent));\\r\\n  } else {\\r\\n    timeout = initialDelay;\\r\\n  }\\r\\n\\r\\n  if (timeout > reconnectOptions.maxDelay) {\\r\\n    timeout = reconnectOptions.maxDelay;\\r\\n  }\\r\\n\\r\\n  clearTimeout(this._reconnectTimeoutRef);\\r\\n\\r\\n  this.pendingReconnect = true;\\r\\n  this.pendingReconnectTimeout = timeout;\\r\\n  this._reconnectTimeoutRef = setTimeout(function () {\\r\\n    self.connect();\\r\\n  }, timeout);\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._onSCOpen = function (status) {\\r\\n  var self = this;\\r\\n\\r\\n  this.preparingPendingSubscriptions = true;\\r\\n\\r\\n  if (status) {\\r\\n    this.id = status.id;\\r\\n    this.pingTimeout = status.pingTimeout;\\r\\n    this.transport.pingTimeout = this.pingTimeout;\\r\\n    if (status.isAuthenticated) {\\r\\n      this._changeToAuthenticatedState(status.authToken);\\r\\n    } else {\\r\\n      this._changeToUnauthenticatedStateAndClearTokens();\\r\\n    }\\r\\n  } else {\\r\\n    // This can happen if auth.loadToken (in sctransport.js) fails with\\r\\n    // an error - This means that the signedAuthToken cannot be loaded by\\r\\n    // the auth engine and therefore, we need to unauthenticate the client.\\r\\n    this._changeToUnauthenticatedStateAndClearTokens();\\r\\n  }\\r\\n\\r\\n  this.connectAttempts = 0;\\r\\n\\r\\n  if (this.options.autoSubscribeOnConnect) {\\r\\n    this.processPendingSubscriptions();\\r\\n  }\\r\\n\\r\\n  // If the user invokes the callback while in autoSubscribeOnConnect mode, it\\r\\n  // won't break anything.\\r\\n  Emitter.prototype.emit.call(this, 'connect', status, function () {\\r\\n    self.processPendingSubscriptions();\\r\\n  });\\r\\n\\r\\n  if (this.state === this.OPEN) {\\r\\n    this._flushEmitBuffer();\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._onSCError = function (err) {\\r\\n  var self = this;\\r\\n\\r\\n  // Throw error in different stack frame so that error handling\\r\\n  // cannot interfere with a reconnect action.\\r\\n  setTimeout(function () {\\r\\n    if (self.listeners('error').length < 1) {\\r\\n      throw err;\\r\\n    } else {\\r\\n      Emitter.prototype.emit.call(self, 'error', err);\\r\\n    }\\r\\n  }, 0);\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._suspendSubscriptions = function () {\\r\\n  var channel, newState;\\r\\n  for (var channelName in this.channels) {\\r\\n    if (this.channels.hasOwnProperty(channelName)) {\\r\\n      channel = this.channels[channelName];\\r\\n      if (channel.state === channel.SUBSCRIBED ||\\r\\n        channel.state === channel.PENDING) {\\r\\n\\r\\n        newState = channel.PENDING;\\r\\n      } else {\\r\\n        newState = channel.UNSUBSCRIBED;\\r\\n      }\\r\\n\\r\\n      this._triggerChannelUnsubscribe(channel, newState);\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._abortAllPendingEventsDueToBadConnection = function (failureType) {\\r\\n  var currentNode = this._emitBuffer.head;\\r\\n  var nextNode;\\r\\n\\r\\n  while (currentNode) {\\r\\n    nextNode = currentNode.next;\\r\\n    var eventObject = currentNode.data;\\r\\n    clearTimeout(eventObject.timeout);\\r\\n    delete eventObject.timeout;\\r\\n    currentNode.detach();\\r\\n    currentNode = nextNode;\\r\\n\\r\\n    var callback = eventObject.callback;\\r\\n    if (callback) {\\r\\n      delete eventObject.callback;\\r\\n      var errorMessage = \\\"Event '\\\" + eventObject.event +\\r\\n        \\\"' was aborted due to a bad connection\\\";\\r\\n      var error = new BadConnectionError(errorMessage, failureType);\\r\\n      callback.call(eventObject, error, eventObject);\\r\\n    }\\r\\n    // Cleanup any pending response callback in the transport layer too.\\r\\n    if (eventObject.cid) {\\r\\n      this.transport.cancelPendingResponse(eventObject.cid);\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._onSCClose = function (code, data, openAbort) {\\r\\n  var self = this;\\r\\n\\r\\n  this.id = null;\\r\\n\\r\\n  if (this.transport) {\\r\\n    this.transport.off();\\r\\n  }\\r\\n  this.pendingReconnect = false;\\r\\n  this.pendingReconnectTimeout = null;\\r\\n  clearTimeout(this._reconnectTimeoutRef);\\r\\n\\r\\n  this._suspendSubscriptions();\\r\\n  this._abortAllPendingEventsDueToBadConnection(openAbort ? 'connectAbort' : 'disconnect');\\r\\n\\r\\n  // Try to reconnect\\r\\n  // on server ping timeout (4000)\\r\\n  // or on client pong timeout (4001)\\r\\n  // or on close without status (1005)\\r\\n  // or on handshake failure (4003)\\r\\n  // or on handshake rejection (4008)\\r\\n  // or on socket hung up (1006)\\r\\n  if (this.options.autoReconnect) {\\r\\n    if (code === 4000 || code === 4001 || code === 1005) {\\r\\n      // If there is a ping or pong timeout or socket closes without\\r\\n      // status, don't wait before trying to reconnect - These could happen\\r\\n      // if the client wakes up after a period of inactivity and in this case we\\r\\n      // want to re-establish the connection as soon as possible.\\r\\n      this._tryReconnect(0);\\r\\n\\r\\n      // Codes 4500 and above will be treated as permanent disconnects.\\r\\n      // Socket will not try to auto-reconnect.\\r\\n    } else if (code !== 1000 && code < 4500) {\\r\\n      this._tryReconnect();\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (openAbort) {\\r\\n    Emitter.prototype.emit.call(self, 'connectAbort', code, data);\\r\\n  } else {\\r\\n    Emitter.prototype.emit.call(self, 'disconnect', code, data);\\r\\n  }\\r\\n  Emitter.prototype.emit.call(self, 'close', code, data);\\r\\n\\r\\n  if (!SCClientSocket.ignoreStatuses[code]) {\\r\\n    var closeMessage;\\r\\n    if (data) {\\r\\n      closeMessage = 'Socket connection closed with status code ' + code + ' and reason: ' + data;\\r\\n    } else {\\r\\n      closeMessage = 'Socket connection closed with status code ' + code;\\r\\n    }\\r\\n    var err = new SocketProtocolError(SCClientSocket.errorStatuses[code] || closeMessage, code);\\r\\n    this._onSCError(err);\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._onSCEvent = function (event, data, res) {\\r\\n  var handler = this._privateEventHandlerMap[event];\\r\\n  if (handler) {\\r\\n    handler.call(this, data, res);\\r\\n  } else {\\r\\n    Emitter.prototype.emit.call(this, event, data, function () {\\r\\n      res && res.callback.apply(res, arguments);\\r\\n    });\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.decode = function (message) {\\r\\n  return this.transport.decode(message);\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.encode = function (object) {\\r\\n  return this.transport.encode(object);\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._flushEmitBuffer = function () {\\r\\n  var currentNode = this._emitBuffer.head;\\r\\n  var nextNode;\\r\\n\\r\\n  while (currentNode) {\\r\\n    nextNode = currentNode.next;\\r\\n    var eventObject = currentNode.data;\\r\\n    currentNode.detach();\\r\\n    this.transport.emitObject(eventObject);\\r\\n    currentNode = nextNode;\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._handleEventAckTimeout = function (eventObject, eventNode) {\\r\\n  if (eventNode) {\\r\\n    eventNode.detach();\\r\\n  }\\r\\n  delete eventObject.timeout;\\r\\n\\r\\n  var callback = eventObject.callback;\\r\\n  if (callback) {\\r\\n    delete eventObject.callback;\\r\\n    var error = new TimeoutError(\\\"Event response for '\\\" + eventObject.event + \\\"' timed out\\\");\\r\\n    callback.call(eventObject, error, eventObject);\\r\\n  }\\r\\n  // Cleanup any pending response callback in the transport layer too.\\r\\n  if (eventObject.cid) {\\r\\n    this.transport.cancelPendingResponse(eventObject.cid);\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._emit = function (event, data, callback) {\\r\\n  var self = this;\\r\\n\\r\\n  if (this.state === this.CLOSED) {\\r\\n    this.connect();\\r\\n  }\\r\\n  var eventObject = {\\r\\n    event: event,\\r\\n    callback: callback\\r\\n  };\\r\\n\\r\\n  var eventNode = new LinkedList.Item();\\r\\n\\r\\n  if (this.options.cloneData) {\\r\\n    eventObject.data = clone(data);\\r\\n  } else {\\r\\n    eventObject.data = data;\\r\\n  }\\r\\n  eventNode.data = eventObject;\\r\\n\\r\\n  eventObject.timeout = setTimeout(function () {\\r\\n    self._handleEventAckTimeout(eventObject, eventNode);\\r\\n  }, this.ackTimeout);\\r\\n\\r\\n  this._emitBuffer.append(eventNode);\\r\\n  if (this.state === this.OPEN) {\\r\\n    this._flushEmitBuffer();\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.send = function (data) {\\r\\n  this.transport.send(data);\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.emit = function (event, data, callback) {\\r\\n  if (this._localEvents[event] == null) {\\r\\n    this._emit(event, data, callback);\\r\\n  } else if (event === 'error') {\\r\\n    Emitter.prototype.emit.call(this, event, data);\\r\\n  } else {\\r\\n    var error = new InvalidActionError('The \\\"' + event + '\\\" event is reserved and cannot be emitted on a client socket');\\r\\n    this._onSCError(error);\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.publish = function (channelName, data, callback) {\\r\\n  var pubData = {\\r\\n    channel: this._decorateChannelName(channelName),\\r\\n    data: data\\r\\n  };\\r\\n  this.emit('#publish', pubData, callback);\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._triggerChannelSubscribe = function (channel, subscriptionOptions) {\\r\\n  var channelName = channel.name;\\r\\n\\r\\n  if (channel.state !== channel.SUBSCRIBED) {\\r\\n    var oldState = channel.state;\\r\\n    channel.state = channel.SUBSCRIBED;\\r\\n\\r\\n    var stateChangeData = {\\r\\n      channel: channelName,\\r\\n      oldState: oldState,\\r\\n      newState: channel.state,\\r\\n      subscriptionOptions: subscriptionOptions\\r\\n    };\\r\\n    channel.emit('subscribeStateChange', stateChangeData);\\r\\n    channel.emit('subscribe', channelName, subscriptionOptions);\\r\\n    Emitter.prototype.emit.call(this, 'subscribeStateChange', stateChangeData);\\r\\n    Emitter.prototype.emit.call(this, 'subscribe', channelName, subscriptionOptions);\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._triggerChannelSubscribeFail = function (err, channel, subscriptionOptions) {\\r\\n  var channelName = channel.name;\\r\\n  var meetsAuthRequirements = !channel.waitForAuth || this.authState === this.AUTHENTICATED;\\r\\n\\r\\n  if (channel.state !== channel.UNSUBSCRIBED && meetsAuthRequirements) {\\r\\n    channel.state = channel.UNSUBSCRIBED;\\r\\n\\r\\n    channel.emit('subscribeFail', err, channelName, subscriptionOptions);\\r\\n    Emitter.prototype.emit.call(this, 'subscribeFail', err, channelName, subscriptionOptions);\\r\\n  }\\r\\n};\\r\\n\\r\\n// Cancel any pending subscribe callback\\r\\nSCClientSocket.prototype._cancelPendingSubscribeCallback = function (channel) {\\r\\n  if (channel._pendingSubscriptionCid != null) {\\r\\n    this.transport.cancelPendingResponse(channel._pendingSubscriptionCid);\\r\\n    delete channel._pendingSubscriptionCid;\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._decorateChannelName = function (channelName) {\\r\\n  if (this.channelPrefix) {\\r\\n    channelName = this.channelPrefix + channelName;\\r\\n  }\\r\\n  return channelName;\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._undecorateChannelName = function (decoratedChannelName) {\\r\\n  if (this.channelPrefix && decoratedChannelName.indexOf(this.channelPrefix) === 0) {\\r\\n    return decoratedChannelName.replace(this.channelPrefix, '');\\r\\n  }\\r\\n  return decoratedChannelName;\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._trySubscribe = function (channel) {\\r\\n  var self = this;\\r\\n\\r\\n  var meetsAuthRequirements = !channel.waitForAuth || this.authState === this.AUTHENTICATED;\\r\\n\\r\\n  // We can only ever have one pending subscribe action at any given time on a channel\\r\\n  if (this.state === this.OPEN && !this.preparingPendingSubscriptions &&\\r\\n    channel._pendingSubscriptionCid == null && meetsAuthRequirements) {\\r\\n\\r\\n    var options = {\\r\\n      noTimeout: true\\r\\n    };\\r\\n\\r\\n    var subscriptionOptions = {\\r\\n      channel: this._decorateChannelName(channel.name)\\r\\n    };\\r\\n    if (channel.waitForAuth) {\\r\\n      options.waitForAuth = true;\\r\\n      subscriptionOptions.waitForAuth = options.waitForAuth;\\r\\n    }\\r\\n    if (channel.data) {\\r\\n      subscriptionOptions.data = channel.data;\\r\\n    }\\r\\n    if (channel.batch) {\\r\\n      options.batch = true;\\r\\n      subscriptionOptions.batch = true;\\r\\n    }\\r\\n\\r\\n    channel._pendingSubscriptionCid = this.transport.emit(\\r\\n      '#subscribe', subscriptionOptions, options,\\r\\n      function (err) {\\r\\n        delete channel._pendingSubscriptionCid;\\r\\n        if (err) {\\r\\n          self._triggerChannelSubscribeFail(err, channel, subscriptionOptions);\\r\\n        } else {\\r\\n          self._triggerChannelSubscribe(channel, subscriptionOptions);\\r\\n        }\\r\\n      }\\r\\n    );\\r\\n    Emitter.prototype.emit.call(this, 'subscribeRequest', channel.name, subscriptionOptions);\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.subscribe = function (channelName, options) {\\r\\n  var channel = this.channels[channelName];\\r\\n\\r\\n  if (!channel) {\\r\\n    channel = new SCChannel(channelName, this, options);\\r\\n    this.channels[channelName] = channel;\\r\\n  } else if (options) {\\r\\n    channel.setOptions(options);\\r\\n  }\\r\\n\\r\\n  if (channel.state === channel.UNSUBSCRIBED) {\\r\\n    channel.state = channel.PENDING;\\r\\n    this._trySubscribe(channel);\\r\\n  }\\r\\n\\r\\n  return channel;\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._triggerChannelUnsubscribe = function (channel, newState) {\\r\\n  var channelName = channel.name;\\r\\n  var oldState = channel.state;\\r\\n\\r\\n  if (newState) {\\r\\n    channel.state = newState;\\r\\n  } else {\\r\\n    channel.state = channel.UNSUBSCRIBED;\\r\\n  }\\r\\n  this._cancelPendingSubscribeCallback(channel);\\r\\n\\r\\n  if (oldState === channel.SUBSCRIBED) {\\r\\n    var stateChangeData = {\\r\\n      channel: channelName,\\r\\n      oldState: oldState,\\r\\n      newState: channel.state\\r\\n    };\\r\\n    channel.emit('subscribeStateChange', stateChangeData);\\r\\n    channel.emit('unsubscribe', channelName);\\r\\n    Emitter.prototype.emit.call(this, 'subscribeStateChange', stateChangeData);\\r\\n    Emitter.prototype.emit.call(this, 'unsubscribe', channelName);\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype._tryUnsubscribe = function (channel) {\\r\\n  var self = this;\\r\\n\\r\\n  if (this.state === this.OPEN) {\\r\\n    var options = {\\r\\n      noTimeout: true\\r\\n    };\\r\\n    if (channel.batch) {\\r\\n      options.batch = true;\\r\\n    }\\r\\n    // If there is a pending subscribe action, cancel the callback\\r\\n    this._cancelPendingSubscribeCallback(channel);\\r\\n\\r\\n    // This operation cannot fail because the TCP protocol guarantees delivery\\r\\n    // so long as the connection remains open. If the connection closes,\\r\\n    // the server will automatically unsubscribe the client and thus complete\\r\\n    // the operation on the server side.\\r\\n    var decoratedChannelName = this._decorateChannelName(channel.name);\\r\\n    this.transport.emit('#unsubscribe', decoratedChannelName, options);\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.unsubscribe = function (channelName) {\\r\\n  var channel = this.channels[channelName];\\r\\n\\r\\n  if (channel) {\\r\\n    if (channel.state !== channel.UNSUBSCRIBED) {\\r\\n      this._triggerChannelUnsubscribe(channel);\\r\\n      this._tryUnsubscribe(channel);\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.channel = function (channelName, options) {\\r\\n  var currentChannel = this.channels[channelName];\\r\\n\\r\\n  if (!currentChannel) {\\r\\n    currentChannel = new SCChannel(channelName, this, options);\\r\\n    this.channels[channelName] = currentChannel;\\r\\n  }\\r\\n  return currentChannel;\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.destroyChannel = function (channelName) {\\r\\n  var channel = this.channels[channelName];\\r\\n\\r\\n  if (channel) {\\r\\n    channel.unwatch();\\r\\n    channel.unsubscribe();\\r\\n    delete this.channels[channelName];\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.subscriptions = function (includePending) {\\r\\n  var subs = [];\\r\\n  var channel, includeChannel;\\r\\n  for (var channelName in this.channels) {\\r\\n    if (this.channels.hasOwnProperty(channelName)) {\\r\\n      channel = this.channels[channelName];\\r\\n\\r\\n      if (includePending) {\\r\\n        includeChannel = channel && (channel.state === channel.SUBSCRIBED ||\\r\\n          channel.state === channel.PENDING);\\r\\n      } else {\\r\\n        includeChannel = channel && channel.state === channel.SUBSCRIBED;\\r\\n      }\\r\\n\\r\\n      if (includeChannel) {\\r\\n        subs.push(channelName);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  return subs;\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.isSubscribed = function (channelName, includePending) {\\r\\n  var channel = this.channels[channelName];\\r\\n  if (includePending) {\\r\\n    return !!channel && (channel.state === channel.SUBSCRIBED ||\\r\\n      channel.state === channel.PENDING);\\r\\n  }\\r\\n  return !!channel && channel.state === channel.SUBSCRIBED;\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.processPendingSubscriptions = function () {\\r\\n  var self = this;\\r\\n\\r\\n  this.preparingPendingSubscriptions = false;\\r\\n\\r\\n  var pendingChannels = [];\\r\\n\\r\\n  for (var i in this.channels) {\\r\\n    if (this.channels.hasOwnProperty(i)) {\\r\\n      var channel = this.channels[i];\\r\\n      if (channel.state === channel.PENDING) {\\r\\n        pendingChannels.push(channel);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  pendingChannels.sort(function (a, b) {\\r\\n    var ap = a.priority || 0;\\r\\n    var bp = b.priority || 0;\\r\\n    if (ap > bp) {\\r\\n      return -1;\\r\\n    }\\r\\n    if (ap < bp) {\\r\\n      return 1;\\r\\n    }\\r\\n    return 0;\\r\\n  });\\r\\n\\r\\n  pendingChannels.forEach(function (channel) {\\r\\n    self._trySubscribe(channel);\\r\\n  });\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.watch = function (channelName, handler) {\\r\\n  if (typeof handler !== 'function') {\\r\\n    throw new InvalidArgumentsError('No handler function was provided');\\r\\n  }\\r\\n  this._channelEmitter.on(channelName, handler);\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.unwatch = function (channelName, handler) {\\r\\n  if (handler) {\\r\\n    this._channelEmitter.removeListener(channelName, handler);\\r\\n  } else {\\r\\n    this._channelEmitter.removeAllListeners(channelName);\\r\\n  }\\r\\n};\\r\\n\\r\\nSCClientSocket.prototype.watchers = function (channelName) {\\r\\n  return this._channelEmitter.listeners(channelName);\\r\\n};\\r\\n\\r\\nmodule.exports = SCClientSocket;\\r\\n\\r\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n},{\\\"./auth\\\":2,\\\"./response\\\":4,\\\"./sctransport\\\":6,\\\"buffer/\\\":9,\\\"clone\\\":10,\\\"component-emitter\\\":11,\\\"linked-list\\\":14,\\\"querystring\\\":17,\\\"sc-channel\\\":18,\\\"sc-errors\\\":20,\\\"sc-formatter\\\":21}],6:[function(_dereq_,module,exports){\\r\\n(function (global){\\r\\nvar Emitter = _dereq_('component-emitter');\\r\\nvar Response = _dereq_('./response').Response;\\r\\nvar querystring = _dereq_('querystring');\\r\\nvar WebSocket;\\r\\nvar createWebSocket;\\r\\n\\r\\nif (global.WebSocket) {\\r\\n  WebSocket = global.WebSocket;\\r\\n  createWebSocket = function (uri, options) {\\r\\n    return new WebSocket(uri);\\r\\n  };\\r\\n} else {\\r\\n  WebSocket = _dereq_('ws');\\r\\n  createWebSocket = function (uri, options) {\\r\\n    return new WebSocket(uri, null, options);\\r\\n  };\\r\\n}\\r\\n\\r\\nvar scErrors = _dereq_('sc-errors');\\r\\nvar TimeoutError = scErrors.TimeoutError;\\r\\nvar BadConnectionError = scErrors.BadConnectionError;\\r\\n\\r\\n\\r\\nvar SCTransport = function (authEngine, codecEngine, options) {\\r\\n  var self = this;\\r\\n\\r\\n  this.state = this.CLOSED;\\r\\n  this.auth = authEngine;\\r\\n  this.codec = codecEngine;\\r\\n  this.options = options;\\r\\n  this.connectTimeout = options.connectTimeout;\\r\\n  this.pingTimeout = options.ackTimeout;\\r\\n  this.pingTimeoutDisabled = !!options.pingTimeoutDisabled;\\r\\n  this.callIdGenerator = options.callIdGenerator;\\r\\n  this.authTokenName = options.authTokenName;\\r\\n\\r\\n  this._pingTimeoutTicker = null;\\r\\n  this._callbackMap = {};\\r\\n  this._batchSendList = [];\\r\\n\\r\\n  // Open the connection.\\r\\n\\r\\n  this.state = this.CONNECTING;\\r\\n  var uri = this.uri();\\r\\n\\r\\n  var wsSocket = createWebSocket(uri, this.options);\\r\\n  wsSocket.binaryType = this.options.binaryType;\\r\\n\\r\\n  this.socket = wsSocket;\\r\\n\\r\\n  wsSocket.onopen = function () {\\r\\n    self._onOpen();\\r\\n  };\\r\\n\\r\\n  wsSocket.onclose = function (event) {\\r\\n    var code;\\r\\n    if (event.code == null) {\\r\\n      // This is to handle an edge case in React Native whereby\\r\\n      // event.code is undefined when the mobile device is locked.\\r\\n      // TODO: This is not perfect since this condition could also apply to\\r\\n      // an abnormal close (no close control frame) which would be a 1006.\\r\\n      code = 1005;\\r\\n    } else {\\r\\n      code = event.code;\\r\\n    }\\r\\n    self._onClose(code, event.reason);\\r\\n  };\\r\\n\\r\\n  wsSocket.onmessage = function (message, flags) {\\r\\n    self._onMessage(message.data);\\r\\n  };\\r\\n\\r\\n  wsSocket.onerror = function (error) {\\r\\n    // The onclose event will be called automatically after the onerror event\\r\\n    // if the socket is connected - Otherwise, if it's in the middle of\\r\\n    // connecting, we want to close it manually with a 1006 - This is necessary\\r\\n    // to prevent inconsistent behavior when running the client in Node.js\\r\\n    // vs in a browser.\\r\\n\\r\\n    if (self.state === self.CONNECTING) {\\r\\n      self._onClose(1006);\\r\\n    }\\r\\n  };\\r\\n\\r\\n  this._connectTimeoutRef = setTimeout(function () {\\r\\n    self._onClose(4007);\\r\\n    self.socket.close(4007);\\r\\n  }, this.connectTimeout);\\r\\n};\\r\\n\\r\\nSCTransport.prototype = Object.create(Emitter.prototype);\\r\\n\\r\\nSCTransport.CONNECTING = SCTransport.prototype.CONNECTING = 'connecting';\\r\\nSCTransport.OPEN = SCTransport.prototype.OPEN = 'open';\\r\\nSCTransport.CLOSED = SCTransport.prototype.CLOSED = 'closed';\\r\\n\\r\\nSCTransport.prototype.uri = function () {\\r\\n  var query = this.options.query || {};\\r\\n  var schema = this.options.secure ? 'wss' : 'ws';\\r\\n\\r\\n  if (this.options.timestampRequests) {\\r\\n    query[this.options.timestampParam] = (new Date()).getTime();\\r\\n  }\\r\\n\\r\\n  query = querystring.encode(query);\\r\\n\\r\\n  if (query.length) {\\r\\n    query = '?' + query;\\r\\n  }\\r\\n\\r\\n  var host;\\r\\n  if (this.options.host) {\\r\\n    host = this.options.host;\\r\\n  } else {\\r\\n    var port = '';\\r\\n\\r\\n    if (this.options.port && ((schema === 'wss' && this.options.port !== 443)\\r\\n      || (schema === 'ws' && this.options.port !== 80))) {\\r\\n      port = ':' + this.options.port;\\r\\n    }\\r\\n    host = this.options.hostname + port;\\r\\n  }\\r\\n\\r\\n  return schema + '://' + host + this.options.path + query;\\r\\n};\\r\\n\\r\\nSCTransport.prototype._onOpen = function () {\\r\\n  var self = this;\\r\\n\\r\\n  clearTimeout(this._connectTimeoutRef);\\r\\n  this._resetPingTimeout();\\r\\n\\r\\n  this._handshake(function (err, status) {\\r\\n    if (err) {\\r\\n      var statusCode;\\r\\n      if (status && status.code) {\\r\\n        statusCode = status.code;\\r\\n      } else {\\r\\n        statusCode = 4003;\\r\\n      }\\r\\n      self._onError(err);\\r\\n      self._onClose(statusCode, err.toString());\\r\\n      self.socket.close(statusCode);\\r\\n    } else {\\r\\n      self.state = self.OPEN;\\r\\n      Emitter.prototype.emit.call(self, 'open', status);\\r\\n      self._resetPingTimeout();\\r\\n    }\\r\\n  });\\r\\n};\\r\\n\\r\\nSCTransport.prototype._handshake = function (callback) {\\r\\n  var self = this;\\r\\n  this.auth.loadToken(this.authTokenName, function (err, token) {\\r\\n    if (err) {\\r\\n      callback(err);\\r\\n    } else {\\r\\n      // Don't wait for this.state to be 'open'.\\r\\n      // The underlying WebSocket (this.socket) is already open.\\r\\n      var options = {\\r\\n        force: true\\r\\n      };\\r\\n      self.emit('#handshake', {\\r\\n        authToken: token\\r\\n      }, options, function (err, status) {\\r\\n        if (status) {\\r\\n          // Add the token which was used as part of authentication attempt\\r\\n          // to the status object.\\r\\n          status.authToken = token;\\r\\n          if (status.authError) {\\r\\n            status.authError = scErrors.hydrateError(status.authError);\\r\\n          }\\r\\n        }\\r\\n        callback(err, status);\\r\\n      });\\r\\n    }\\r\\n  });\\r\\n};\\r\\n\\r\\nSCTransport.prototype._abortAllPendingEventsDueToBadConnection = function (failureType) {\\r\\n  for (var i in this._callbackMap) {\\r\\n    if (this._callbackMap.hasOwnProperty(i)) {\\r\\n      var eventObject = this._callbackMap[i];\\r\\n      delete this._callbackMap[i];\\r\\n\\r\\n      clearTimeout(eventObject.timeout);\\r\\n      delete eventObject.timeout;\\r\\n\\r\\n      var errorMessage = \\\"Event '\\\" + eventObject.event +\\r\\n        \\\"' was aborted due to a bad connection\\\";\\r\\n      var badConnectionError = new BadConnectionError(errorMessage, failureType);\\r\\n\\r\\n      var callback = eventObject.callback;\\r\\n      delete eventObject.callback;\\r\\n      callback.call(eventObject, badConnectionError, eventObject);\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nSCTransport.prototype._onClose = function (code, data) {\\r\\n  delete this.socket.onopen;\\r\\n  delete this.socket.onclose;\\r\\n  delete this.socket.onmessage;\\r\\n  delete this.socket.onerror;\\r\\n\\r\\n  clearTimeout(this._connectTimeoutRef);\\r\\n  clearTimeout(this._pingTimeoutTicker);\\r\\n  clearTimeout(this._batchTimeout);\\r\\n\\r\\n  if (this.state === this.OPEN) {\\r\\n    this.state = this.CLOSED;\\r\\n    Emitter.prototype.emit.call(this, 'close', code, data);\\r\\n    this._abortAllPendingEventsDueToBadConnection('disconnect');\\r\\n\\r\\n  } else if (this.state === this.CONNECTING) {\\r\\n    this.state = this.CLOSED;\\r\\n    Emitter.prototype.emit.call(this, 'openAbort', code, data);\\r\\n    this._abortAllPendingEventsDueToBadConnection('connectAbort');\\r\\n  }\\r\\n};\\r\\n\\r\\nSCTransport.prototype._handleEventObject = function (obj, message) {\\r\\n  if (obj && obj.event != null) {\\r\\n    var response = new Response(this, obj.cid);\\r\\n    Emitter.prototype.emit.call(this, 'event', obj.event, obj.data, response);\\r\\n  } else if (obj && obj.rid != null) {\\r\\n    var eventObject = this._callbackMap[obj.rid];\\r\\n    if (eventObject) {\\r\\n      clearTimeout(eventObject.timeout);\\r\\n      delete eventObject.timeout;\\r\\n      delete this._callbackMap[obj.rid];\\r\\n\\r\\n      if (eventObject.callback) {\\r\\n        var rehydratedError = scErrors.hydrateError(obj.error);\\r\\n        eventObject.callback(rehydratedError, obj.data);\\r\\n      }\\r\\n    }\\r\\n  } else {\\r\\n    Emitter.prototype.emit.call(this, 'event', 'raw', message);\\r\\n  }\\r\\n};\\r\\n\\r\\nSCTransport.prototype._onMessage = function (message) {\\r\\n  Emitter.prototype.emit.call(this, 'event', 'message', message);\\r\\n\\r\\n  var obj = this.decode(message);\\r\\n\\r\\n  // If ping\\r\\n  if (obj === '#1') {\\r\\n    this._resetPingTimeout();\\r\\n    if (this.socket.readyState === this.socket.OPEN) {\\r\\n      this.sendObject('#2');\\r\\n    }\\r\\n  } else {\\r\\n    if (Array.isArray(obj)) {\\r\\n      var len = obj.length;\\r\\n      for (var i = 0; i < len; i++) {\\r\\n        this._handleEventObject(obj[i], message);\\r\\n      }\\r\\n    } else {\\r\\n      this._handleEventObject(obj, message);\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nSCTransport.prototype._onError = function (err) {\\r\\n  Emitter.prototype.emit.call(this, 'error', err);\\r\\n};\\r\\n\\r\\nSCTransport.prototype._resetPingTimeout = function () {\\r\\n  if (this.pingTimeoutDisabled) {\\r\\n    return;\\r\\n  }\\r\\n  var self = this;\\r\\n\\r\\n  var now = (new Date()).getTime();\\r\\n  clearTimeout(this._pingTimeoutTicker);\\r\\n\\r\\n  this._pingTimeoutTicker = setTimeout(function () {\\r\\n    self._onClose(4000);\\r\\n    self.socket.close(4000);\\r\\n  }, this.pingTimeout);\\r\\n};\\r\\n\\r\\nSCTransport.prototype.getBytesReceived = function () {\\r\\n  return this.socket.bytesReceived;\\r\\n};\\r\\n\\r\\nSCTransport.prototype.close = function (code, data) {\\r\\n  code = code || 1000;\\r\\n\\r\\n  if (this.state === this.OPEN) {\\r\\n    var packet = {\\r\\n      code: code,\\r\\n      data: data\\r\\n    };\\r\\n    this.emit('#disconnect', packet);\\r\\n\\r\\n    this._onClose(code, data);\\r\\n    this.socket.close(code);\\r\\n\\r\\n  } else if (this.state === this.CONNECTING) {\\r\\n    this._onClose(code, data);\\r\\n    this.socket.close(code);\\r\\n  }\\r\\n};\\r\\n\\r\\nSCTransport.prototype.emitObject = function (eventObject, options) {\\r\\n  var simpleEventObject = {\\r\\n    event: eventObject.event,\\r\\n    data: eventObject.data\\r\\n  };\\r\\n\\r\\n  if (eventObject.callback) {\\r\\n    simpleEventObject.cid = eventObject.cid = this.callIdGenerator();\\r\\n    this._callbackMap[eventObject.cid] = eventObject;\\r\\n  }\\r\\n\\r\\n  this.sendObject(simpleEventObject, options);\\r\\n\\r\\n  return eventObject.cid || null;\\r\\n};\\r\\n\\r\\nSCTransport.prototype._handleEventAckTimeout = function (eventObject) {\\r\\n  if (eventObject.cid) {\\r\\n    delete this._callbackMap[eventObject.cid];\\r\\n  }\\r\\n  delete eventObject.timeout;\\r\\n\\r\\n  var callback = eventObject.callback;\\r\\n  if (callback) {\\r\\n    delete eventObject.callback;\\r\\n    var error = new TimeoutError(\\\"Event response for '\\\" + eventObject.event + \\\"' timed out\\\");\\r\\n    callback.call(eventObject, error, eventObject);\\r\\n  }\\r\\n};\\r\\n\\r\\n// The last two optional arguments (a and b) can be options and/or callback\\r\\nSCTransport.prototype.emit = function (event, data, a, b) {\\r\\n  var self = this;\\r\\n\\r\\n  var callback, options;\\r\\n\\r\\n  if (b) {\\r\\n    options = a;\\r\\n    callback = b;\\r\\n  } else {\\r\\n    if (a instanceof Function) {\\r\\n      options = {};\\r\\n      callback = a;\\r\\n    } else {\\r\\n      options = a;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var eventObject = {\\r\\n    event: event,\\r\\n    data: data,\\r\\n    callback: callback\\r\\n  };\\r\\n\\r\\n  if (callback && !options.noTimeout) {\\r\\n    eventObject.timeout = setTimeout(function () {\\r\\n      self._handleEventAckTimeout(eventObject);\\r\\n    }, this.options.ackTimeout);\\r\\n  }\\r\\n\\r\\n  var cid = null;\\r\\n  if (this.state === this.OPEN || options.force) {\\r\\n    cid = this.emitObject(eventObject, options);\\r\\n  }\\r\\n  return cid;\\r\\n};\\r\\n\\r\\nSCTransport.prototype.cancelPendingResponse = function (cid) {\\r\\n  delete this._callbackMap[cid];\\r\\n};\\r\\n\\r\\nSCTransport.prototype.decode = function (message) {\\r\\n  return this.codec.decode(message);\\r\\n};\\r\\n\\r\\nSCTransport.prototype.encode = function (object) {\\r\\n  return this.codec.encode(object);\\r\\n};\\r\\n\\r\\nSCTransport.prototype.send = function (data) {\\r\\n  if (this.socket.readyState !== this.socket.OPEN) {\\r\\n    this._onClose(1005);\\r\\n  } else {\\r\\n    this.socket.send(data);\\r\\n  }\\r\\n};\\r\\n\\r\\nSCTransport.prototype.serializeObject = function (object) {\\r\\n  var str, formatError;\\r\\n  try {\\r\\n    str = this.encode(object);\\r\\n  } catch (err) {\\r\\n    formatError = err;\\r\\n    this._onError(formatError);\\r\\n  }\\r\\n  if (!formatError) {\\r\\n    return str;\\r\\n  }\\r\\n  return null;\\r\\n};\\r\\n\\r\\nSCTransport.prototype.sendObjectBatch = function (object) {\\r\\n  var self = this;\\r\\n\\r\\n  this._batchSendList.push(object);\\r\\n  if (this._batchTimeout) {\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  this._batchTimeout = setTimeout(function () {\\r\\n    delete self._batchTimeout;\\r\\n    if (self._batchSendList.length) {\\r\\n      var str = self.serializeObject(self._batchSendList);\\r\\n      if (str != null) {\\r\\n        self.send(str);\\r\\n      }\\r\\n      self._batchSendList = [];\\r\\n    }\\r\\n  }, this.options.pubSubBatchDuration || 0);\\r\\n};\\r\\n\\r\\nSCTransport.prototype.sendObjectSingle = function (object) {\\r\\n  var str = this.serializeObject(object);\\r\\n  if (str != null) {\\r\\n    this.send(str);\\r\\n  }\\r\\n};\\r\\n\\r\\nSCTransport.prototype.sendObject = function (object, options) {\\r\\n  if (options && options.batch) {\\r\\n    this.sendObjectBatch(object);\\r\\n  } else {\\r\\n    this.sendObjectSingle(object);\\r\\n  }\\r\\n};\\r\\n\\r\\nmodule.exports.SCTransport = SCTransport;\\r\\n\\r\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n},{\\\"./response\\\":4,\\\"component-emitter\\\":11,\\\"querystring\\\":17,\\\"sc-errors\\\":20,\\\"ws\\\":7}],7:[function(_dereq_,module,exports){\\r\\nvar global;\\r\\nif (typeof WorkerGlobalScope !== 'undefined') {\\r\\n  global = self;\\r\\n} else {\\r\\n  global = typeof window !== 'undefined' && window || (function() { return this; })();\\r\\n}\\r\\n\\r\\nvar WebSocket = global.WebSocket || global.MozWebSocket;\\r\\n\\r\\n/**\\r\\n * WebSocket constructor.\\r\\n *\\r\\n * The third `opts` options object gets ignored in web browsers, since it's\\r\\n * non-standard, and throws a TypeError if passed to the constructor.\\r\\n * See: https://github.com/einaros/ws/issues/227\\r\\n *\\r\\n * @param {String} uri\\r\\n * @param {Array} protocols (optional)\\r\\n * @param {Object} opts (optional)\\r\\n * @api public\\r\\n */\\r\\n\\r\\nfunction ws(uri, protocols, opts) {\\r\\n  var instance;\\r\\n  if (protocols) {\\r\\n    instance = new WebSocket(uri, protocols);\\r\\n  } else {\\r\\n    instance = new WebSocket(uri);\\r\\n  }\\r\\n  return instance;\\r\\n}\\r\\n\\r\\nif (WebSocket) ws.prototype = WebSocket.prototype;\\r\\n\\r\\nmodule.exports = WebSocket ? ws : null;\\r\\n\\r\\n},{}],8:[function(_dereq_,module,exports){\\r\\n'use strict'\\r\\n\\r\\nexports.byteLength = byteLength\\r\\nexports.toByteArray = toByteArray\\r\\nexports.fromByteArray = fromByteArray\\r\\n\\r\\nvar lookup = []\\r\\nvar revLookup = []\\r\\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\\r\\n\\r\\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\\r\\nfor (var i = 0, len = code.length; i < len; ++i) {\\r\\n  lookup[i] = code[i]\\r\\n  revLookup[code.charCodeAt(i)] = i\\r\\n}\\r\\n\\r\\n// Support decoding URL-safe base64 strings, as Node.js does.\\r\\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\\r\\nrevLookup['-'.charCodeAt(0)] = 62\\r\\nrevLookup['_'.charCodeAt(0)] = 63\\r\\n\\r\\nfunction getLens (b64) {\\r\\n  var len = b64.length\\r\\n\\r\\n  if (len % 4 > 0) {\\r\\n    throw new Error('Invalid string. Length must be a multiple of 4')\\r\\n  }\\r\\n\\r\\n  // Trim off extra bytes after placeholder bytes are found\\r\\n  // See: https://github.com/beatgammit/base64-js/issues/42\\r\\n  var validLen = b64.indexOf('=')\\r\\n  if (validLen === -1) validLen = len\\r\\n\\r\\n  var placeHoldersLen = validLen === len\\r\\n    ? 0\\r\\n    : 4 - (validLen % 4)\\r\\n\\r\\n  return [validLen, placeHoldersLen]\\r\\n}\\r\\n\\r\\n// base64 is 4/3 + up to two characters of the original data\\r\\nfunction byteLength (b64) {\\r\\n  var lens = getLens(b64)\\r\\n  var validLen = lens[0]\\r\\n  var placeHoldersLen = lens[1]\\r\\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\\r\\n}\\r\\n\\r\\nfunction _byteLength (b64, validLen, placeHoldersLen) {\\r\\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\\r\\n}\\r\\n\\r\\nfunction toByteArray (b64) {\\r\\n  var tmp\\r\\n  var lens = getLens(b64)\\r\\n  var validLen = lens[0]\\r\\n  var placeHoldersLen = lens[1]\\r\\n\\r\\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\\r\\n\\r\\n  var curByte = 0\\r\\n\\r\\n  // if there are placeholders, only get up to the last complete 4 chars\\r\\n  var len = placeHoldersLen > 0\\r\\n    ? validLen - 4\\r\\n    : validLen\\r\\n\\r\\n  for (var i = 0; i < len; i += 4) {\\r\\n    tmp =\\r\\n      (revLookup[b64.charCodeAt(i)] << 18) |\\r\\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\\r\\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\\r\\n      revLookup[b64.charCodeAt(i + 3)]\\r\\n    arr[curByte++] = (tmp >> 16) & 0xFF\\r\\n    arr[curByte++] = (tmp >> 8) & 0xFF\\r\\n    arr[curByte++] = tmp & 0xFF\\r\\n  }\\r\\n\\r\\n  if (placeHoldersLen === 2) {\\r\\n    tmp =\\r\\n      (revLookup[b64.charCodeAt(i)] << 2) |\\r\\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\\r\\n    arr[curByte++] = tmp & 0xFF\\r\\n  }\\r\\n\\r\\n  if (placeHoldersLen === 1) {\\r\\n    tmp =\\r\\n      (revLookup[b64.charCodeAt(i)] << 10) |\\r\\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\\r\\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\\r\\n    arr[curByte++] = (tmp >> 8) & 0xFF\\r\\n    arr[curByte++] = tmp & 0xFF\\r\\n  }\\r\\n\\r\\n  return arr\\r\\n}\\r\\n\\r\\nfunction tripletToBase64 (num) {\\r\\n  return lookup[num >> 18 & 0x3F] +\\r\\n    lookup[num >> 12 & 0x3F] +\\r\\n    lookup[num >> 6 & 0x3F] +\\r\\n    lookup[num & 0x3F]\\r\\n}\\r\\n\\r\\nfunction encodeChunk (uint8, start, end) {\\r\\n  var tmp\\r\\n  var output = []\\r\\n  for (var i = start; i < end; i += 3) {\\r\\n    tmp =\\r\\n      ((uint8[i] << 16) & 0xFF0000) +\\r\\n      ((uint8[i + 1] << 8) & 0xFF00) +\\r\\n      (uint8[i + 2] & 0xFF)\\r\\n    output.push(tripletToBase64(tmp))\\r\\n  }\\r\\n  return output.join('')\\r\\n}\\r\\n\\r\\nfunction fromByteArray (uint8) {\\r\\n  var tmp\\r\\n  var len = uint8.length\\r\\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\\r\\n  var parts = []\\r\\n  var maxChunkLength = 16383 // must be multiple of 3\\r\\n\\r\\n  // go through the array every three bytes, we'll deal with trailing stuff later\\r\\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\\r\\n    parts.push(encodeChunk(\\r\\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\\r\\n    ))\\r\\n  }\\r\\n\\r\\n  // pad the end with zeros, but make sure to not forget the extra bytes\\r\\n  if (extraBytes === 1) {\\r\\n    tmp = uint8[len - 1]\\r\\n    parts.push(\\r\\n      lookup[tmp >> 2] +\\r\\n      lookup[(tmp << 4) & 0x3F] +\\r\\n      '=='\\r\\n    )\\r\\n  } else if (extraBytes === 2) {\\r\\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\\r\\n    parts.push(\\r\\n      lookup[tmp >> 10] +\\r\\n      lookup[(tmp >> 4) & 0x3F] +\\r\\n      lookup[(tmp << 2) & 0x3F] +\\r\\n      '='\\r\\n    )\\r\\n  }\\r\\n\\r\\n  return parts.join('')\\r\\n}\\r\\n\\r\\n},{}],9:[function(_dereq_,module,exports){\\r\\n(function (Buffer){\\r\\n/*!\\r\\n * The buffer module from node.js, for the browser.\\r\\n *\\r\\n * @author   Feross Aboukhadijeh <https://feross.org>\\r\\n * @license  MIT\\r\\n */\\r\\n/* eslint-disable no-proto */\\r\\n\\r\\n'use strict'\\r\\n\\r\\nvar base64 = _dereq_('base64-js')\\r\\nvar ieee754 = _dereq_('ieee754')\\r\\n\\r\\nexports.Buffer = Buffer\\r\\nexports.SlowBuffer = SlowBuffer\\r\\nexports.INSPECT_MAX_BYTES = 50\\r\\n\\r\\nvar K_MAX_LENGTH = 0x7fffffff\\r\\nexports.kMaxLength = K_MAX_LENGTH\\r\\n\\r\\n/**\\r\\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\\r\\n *   === true    Use Uint8Array implementation (fastest)\\r\\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\\r\\n *               implementation (most compatible, even IE6)\\r\\n *\\r\\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\\r\\n * Opera 11.6+, iOS 4.2+.\\r\\n *\\r\\n * We report that the browser does not support typed arrays if the are not subclassable\\r\\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\\r\\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\\r\\n * for __proto__ and has a buggy typed array implementation.\\r\\n */\\r\\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\\r\\n\\r\\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\\r\\n    typeof console.error === 'function') {\\r\\n  console.error(\\r\\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\\r\\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction typedArraySupport () {\\r\\n  // Can typed array instances can be augmented?\\r\\n  try {\\r\\n    var arr = new Uint8Array(1)\\r\\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }\\r\\n    return arr.foo() === 42\\r\\n  } catch (e) {\\r\\n    return false\\r\\n  }\\r\\n}\\r\\n\\r\\nObject.defineProperty(Buffer.prototype, 'parent', {\\r\\n  enumerable: true,\\r\\n  get: function () {\\r\\n    if (!Buffer.isBuffer(this)) return undefined\\r\\n    return this.buffer\\r\\n  }\\r\\n})\\r\\n\\r\\nObject.defineProperty(Buffer.prototype, 'offset', {\\r\\n  enumerable: true,\\r\\n  get: function () {\\r\\n    if (!Buffer.isBuffer(this)) return undefined\\r\\n    return this.byteOffset\\r\\n  }\\r\\n})\\r\\n\\r\\nfunction createBuffer (length) {\\r\\n  if (length > K_MAX_LENGTH) {\\r\\n    throw new RangeError('The value \\\"' + length + '\\\" is invalid for option \\\"size\\\"')\\r\\n  }\\r\\n  // Return an augmented `Uint8Array` instance\\r\\n  var buf = new Uint8Array(length)\\r\\n  buf.__proto__ = Buffer.prototype\\r\\n  return buf\\r\\n}\\r\\n\\r\\n/**\\r\\n * The Buffer constructor returns instances of `Uint8Array` that have their\\r\\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\\r\\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\\r\\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\\r\\n * returns a single octet.\\r\\n *\\r\\n * The `Uint8Array` prototype remains unmodified.\\r\\n */\\r\\n\\r\\nfunction Buffer (arg, encodingOrOffset, length) {\\r\\n  // Common case.\\r\\n  if (typeof arg === 'number') {\\r\\n    if (typeof encodingOrOffset === 'string') {\\r\\n      throw new TypeError(\\r\\n        'The \\\"string\\\" argument must be of type string. Received type number'\\r\\n      )\\r\\n    }\\r\\n    return allocUnsafe(arg)\\r\\n  }\\r\\n  return from(arg, encodingOrOffset, length)\\r\\n}\\r\\n\\r\\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\\r\\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\\r\\n    Buffer[Symbol.species] === Buffer) {\\r\\n  Object.defineProperty(Buffer, Symbol.species, {\\r\\n    value: null,\\r\\n    configurable: true,\\r\\n    enumerable: false,\\r\\n    writable: false\\r\\n  })\\r\\n}\\r\\n\\r\\nBuffer.poolSize = 8192 // not used by this implementation\\r\\n\\r\\nfunction from (value, encodingOrOffset, length) {\\r\\n  if (typeof value === 'string') {\\r\\n    return fromString(value, encodingOrOffset)\\r\\n  }\\r\\n\\r\\n  if (ArrayBuffer.isView(value)) {\\r\\n    return fromArrayLike(value)\\r\\n  }\\r\\n\\r\\n  if (value == null) {\\r\\n    throw TypeError(\\r\\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\\r\\n      'or Array-like Object. Received type ' + (typeof value)\\r\\n    )\\r\\n  }\\r\\n\\r\\n  if (isInstance(value, ArrayBuffer) ||\\r\\n      (value && isInstance(value.buffer, ArrayBuffer))) {\\r\\n    return fromArrayBuffer(value, encodingOrOffset, length)\\r\\n  }\\r\\n\\r\\n  if (typeof value === 'number') {\\r\\n    throw new TypeError(\\r\\n      'The \\\"value\\\" argument must not be of type number. Received type number'\\r\\n    )\\r\\n  }\\r\\n\\r\\n  var valueOf = value.valueOf && value.valueOf()\\r\\n  if (valueOf != null && valueOf !== value) {\\r\\n    return Buffer.from(valueOf, encodingOrOffset, length)\\r\\n  }\\r\\n\\r\\n  var b = fromObject(value)\\r\\n  if (b) return b\\r\\n\\r\\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\\r\\n      typeof value[Symbol.toPrimitive] === 'function') {\\r\\n    return Buffer.from(\\r\\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\\r\\n    )\\r\\n  }\\r\\n\\r\\n  throw new TypeError(\\r\\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\\r\\n    'or Array-like Object. Received type ' + (typeof value)\\r\\n  )\\r\\n}\\r\\n\\r\\n/**\\r\\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\\r\\n * if value is a number.\\r\\n * Buffer.from(str[, encoding])\\r\\n * Buffer.from(array)\\r\\n * Buffer.from(buffer)\\r\\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\\r\\n **/\\r\\nBuffer.from = function (value, encodingOrOffset, length) {\\r\\n  return from(value, encodingOrOffset, length)\\r\\n}\\r\\n\\r\\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\\r\\n// https://github.com/feross/buffer/pull/148\\r\\nBuffer.prototype.__proto__ = Uint8Array.prototype\\r\\nBuffer.__proto__ = Uint8Array\\r\\n\\r\\nfunction assertSize (size) {\\r\\n  if (typeof size !== 'number') {\\r\\n    throw new TypeError('\\\"size\\\" argument must be of type number')\\r\\n  } else if (size < 0) {\\r\\n    throw new RangeError('The value \\\"' + size + '\\\" is invalid for option \\\"size\\\"')\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction alloc (size, fill, encoding) {\\r\\n  assertSize(size)\\r\\n  if (size <= 0) {\\r\\n    return createBuffer(size)\\r\\n  }\\r\\n  if (fill !== undefined) {\\r\\n    // Only pay attention to encoding if it's a string. This\\r\\n    // prevents accidentally sending in a number that would\\r\\n    // be interpretted as a start offset.\\r\\n    return typeof encoding === 'string'\\r\\n      ? createBuffer(size).fill(fill, encoding)\\r\\n      : createBuffer(size).fill(fill)\\r\\n  }\\r\\n  return createBuffer(size)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a new filled Buffer instance.\\r\\n * alloc(size[, fill[, encoding]])\\r\\n **/\\r\\nBuffer.alloc = function (size, fill, encoding) {\\r\\n  return alloc(size, fill, encoding)\\r\\n}\\r\\n\\r\\nfunction allocUnsafe (size) {\\r\\n  assertSize(size)\\r\\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\\r\\n * */\\r\\nBuffer.allocUnsafe = function (size) {\\r\\n  return allocUnsafe(size)\\r\\n}\\r\\n/**\\r\\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\\r\\n */\\r\\nBuffer.allocUnsafeSlow = function (size) {\\r\\n  return allocUnsafe(size)\\r\\n}\\r\\n\\r\\nfunction fromString (string, encoding) {\\r\\n  if (typeof encoding !== 'string' || encoding === '') {\\r\\n    encoding = 'utf8'\\r\\n  }\\r\\n\\r\\n  if (!Buffer.isEncoding(encoding)) {\\r\\n    throw new TypeError('Unknown encoding: ' + encoding)\\r\\n  }\\r\\n\\r\\n  var length = byteLength(string, encoding) | 0\\r\\n  var buf = createBuffer(length)\\r\\n\\r\\n  var actual = buf.write(string, encoding)\\r\\n\\r\\n  if (actual !== length) {\\r\\n    // Writing a hex string, for example, that contains invalid characters will\\r\\n    // cause everything after the first invalid character to be ignored. (e.g.\\r\\n    // 'abxxcd' will be treated as 'ab')\\r\\n    buf = buf.slice(0, actual)\\r\\n  }\\r\\n\\r\\n  return buf\\r\\n}\\r\\n\\r\\nfunction fromArrayLike (array) {\\r\\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\\r\\n  var buf = createBuffer(length)\\r\\n  for (var i = 0; i < length; i += 1) {\\r\\n    buf[i] = array[i] & 255\\r\\n  }\\r\\n  return buf\\r\\n}\\r\\n\\r\\nfunction fromArrayBuffer (array, byteOffset, length) {\\r\\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\\r\\n    throw new RangeError('\\\"offset\\\" is outside of buffer bounds')\\r\\n  }\\r\\n\\r\\n  if (array.byteLength < byteOffset + (length || 0)) {\\r\\n    throw new RangeError('\\\"length\\\" is outside of buffer bounds')\\r\\n  }\\r\\n\\r\\n  var buf\\r\\n  if (byteOffset === undefined && length === undefined) {\\r\\n    buf = new Uint8Array(array)\\r\\n  } else if (length === undefined) {\\r\\n    buf = new Uint8Array(array, byteOffset)\\r\\n  } else {\\r\\n    buf = new Uint8Array(array, byteOffset, length)\\r\\n  }\\r\\n\\r\\n  // Return an augmented `Uint8Array` instance\\r\\n  buf.__proto__ = Buffer.prototype\\r\\n  return buf\\r\\n}\\r\\n\\r\\nfunction fromObject (obj) {\\r\\n  if (Buffer.isBuffer(obj)) {\\r\\n    var len = checked(obj.length) | 0\\r\\n    var buf = createBuffer(len)\\r\\n\\r\\n    if (buf.length === 0) {\\r\\n      return buf\\r\\n    }\\r\\n\\r\\n    obj.copy(buf, 0, 0, len)\\r\\n    return buf\\r\\n  }\\r\\n\\r\\n  if (obj.length !== undefined) {\\r\\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\\r\\n      return createBuffer(0)\\r\\n    }\\r\\n    return fromArrayLike(obj)\\r\\n  }\\r\\n\\r\\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\\r\\n    return fromArrayLike(obj.data)\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction checked (length) {\\r\\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\\r\\n  // length is NaN (which is otherwise coerced to zero.)\\r\\n  if (length >= K_MAX_LENGTH) {\\r\\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\\r\\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\\r\\n  }\\r\\n  return length | 0\\r\\n}\\r\\n\\r\\nfunction SlowBuffer (length) {\\r\\n  if (+length != length) { // eslint-disable-line eqeqeq\\r\\n    length = 0\\r\\n  }\\r\\n  return Buffer.alloc(+length)\\r\\n}\\r\\n\\r\\nBuffer.isBuffer = function isBuffer (b) {\\r\\n  return b != null && b._isBuffer === true &&\\r\\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\\r\\n}\\r\\n\\r\\nBuffer.compare = function compare (a, b) {\\r\\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\\r\\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\\r\\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\\r\\n    throw new TypeError(\\r\\n      'The \\\"buf1\\\", \\\"buf2\\\" arguments must be one of type Buffer or Uint8Array'\\r\\n    )\\r\\n  }\\r\\n\\r\\n  if (a === b) return 0\\r\\n\\r\\n  var x = a.length\\r\\n  var y = b.length\\r\\n\\r\\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\\r\\n    if (a[i] !== b[i]) {\\r\\n      x = a[i]\\r\\n      y = b[i]\\r\\n      break\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (x < y) return -1\\r\\n  if (y < x) return 1\\r\\n  return 0\\r\\n}\\r\\n\\r\\nBuffer.isEncoding = function isEncoding (encoding) {\\r\\n  switch (String(encoding).toLowerCase()) {\\r\\n    case 'hex':\\r\\n    case 'utf8':\\r\\n    case 'utf-8':\\r\\n    case 'ascii':\\r\\n    case 'latin1':\\r\\n    case 'binary':\\r\\n    case 'base64':\\r\\n    case 'ucs2':\\r\\n    case 'ucs-2':\\r\\n    case 'utf16le':\\r\\n    case 'utf-16le':\\r\\n      return true\\r\\n    default:\\r\\n      return false\\r\\n  }\\r\\n}\\r\\n\\r\\nBuffer.concat = function concat (list, length) {\\r\\n  if (!Array.isArray(list)) {\\r\\n    throw new TypeError('\\\"list\\\" argument must be an Array of Buffers')\\r\\n  }\\r\\n\\r\\n  if (list.length === 0) {\\r\\n    return Buffer.alloc(0)\\r\\n  }\\r\\n\\r\\n  var i\\r\\n  if (length === undefined) {\\r\\n    length = 0\\r\\n    for (i = 0; i < list.length; ++i) {\\r\\n      length += list[i].length\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var buffer = Buffer.allocUnsafe(length)\\r\\n  var pos = 0\\r\\n  for (i = 0; i < list.length; ++i) {\\r\\n    var buf = list[i]\\r\\n    if (isInstance(buf, Uint8Array)) {\\r\\n      buf = Buffer.from(buf)\\r\\n    }\\r\\n    if (!Buffer.isBuffer(buf)) {\\r\\n      throw new TypeError('\\\"list\\\" argument must be an Array of Buffers')\\r\\n    }\\r\\n    buf.copy(buffer, pos)\\r\\n    pos += buf.length\\r\\n  }\\r\\n  return buffer\\r\\n}\\r\\n\\r\\nfunction byteLength (string, encoding) {\\r\\n  if (Buffer.isBuffer(string)) {\\r\\n    return string.length\\r\\n  }\\r\\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\\r\\n    return string.byteLength\\r\\n  }\\r\\n  if (typeof string !== 'string') {\\r\\n    throw new TypeError(\\r\\n      'The \\\"string\\\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\\r\\n      'Received type ' + typeof string\\r\\n    )\\r\\n  }\\r\\n\\r\\n  var len = string.length\\r\\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\\r\\n  if (!mustMatch && len === 0) return 0\\r\\n\\r\\n  // Use a for loop to avoid recursion\\r\\n  var loweredCase = false\\r\\n  for (;;) {\\r\\n    switch (encoding) {\\r\\n      case 'ascii':\\r\\n      case 'latin1':\\r\\n      case 'binary':\\r\\n        return len\\r\\n      case 'utf8':\\r\\n      case 'utf-8':\\r\\n        return utf8ToBytes(string).length\\r\\n      case 'ucs2':\\r\\n      case 'ucs-2':\\r\\n      case 'utf16le':\\r\\n      case 'utf-16le':\\r\\n        return len * 2\\r\\n      case 'hex':\\r\\n        return len >>> 1\\r\\n      case 'base64':\\r\\n        return base64ToBytes(string).length\\r\\n      default:\\r\\n        if (loweredCase) {\\r\\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\\r\\n        }\\r\\n        encoding = ('' + encoding).toLowerCase()\\r\\n        loweredCase = true\\r\\n    }\\r\\n  }\\r\\n}\\r\\nBuffer.byteLength = byteLength\\r\\n\\r\\nfunction slowToString (encoding, start, end) {\\r\\n  var loweredCase = false\\r\\n\\r\\n  // No need to verify that \\\"this.length <= MAX_UINT32\\\" since it's a read-only\\r\\n  // property of a typed array.\\r\\n\\r\\n  // This behaves neither like String nor Uint8Array in that we set start/end\\r\\n  // to their upper/lower bounds if the value passed is out of range.\\r\\n  // undefined is handled specially as per ECMA-262 6th Edition,\\r\\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\\r\\n  if (start === undefined || start < 0) {\\r\\n    start = 0\\r\\n  }\\r\\n  // Return early if start > this.length. Done here to prevent potential uint32\\r\\n  // coercion fail below.\\r\\n  if (start > this.length) {\\r\\n    return ''\\r\\n  }\\r\\n\\r\\n  if (end === undefined || end > this.length) {\\r\\n    end = this.length\\r\\n  }\\r\\n\\r\\n  if (end <= 0) {\\r\\n    return ''\\r\\n  }\\r\\n\\r\\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\\r\\n  end >>>= 0\\r\\n  start >>>= 0\\r\\n\\r\\n  if (end <= start) {\\r\\n    return ''\\r\\n  }\\r\\n\\r\\n  if (!encoding) encoding = 'utf8'\\r\\n\\r\\n  while (true) {\\r\\n    switch (encoding) {\\r\\n      case 'hex':\\r\\n        return hexSlice(this, start, end)\\r\\n\\r\\n      case 'utf8':\\r\\n      case 'utf-8':\\r\\n        return utf8Slice(this, start, end)\\r\\n\\r\\n      case 'ascii':\\r\\n        return asciiSlice(this, start, end)\\r\\n\\r\\n      case 'latin1':\\r\\n      case 'binary':\\r\\n        return latin1Slice(this, start, end)\\r\\n\\r\\n      case 'base64':\\r\\n        return base64Slice(this, start, end)\\r\\n\\r\\n      case 'ucs2':\\r\\n      case 'ucs-2':\\r\\n      case 'utf16le':\\r\\n      case 'utf-16le':\\r\\n        return utf16leSlice(this, start, end)\\r\\n\\r\\n      default:\\r\\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\\r\\n        encoding = (encoding + '').toLowerCase()\\r\\n        loweredCase = true\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\\r\\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\\r\\n// reliably in a browserify context because there could be multiple different\\r\\n// copies of the 'buffer' package in use. This method works even for Buffer\\r\\n// instances that were created from another copy of the `buffer` package.\\r\\n// See: https://github.com/feross/buffer/issues/154\\r\\nBuffer.prototype._isBuffer = true\\r\\n\\r\\nfunction swap (b, n, m) {\\r\\n  var i = b[n]\\r\\n  b[n] = b[m]\\r\\n  b[m] = i\\r\\n}\\r\\n\\r\\nBuffer.prototype.swap16 = function swap16 () {\\r\\n  var len = this.length\\r\\n  if (len % 2 !== 0) {\\r\\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\\r\\n  }\\r\\n  for (var i = 0; i < len; i += 2) {\\r\\n    swap(this, i, i + 1)\\r\\n  }\\r\\n  return this\\r\\n}\\r\\n\\r\\nBuffer.prototype.swap32 = function swap32 () {\\r\\n  var len = this.length\\r\\n  if (len % 4 !== 0) {\\r\\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\\r\\n  }\\r\\n  for (var i = 0; i < len; i += 4) {\\r\\n    swap(this, i, i + 3)\\r\\n    swap(this, i + 1, i + 2)\\r\\n  }\\r\\n  return this\\r\\n}\\r\\n\\r\\nBuffer.prototype.swap64 = function swap64 () {\\r\\n  var len = this.length\\r\\n  if (len % 8 !== 0) {\\r\\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\\r\\n  }\\r\\n  for (var i = 0; i < len; i += 8) {\\r\\n    swap(this, i, i + 7)\\r\\n    swap(this, i + 1, i + 6)\\r\\n    swap(this, i + 2, i + 5)\\r\\n    swap(this, i + 3, i + 4)\\r\\n  }\\r\\n  return this\\r\\n}\\r\\n\\r\\nBuffer.prototype.toString = function toString () {\\r\\n  var length = this.length\\r\\n  if (length === 0) return ''\\r\\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\\r\\n  return slowToString.apply(this, arguments)\\r\\n}\\r\\n\\r\\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\\r\\n\\r\\nBuffer.prototype.equals = function equals (b) {\\r\\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\\r\\n  if (this === b) return true\\r\\n  return Buffer.compare(this, b) === 0\\r\\n}\\r\\n\\r\\nBuffer.prototype.inspect = function inspect () {\\r\\n  var str = ''\\r\\n  var max = exports.INSPECT_MAX_BYTES\\r\\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\\r\\n  if (this.length > max) str += ' ... '\\r\\n  return '<Buffer ' + str + '>'\\r\\n}\\r\\n\\r\\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\\r\\n  if (isInstance(target, Uint8Array)) {\\r\\n    target = Buffer.from(target, target.offset, target.byteLength)\\r\\n  }\\r\\n  if (!Buffer.isBuffer(target)) {\\r\\n    throw new TypeError(\\r\\n      'The \\\"target\\\" argument must be one of type Buffer or Uint8Array. ' +\\r\\n      'Received type ' + (typeof target)\\r\\n    )\\r\\n  }\\r\\n\\r\\n  if (start === undefined) {\\r\\n    start = 0\\r\\n  }\\r\\n  if (end === undefined) {\\r\\n    end = target ? target.length : 0\\r\\n  }\\r\\n  if (thisStart === undefined) {\\r\\n    thisStart = 0\\r\\n  }\\r\\n  if (thisEnd === undefined) {\\r\\n    thisEnd = this.length\\r\\n  }\\r\\n\\r\\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\\r\\n    throw new RangeError('out of range index')\\r\\n  }\\r\\n\\r\\n  if (thisStart >= thisEnd && start >= end) {\\r\\n    return 0\\r\\n  }\\r\\n  if (thisStart >= thisEnd) {\\r\\n    return -1\\r\\n  }\\r\\n  if (start >= end) {\\r\\n    return 1\\r\\n  }\\r\\n\\r\\n  start >>>= 0\\r\\n  end >>>= 0\\r\\n  thisStart >>>= 0\\r\\n  thisEnd >>>= 0\\r\\n\\r\\n  if (this === target) return 0\\r\\n\\r\\n  var x = thisEnd - thisStart\\r\\n  var y = end - start\\r\\n  var len = Math.min(x, y)\\r\\n\\r\\n  var thisCopy = this.slice(thisStart, thisEnd)\\r\\n  var targetCopy = target.slice(start, end)\\r\\n\\r\\n  for (var i = 0; i < len; ++i) {\\r\\n    if (thisCopy[i] !== targetCopy[i]) {\\r\\n      x = thisCopy[i]\\r\\n      y = targetCopy[i]\\r\\n      break\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (x < y) return -1\\r\\n  if (y < x) return 1\\r\\n  return 0\\r\\n}\\r\\n\\r\\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\\r\\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\\r\\n//\\r\\n// Arguments:\\r\\n// - buffer - a Buffer to search\\r\\n// - val - a string, Buffer, or number\\r\\n// - byteOffset - an index into `buffer`; will be clamped to an int32\\r\\n// - encoding - an optional encoding, relevant is val is a string\\r\\n// - dir - true for indexOf, false for lastIndexOf\\r\\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\\r\\n  // Empty buffer means no match\\r\\n  if (buffer.length === 0) return -1\\r\\n\\r\\n  // Normalize byteOffset\\r\\n  if (typeof byteOffset === 'string') {\\r\\n    encoding = byteOffset\\r\\n    byteOffset = 0\\r\\n  } else if (byteOffset > 0x7fffffff) {\\r\\n    byteOffset = 0x7fffffff\\r\\n  } else if (byteOffset < -0x80000000) {\\r\\n    byteOffset = -0x80000000\\r\\n  }\\r\\n  byteOffset = +byteOffset // Coerce to Number.\\r\\n  if (numberIsNaN(byteOffset)) {\\r\\n    // byteOffset: it it's undefined, null, NaN, \\\"foo\\\", etc, search whole buffer\\r\\n    byteOffset = dir ? 0 : (buffer.length - 1)\\r\\n  }\\r\\n\\r\\n  // Normalize byteOffset: negative offsets start from the end of the buffer\\r\\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\\r\\n  if (byteOffset >= buffer.length) {\\r\\n    if (dir) return -1\\r\\n    else byteOffset = buffer.length - 1\\r\\n  } else if (byteOffset < 0) {\\r\\n    if (dir) byteOffset = 0\\r\\n    else return -1\\r\\n  }\\r\\n\\r\\n  // Normalize val\\r\\n  if (typeof val === 'string') {\\r\\n    val = Buffer.from(val, encoding)\\r\\n  }\\r\\n\\r\\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\\r\\n  if (Buffer.isBuffer(val)) {\\r\\n    // Special case: looking for empty string/buffer always fails\\r\\n    if (val.length === 0) {\\r\\n      return -1\\r\\n    }\\r\\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\\r\\n  } else if (typeof val === 'number') {\\r\\n    val = val & 0xFF // Search for a byte value [0-255]\\r\\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\\r\\n      if (dir) {\\r\\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\\r\\n      } else {\\r\\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\\r\\n      }\\r\\n    }\\r\\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\\r\\n  }\\r\\n\\r\\n  throw new TypeError('val must be string, number or Buffer')\\r\\n}\\r\\n\\r\\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\\r\\n  var indexSize = 1\\r\\n  var arrLength = arr.length\\r\\n  var valLength = val.length\\r\\n\\r\\n  if (encoding !== undefined) {\\r\\n    encoding = String(encoding).toLowerCase()\\r\\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\\r\\n        encoding === 'utf16le' || encoding === 'utf-16le') {\\r\\n      if (arr.length < 2 || val.length < 2) {\\r\\n        return -1\\r\\n      }\\r\\n      indexSize = 2\\r\\n      arrLength /= 2\\r\\n      valLength /= 2\\r\\n      byteOffset /= 2\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function read (buf, i) {\\r\\n    if (indexSize === 1) {\\r\\n      return buf[i]\\r\\n    } else {\\r\\n      return buf.readUInt16BE(i * indexSize)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var i\\r\\n  if (dir) {\\r\\n    var foundIndex = -1\\r\\n    for (i = byteOffset; i < arrLength; i++) {\\r\\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\\r\\n        if (foundIndex === -1) foundIndex = i\\r\\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\\r\\n      } else {\\r\\n        if (foundIndex !== -1) i -= i - foundIndex\\r\\n        foundIndex = -1\\r\\n      }\\r\\n    }\\r\\n  } else {\\r\\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\\r\\n    for (i = byteOffset; i >= 0; i--) {\\r\\n      var found = true\\r\\n      for (var j = 0; j < valLength; j++) {\\r\\n        if (read(arr, i + j) !== read(val, j)) {\\r\\n          found = false\\r\\n          break\\r\\n        }\\r\\n      }\\r\\n      if (found) return i\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return -1\\r\\n}\\r\\n\\r\\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\\r\\n  return this.indexOf(val, byteOffset, encoding) !== -1\\r\\n}\\r\\n\\r\\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\\r\\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\\r\\n}\\r\\n\\r\\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\\r\\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\\r\\n}\\r\\n\\r\\nfunction hexWrite (buf, string, offset, length) {\\r\\n  offset = Number(offset) || 0\\r\\n  var remaining = buf.length - offset\\r\\n  if (!length) {\\r\\n    length = remaining\\r\\n  } else {\\r\\n    length = Number(length)\\r\\n    if (length > remaining) {\\r\\n      length = remaining\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var strLen = string.length\\r\\n\\r\\n  if (length > strLen / 2) {\\r\\n    length = strLen / 2\\r\\n  }\\r\\n  for (var i = 0; i < length; ++i) {\\r\\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\\r\\n    if (numberIsNaN(parsed)) return i\\r\\n    buf[offset + i] = parsed\\r\\n  }\\r\\n  return i\\r\\n}\\r\\n\\r\\nfunction utf8Write (buf, string, offset, length) {\\r\\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\\r\\n}\\r\\n\\r\\nfunction asciiWrite (buf, string, offset, length) {\\r\\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\\r\\n}\\r\\n\\r\\nfunction latin1Write (buf, string, offset, length) {\\r\\n  return asciiWrite(buf, string, offset, length)\\r\\n}\\r\\n\\r\\nfunction base64Write (buf, string, offset, length) {\\r\\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\\r\\n}\\r\\n\\r\\nfunction ucs2Write (buf, string, offset, length) {\\r\\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\\r\\n}\\r\\n\\r\\nBuffer.prototype.write = function write (string, offset, length, encoding) {\\r\\n  // Buffer#write(string)\\r\\n  if (offset === undefined) {\\r\\n    encoding = 'utf8'\\r\\n    length = this.length\\r\\n    offset = 0\\r\\n  // Buffer#write(string, encoding)\\r\\n  } else if (length === undefined && typeof offset === 'string') {\\r\\n    encoding = offset\\r\\n    length = this.length\\r\\n    offset = 0\\r\\n  // Buffer#write(string, offset[, length][, encoding])\\r\\n  } else if (isFinite(offset)) {\\r\\n    offset = offset >>> 0\\r\\n    if (isFinite(length)) {\\r\\n      length = length >>> 0\\r\\n      if (encoding === undefined) encoding = 'utf8'\\r\\n    } else {\\r\\n      encoding = length\\r\\n      length = undefined\\r\\n    }\\r\\n  } else {\\r\\n    throw new Error(\\r\\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\\r\\n    )\\r\\n  }\\r\\n\\r\\n  var remaining = this.length - offset\\r\\n  if (length === undefined || length > remaining) length = remaining\\r\\n\\r\\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\\r\\n    throw new RangeError('Attempt to write outside buffer bounds')\\r\\n  }\\r\\n\\r\\n  if (!encoding) encoding = 'utf8'\\r\\n\\r\\n  var loweredCase = false\\r\\n  for (;;) {\\r\\n    switch (encoding) {\\r\\n      case 'hex':\\r\\n        return hexWrite(this, string, offset, length)\\r\\n\\r\\n      case 'utf8':\\r\\n      case 'utf-8':\\r\\n        return utf8Write(this, string, offset, length)\\r\\n\\r\\n      case 'ascii':\\r\\n        return asciiWrite(this, string, offset, length)\\r\\n\\r\\n      case 'latin1':\\r\\n      case 'binary':\\r\\n        return latin1Write(this, string, offset, length)\\r\\n\\r\\n      case 'base64':\\r\\n        // Warning: maxLength not taken into account in base64Write\\r\\n        return base64Write(this, string, offset, length)\\r\\n\\r\\n      case 'ucs2':\\r\\n      case 'ucs-2':\\r\\n      case 'utf16le':\\r\\n      case 'utf-16le':\\r\\n        return ucs2Write(this, string, offset, length)\\r\\n\\r\\n      default:\\r\\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\\r\\n        encoding = ('' + encoding).toLowerCase()\\r\\n        loweredCase = true\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nBuffer.prototype.toJSON = function toJSON () {\\r\\n  return {\\r\\n    type: 'Buffer',\\r\\n    data: Array.prototype.slice.call(this._arr || this, 0)\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction base64Slice (buf, start, end) {\\r\\n  if (start === 0 && end === buf.length) {\\r\\n    return base64.fromByteArray(buf)\\r\\n  } else {\\r\\n    return base64.fromByteArray(buf.slice(start, end))\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction utf8Slice (buf, start, end) {\\r\\n  end = Math.min(buf.length, end)\\r\\n  var res = []\\r\\n\\r\\n  var i = start\\r\\n  while (i < end) {\\r\\n    var firstByte = buf[i]\\r\\n    var codePoint = null\\r\\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\\r\\n      : (firstByte > 0xDF) ? 3\\r\\n        : (firstByte > 0xBF) ? 2\\r\\n          : 1\\r\\n\\r\\n    if (i + bytesPerSequence <= end) {\\r\\n      var secondByte, thirdByte, fourthByte, tempCodePoint\\r\\n\\r\\n      switch (bytesPerSequence) {\\r\\n        case 1:\\r\\n          if (firstByte < 0x80) {\\r\\n            codePoint = firstByte\\r\\n          }\\r\\n          break\\r\\n        case 2:\\r\\n          secondByte = buf[i + 1]\\r\\n          if ((secondByte & 0xC0) === 0x80) {\\r\\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\\r\\n            if (tempCodePoint > 0x7F) {\\r\\n              codePoint = tempCodePoint\\r\\n            }\\r\\n          }\\r\\n          break\\r\\n        case 3:\\r\\n          secondByte = buf[i + 1]\\r\\n          thirdByte = buf[i + 2]\\r\\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\\r\\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\\r\\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\\r\\n              codePoint = tempCodePoint\\r\\n            }\\r\\n          }\\r\\n          break\\r\\n        case 4:\\r\\n          secondByte = buf[i + 1]\\r\\n          thirdByte = buf[i + 2]\\r\\n          fourthByte = buf[i + 3]\\r\\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\\r\\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\\r\\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\\r\\n              codePoint = tempCodePoint\\r\\n            }\\r\\n          }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (codePoint === null) {\\r\\n      // we did not generate a valid codePoint so insert a\\r\\n      // replacement char (U+FFFD) and advance only 1 byte\\r\\n      codePoint = 0xFFFD\\r\\n      bytesPerSequence = 1\\r\\n    } else if (codePoint > 0xFFFF) {\\r\\n      // encode to utf16 (surrogate pair dance)\\r\\n      codePoint -= 0x10000\\r\\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\\r\\n      codePoint = 0xDC00 | codePoint & 0x3FF\\r\\n    }\\r\\n\\r\\n    res.push(codePoint)\\r\\n    i += bytesPerSequence\\r\\n  }\\r\\n\\r\\n  return decodeCodePointsArray(res)\\r\\n}\\r\\n\\r\\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\\r\\n// the lowest limit is Chrome, with 0x10000 args.\\r\\n// We go 1 magnitude less, for safety\\r\\nvar MAX_ARGUMENTS_LENGTH = 0x1000\\r\\n\\r\\nfunction decodeCodePointsArray (codePoints) {\\r\\n  var len = codePoints.length\\r\\n  if (len <= MAX_ARGUMENTS_LENGTH) {\\r\\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\\r\\n  }\\r\\n\\r\\n  // Decode in chunks to avoid \\\"call stack size exceeded\\\".\\r\\n  var res = ''\\r\\n  var i = 0\\r\\n  while (i < len) {\\r\\n    res += String.fromCharCode.apply(\\r\\n      String,\\r\\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\\r\\n    )\\r\\n  }\\r\\n  return res\\r\\n}\\r\\n\\r\\nfunction asciiSlice (buf, start, end) {\\r\\n  var ret = ''\\r\\n  end = Math.min(buf.length, end)\\r\\n\\r\\n  for (var i = start; i < end; ++i) {\\r\\n    ret += String.fromCharCode(buf[i] & 0x7F)\\r\\n  }\\r\\n  return ret\\r\\n}\\r\\n\\r\\nfunction latin1Slice (buf, start, end) {\\r\\n  var ret = ''\\r\\n  end = Math.min(buf.length, end)\\r\\n\\r\\n  for (var i = start; i < end; ++i) {\\r\\n    ret += String.fromCharCode(buf[i])\\r\\n  }\\r\\n  return ret\\r\\n}\\r\\n\\r\\nfunction hexSlice (buf, start, end) {\\r\\n  var len = buf.length\\r\\n\\r\\n  if (!start || start < 0) start = 0\\r\\n  if (!end || end < 0 || end > len) end = len\\r\\n\\r\\n  var out = ''\\r\\n  for (var i = start; i < end; ++i) {\\r\\n    out += toHex(buf[i])\\r\\n  }\\r\\n  return out\\r\\n}\\r\\n\\r\\nfunction utf16leSlice (buf, start, end) {\\r\\n  var bytes = buf.slice(start, end)\\r\\n  var res = ''\\r\\n  for (var i = 0; i < bytes.length; i += 2) {\\r\\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\\r\\n  }\\r\\n  return res\\r\\n}\\r\\n\\r\\nBuffer.prototype.slice = function slice (start, end) {\\r\\n  var len = this.length\\r\\n  start = ~~start\\r\\n  end = end === undefined ? len : ~~end\\r\\n\\r\\n  if (start < 0) {\\r\\n    start += len\\r\\n    if (start < 0) start = 0\\r\\n  } else if (start > len) {\\r\\n    start = len\\r\\n  }\\r\\n\\r\\n  if (end < 0) {\\r\\n    end += len\\r\\n    if (end < 0) end = 0\\r\\n  } else if (end > len) {\\r\\n    end = len\\r\\n  }\\r\\n\\r\\n  if (end < start) end = start\\r\\n\\r\\n  var newBuf = this.subarray(start, end)\\r\\n  // Return an augmented `Uint8Array` instance\\r\\n  newBuf.__proto__ = Buffer.prototype\\r\\n  return newBuf\\r\\n}\\r\\n\\r\\n/*\\r\\n * Need to make sure that buffer isn't trying to write out of bounds.\\r\\n */\\r\\nfunction checkOffset (offset, ext, length) {\\r\\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\\r\\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  byteLength = byteLength >>> 0\\r\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\r\\n\\r\\n  var val = this[offset]\\r\\n  var mul = 1\\r\\n  var i = 0\\r\\n  while (++i < byteLength && (mul *= 0x100)) {\\r\\n    val += this[offset + i] * mul\\r\\n  }\\r\\n\\r\\n  return val\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  byteLength = byteLength >>> 0\\r\\n  if (!noAssert) {\\r\\n    checkOffset(offset, byteLength, this.length)\\r\\n  }\\r\\n\\r\\n  var val = this[offset + --byteLength]\\r\\n  var mul = 1\\r\\n  while (byteLength > 0 && (mul *= 0x100)) {\\r\\n    val += this[offset + --byteLength] * mul\\r\\n  }\\r\\n\\r\\n  return val\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 1, this.length)\\r\\n  return this[offset]\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\r\\n  return this[offset] | (this[offset + 1] << 8)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\r\\n  return (this[offset] << 8) | this[offset + 1]\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\r\\n\\r\\n  return ((this[offset]) |\\r\\n      (this[offset + 1] << 8) |\\r\\n      (this[offset + 2] << 16)) +\\r\\n      (this[offset + 3] * 0x1000000)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\r\\n\\r\\n  return (this[offset] * 0x1000000) +\\r\\n    ((this[offset + 1] << 16) |\\r\\n    (this[offset + 2] << 8) |\\r\\n    this[offset + 3])\\r\\n}\\r\\n\\r\\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  byteLength = byteLength >>> 0\\r\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\r\\n\\r\\n  var val = this[offset]\\r\\n  var mul = 1\\r\\n  var i = 0\\r\\n  while (++i < byteLength && (mul *= 0x100)) {\\r\\n    val += this[offset + i] * mul\\r\\n  }\\r\\n  mul *= 0x80\\r\\n\\r\\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\\r\\n\\r\\n  return val\\r\\n}\\r\\n\\r\\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  byteLength = byteLength >>> 0\\r\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\r\\n\\r\\n  var i = byteLength\\r\\n  var mul = 1\\r\\n  var val = this[offset + --i]\\r\\n  while (i > 0 && (mul *= 0x100)) {\\r\\n    val += this[offset + --i] * mul\\r\\n  }\\r\\n  mul *= 0x80\\r\\n\\r\\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\\r\\n\\r\\n  return val\\r\\n}\\r\\n\\r\\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 1, this.length)\\r\\n  if (!(this[offset] & 0x80)) return (this[offset])\\r\\n  return ((0xff - this[offset] + 1) * -1)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\r\\n  var val = this[offset] | (this[offset + 1] << 8)\\r\\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\\r\\n}\\r\\n\\r\\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\r\\n  var val = this[offset + 1] | (this[offset] << 8)\\r\\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\\r\\n}\\r\\n\\r\\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\r\\n\\r\\n  return (this[offset]) |\\r\\n    (this[offset + 1] << 8) |\\r\\n    (this[offset + 2] << 16) |\\r\\n    (this[offset + 3] << 24)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\r\\n\\r\\n  return (this[offset] << 24) |\\r\\n    (this[offset + 1] << 16) |\\r\\n    (this[offset + 2] << 8) |\\r\\n    (this[offset + 3])\\r\\n}\\r\\n\\r\\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\r\\n  return ieee754.read(this, offset, true, 23, 4)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\r\\n  return ieee754.read(this, offset, false, 23, 4)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 8, this.length)\\r\\n  return ieee754.read(this, offset, true, 52, 8)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 8, this.length)\\r\\n  return ieee754.read(this, offset, false, 52, 8)\\r\\n}\\r\\n\\r\\nfunction checkInt (buf, value, offset, ext, max, min) {\\r\\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\\\"buffer\\\" argument must be a Buffer instance')\\r\\n  if (value > max || value < min) throw new RangeError('\\\"value\\\" argument is out of bounds')\\r\\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  byteLength = byteLength >>> 0\\r\\n  if (!noAssert) {\\r\\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\\r\\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\\r\\n  }\\r\\n\\r\\n  var mul = 1\\r\\n  var i = 0\\r\\n  this[offset] = value & 0xFF\\r\\n  while (++i < byteLength && (mul *= 0x100)) {\\r\\n    this[offset + i] = (value / mul) & 0xFF\\r\\n  }\\r\\n\\r\\n  return offset + byteLength\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  byteLength = byteLength >>> 0\\r\\n  if (!noAssert) {\\r\\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\\r\\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\\r\\n  }\\r\\n\\r\\n  var i = byteLength - 1\\r\\n  var mul = 1\\r\\n  this[offset + i] = value & 0xFF\\r\\n  while (--i >= 0 && (mul *= 0x100)) {\\r\\n    this[offset + i] = (value / mul) & 0xFF\\r\\n  }\\r\\n\\r\\n  return offset + byteLength\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\\r\\n  this[offset] = (value & 0xff)\\r\\n  return offset + 1\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\\r\\n  this[offset] = (value & 0xff)\\r\\n  this[offset + 1] = (value >>> 8)\\r\\n  return offset + 2\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\\r\\n  this[offset] = (value >>> 8)\\r\\n  this[offset + 1] = (value & 0xff)\\r\\n  return offset + 2\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\\r\\n  this[offset + 3] = (value >>> 24)\\r\\n  this[offset + 2] = (value >>> 16)\\r\\n  this[offset + 1] = (value >>> 8)\\r\\n  this[offset] = (value & 0xff)\\r\\n  return offset + 4\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\\r\\n  this[offset] = (value >>> 24)\\r\\n  this[offset + 1] = (value >>> 16)\\r\\n  this[offset + 2] = (value >>> 8)\\r\\n  this[offset + 3] = (value & 0xff)\\r\\n  return offset + 4\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) {\\r\\n    var limit = Math.pow(2, (8 * byteLength) - 1)\\r\\n\\r\\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\\r\\n  }\\r\\n\\r\\n  var i = 0\\r\\n  var mul = 1\\r\\n  var sub = 0\\r\\n  this[offset] = value & 0xFF\\r\\n  while (++i < byteLength && (mul *= 0x100)) {\\r\\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\\r\\n      sub = 1\\r\\n    }\\r\\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\\r\\n  }\\r\\n\\r\\n  return offset + byteLength\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) {\\r\\n    var limit = Math.pow(2, (8 * byteLength) - 1)\\r\\n\\r\\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\\r\\n  }\\r\\n\\r\\n  var i = byteLength - 1\\r\\n  var mul = 1\\r\\n  var sub = 0\\r\\n  this[offset + i] = value & 0xFF\\r\\n  while (--i >= 0 && (mul *= 0x100)) {\\r\\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\\r\\n      sub = 1\\r\\n    }\\r\\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\\r\\n  }\\r\\n\\r\\n  return offset + byteLength\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\\r\\n  if (value < 0) value = 0xff + value + 1\\r\\n  this[offset] = (value & 0xff)\\r\\n  return offset + 1\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\\r\\n  this[offset] = (value & 0xff)\\r\\n  this[offset + 1] = (value >>> 8)\\r\\n  return offset + 2\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\\r\\n  this[offset] = (value >>> 8)\\r\\n  this[offset + 1] = (value & 0xff)\\r\\n  return offset + 2\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\\r\\n  this[offset] = (value & 0xff)\\r\\n  this[offset + 1] = (value >>> 8)\\r\\n  this[offset + 2] = (value >>> 16)\\r\\n  this[offset + 3] = (value >>> 24)\\r\\n  return offset + 4\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\\r\\n  if (value < 0) value = 0xffffffff + value + 1\\r\\n  this[offset] = (value >>> 24)\\r\\n  this[offset + 1] = (value >>> 16)\\r\\n  this[offset + 2] = (value >>> 8)\\r\\n  this[offset + 3] = (value & 0xff)\\r\\n  return offset + 4\\r\\n}\\r\\n\\r\\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\\r\\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\\r\\n  if (offset < 0) throw new RangeError('Index out of range')\\r\\n}\\r\\n\\r\\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) {\\r\\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\\r\\n  }\\r\\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\\r\\n  return offset + 4\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\\r\\n  return writeFloat(this, value, offset, true, noAssert)\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\\r\\n  return writeFloat(this, value, offset, false, noAssert)\\r\\n}\\r\\n\\r\\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) {\\r\\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\\r\\n  }\\r\\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\\r\\n  return offset + 8\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\\r\\n  return writeDouble(this, value, offset, true, noAssert)\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\\r\\n  return writeDouble(this, value, offset, false, noAssert)\\r\\n}\\r\\n\\r\\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\\r\\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\\r\\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\\r\\n  if (!start) start = 0\\r\\n  if (!end && end !== 0) end = this.length\\r\\n  if (targetStart >= target.length) targetStart = target.length\\r\\n  if (!targetStart) targetStart = 0\\r\\n  if (end > 0 && end < start) end = start\\r\\n\\r\\n  // Copy 0 bytes; we're done\\r\\n  if (end === start) return 0\\r\\n  if (target.length === 0 || this.length === 0) return 0\\r\\n\\r\\n  // Fatal error conditions\\r\\n  if (targetStart < 0) {\\r\\n    throw new RangeError('targetStart out of bounds')\\r\\n  }\\r\\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\\r\\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\\r\\n\\r\\n  // Are we oob?\\r\\n  if (end > this.length) end = this.length\\r\\n  if (target.length - targetStart < end - start) {\\r\\n    end = target.length - targetStart + start\\r\\n  }\\r\\n\\r\\n  var len = end - start\\r\\n\\r\\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\\r\\n    // Use built-in when available, missing from IE11\\r\\n    this.copyWithin(targetStart, start, end)\\r\\n  } else if (this === target && start < targetStart && targetStart < end) {\\r\\n    // descending copy from end\\r\\n    for (var i = len - 1; i >= 0; --i) {\\r\\n      target[i + targetStart] = this[i + start]\\r\\n    }\\r\\n  } else {\\r\\n    Uint8Array.prototype.set.call(\\r\\n      target,\\r\\n      this.subarray(start, end),\\r\\n      targetStart\\r\\n    )\\r\\n  }\\r\\n\\r\\n  return len\\r\\n}\\r\\n\\r\\n// Usage:\\r\\n//    buffer.fill(number[, offset[, end]])\\r\\n//    buffer.fill(buffer[, offset[, end]])\\r\\n//    buffer.fill(string[, offset[, end]][, encoding])\\r\\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\\r\\n  // Handle string cases:\\r\\n  if (typeof val === 'string') {\\r\\n    if (typeof start === 'string') {\\r\\n      encoding = start\\r\\n      start = 0\\r\\n      end = this.length\\r\\n    } else if (typeof end === 'string') {\\r\\n      encoding = end\\r\\n      end = this.length\\r\\n    }\\r\\n    if (encoding !== undefined && typeof encoding !== 'string') {\\r\\n      throw new TypeError('encoding must be a string')\\r\\n    }\\r\\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\\r\\n      throw new TypeError('Unknown encoding: ' + encoding)\\r\\n    }\\r\\n    if (val.length === 1) {\\r\\n      var code = val.charCodeAt(0)\\r\\n      if ((encoding === 'utf8' && code < 128) ||\\r\\n          encoding === 'latin1') {\\r\\n        // Fast path: If `val` fits into a single byte, use that numeric value.\\r\\n        val = code\\r\\n      }\\r\\n    }\\r\\n  } else if (typeof val === 'number') {\\r\\n    val = val & 255\\r\\n  }\\r\\n\\r\\n  // Invalid ranges are not set to a default, so can range check early.\\r\\n  if (start < 0 || this.length < start || this.length < end) {\\r\\n    throw new RangeError('Out of range index')\\r\\n  }\\r\\n\\r\\n  if (end <= start) {\\r\\n    return this\\r\\n  }\\r\\n\\r\\n  start = start >>> 0\\r\\n  end = end === undefined ? this.length : end >>> 0\\r\\n\\r\\n  if (!val) val = 0\\r\\n\\r\\n  var i\\r\\n  if (typeof val === 'number') {\\r\\n    for (i = start; i < end; ++i) {\\r\\n      this[i] = val\\r\\n    }\\r\\n  } else {\\r\\n    var bytes = Buffer.isBuffer(val)\\r\\n      ? val\\r\\n      : Buffer.from(val, encoding)\\r\\n    var len = bytes.length\\r\\n    if (len === 0) {\\r\\n      throw new TypeError('The value \\\"' + val +\\r\\n        '\\\" is invalid for argument \\\"value\\\"')\\r\\n    }\\r\\n    for (i = 0; i < end - start; ++i) {\\r\\n      this[i + start] = bytes[i % len]\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return this\\r\\n}\\r\\n\\r\\n// HELPER FUNCTIONS\\r\\n// ================\\r\\n\\r\\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\\r\\n\\r\\nfunction base64clean (str) {\\r\\n  // Node takes equal signs as end of the Base64 encoding\\r\\n  str = str.split('=')[0]\\r\\n  // Node strips out invalid characters like \\\\n and \\\\t from the string, base64-js does not\\r\\n  str = str.trim().replace(INVALID_BASE64_RE, '')\\r\\n  // Node converts strings with length < 2 to ''\\r\\n  if (str.length < 2) return ''\\r\\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\\r\\n  while (str.length % 4 !== 0) {\\r\\n    str = str + '='\\r\\n  }\\r\\n  return str\\r\\n}\\r\\n\\r\\nfunction toHex (n) {\\r\\n  if (n < 16) return '0' + n.toString(16)\\r\\n  return n.toString(16)\\r\\n}\\r\\n\\r\\nfunction utf8ToBytes (string, units) {\\r\\n  units = units || Infinity\\r\\n  var codePoint\\r\\n  var length = string.length\\r\\n  var leadSurrogate = null\\r\\n  var bytes = []\\r\\n\\r\\n  for (var i = 0; i < length; ++i) {\\r\\n    codePoint = string.charCodeAt(i)\\r\\n\\r\\n    // is surrogate component\\r\\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\\r\\n      // last char was a lead\\r\\n      if (!leadSurrogate) {\\r\\n        // no lead yet\\r\\n        if (codePoint > 0xDBFF) {\\r\\n          // unexpected trail\\r\\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\r\\n          continue\\r\\n        } else if (i + 1 === length) {\\r\\n          // unpaired lead\\r\\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\r\\n          continue\\r\\n        }\\r\\n\\r\\n        // valid lead\\r\\n        leadSurrogate = codePoint\\r\\n\\r\\n        continue\\r\\n      }\\r\\n\\r\\n      // 2 leads in a row\\r\\n      if (codePoint < 0xDC00) {\\r\\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\r\\n        leadSurrogate = codePoint\\r\\n        continue\\r\\n      }\\r\\n\\r\\n      // valid surrogate pair\\r\\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\\r\\n    } else if (leadSurrogate) {\\r\\n      // valid bmp char, but last char was a lead\\r\\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\r\\n    }\\r\\n\\r\\n    leadSurrogate = null\\r\\n\\r\\n    // encode utf8\\r\\n    if (codePoint < 0x80) {\\r\\n      if ((units -= 1) < 0) break\\r\\n      bytes.push(codePoint)\\r\\n    } else if (codePoint < 0x800) {\\r\\n      if ((units -= 2) < 0) break\\r\\n      bytes.push(\\r\\n        codePoint >> 0x6 | 0xC0,\\r\\n        codePoint & 0x3F | 0x80\\r\\n      )\\r\\n    } else if (codePoint < 0x10000) {\\r\\n      if ((units -= 3) < 0) break\\r\\n      bytes.push(\\r\\n        codePoint >> 0xC | 0xE0,\\r\\n        codePoint >> 0x6 & 0x3F | 0x80,\\r\\n        codePoint & 0x3F | 0x80\\r\\n      )\\r\\n    } else if (codePoint < 0x110000) {\\r\\n      if ((units -= 4) < 0) break\\r\\n      bytes.push(\\r\\n        codePoint >> 0x12 | 0xF0,\\r\\n        codePoint >> 0xC & 0x3F | 0x80,\\r\\n        codePoint >> 0x6 & 0x3F | 0x80,\\r\\n        codePoint & 0x3F | 0x80\\r\\n      )\\r\\n    } else {\\r\\n      throw new Error('Invalid code point')\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return bytes\\r\\n}\\r\\n\\r\\nfunction asciiToBytes (str) {\\r\\n  var byteArray = []\\r\\n  for (var i = 0; i < str.length; ++i) {\\r\\n    // Node's code seems to be doing this and not & 0x7F..\\r\\n    byteArray.push(str.charCodeAt(i) & 0xFF)\\r\\n  }\\r\\n  return byteArray\\r\\n}\\r\\n\\r\\nfunction utf16leToBytes (str, units) {\\r\\n  var c, hi, lo\\r\\n  var byteArray = []\\r\\n  for (var i = 0; i < str.length; ++i) {\\r\\n    if ((units -= 2) < 0) break\\r\\n\\r\\n    c = str.charCodeAt(i)\\r\\n    hi = c >> 8\\r\\n    lo = c % 256\\r\\n    byteArray.push(lo)\\r\\n    byteArray.push(hi)\\r\\n  }\\r\\n\\r\\n  return byteArray\\r\\n}\\r\\n\\r\\nfunction base64ToBytes (str) {\\r\\n  return base64.toByteArray(base64clean(str))\\r\\n}\\r\\n\\r\\nfunction blitBuffer (src, dst, offset, length) {\\r\\n  for (var i = 0; i < length; ++i) {\\r\\n    if ((i + offset >= dst.length) || (i >= src.length)) break\\r\\n    dst[i + offset] = src[i]\\r\\n  }\\r\\n  return i\\r\\n}\\r\\n\\r\\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\\r\\n// the `instanceof` check but they should be treated as of that type.\\r\\n// See: https://github.com/feross/buffer/issues/166\\r\\nfunction isInstance (obj, type) {\\r\\n  return obj instanceof type ||\\r\\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\\r\\n      obj.constructor.name === type.name)\\r\\n}\\r\\nfunction numberIsNaN (obj) {\\r\\n  // For IE11 support\\r\\n  return obj !== obj // eslint-disable-line no-self-compare\\r\\n}\\r\\n\\r\\n}).call(this,_dereq_(\\\"buffer\\\").Buffer)\\r\\n},{\\\"base64-js\\\":8,\\\"buffer\\\":9,\\\"ieee754\\\":12}],10:[function(_dereq_,module,exports){\\r\\n(function (Buffer){\\r\\nvar clone = (function() {\\r\\n'use strict';\\r\\n\\r\\nfunction _instanceof(obj, type) {\\r\\n  return type != null && obj instanceof type;\\r\\n}\\r\\n\\r\\nvar nativeMap;\\r\\ntry {\\r\\n  nativeMap = Map;\\r\\n} catch(_) {\\r\\n  // maybe a reference error because no `Map`. Give it a dummy value that no\\r\\n  // value will ever be an instanceof.\\r\\n  nativeMap = function() {};\\r\\n}\\r\\n\\r\\nvar nativeSet;\\r\\ntry {\\r\\n  nativeSet = Set;\\r\\n} catch(_) {\\r\\n  nativeSet = function() {};\\r\\n}\\r\\n\\r\\nvar nativePromise;\\r\\ntry {\\r\\n  nativePromise = Promise;\\r\\n} catch(_) {\\r\\n  nativePromise = function() {};\\r\\n}\\r\\n\\r\\n/**\\r\\n * Clones (copies) an Object using deep copying.\\r\\n *\\r\\n * This function supports circular references by default, but if you are certain\\r\\n * there are no circular references in your object, you can save some CPU time\\r\\n * by calling clone(obj, false).\\r\\n *\\r\\n * Caution: if `circular` is false and `parent` contains circular references,\\r\\n * your program may enter an infinite loop and crash.\\r\\n *\\r\\n * @param `parent` - the object to be cloned\\r\\n * @param `circular` - set to true if the object to be cloned may contain\\r\\n *    circular references. (optional - true by default)\\r\\n * @param `depth` - set to a number if the object is only to be cloned to\\r\\n *    a particular depth. (optional - defaults to Infinity)\\r\\n * @param `prototype` - sets the prototype to be used when cloning an object.\\r\\n *    (optional - defaults to parent prototype).\\r\\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\\r\\n *    should be cloned as well. Non-enumerable properties on the prototype\\r\\n *    chain will be ignored. (optional - false by default)\\r\\n*/\\r\\nfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\\r\\n  if (typeof circular === 'object') {\\r\\n    depth = circular.depth;\\r\\n    prototype = circular.prototype;\\r\\n    includeNonEnumerable = circular.includeNonEnumerable;\\r\\n    circular = circular.circular;\\r\\n  }\\r\\n  // maintain two arrays for circular references, where corresponding parents\\r\\n  // and children have the same index\\r\\n  var allParents = [];\\r\\n  var allChildren = [];\\r\\n\\r\\n  var useBuffer = typeof Buffer != 'undefined';\\r\\n\\r\\n  if (typeof circular == 'undefined')\\r\\n    circular = true;\\r\\n\\r\\n  if (typeof depth == 'undefined')\\r\\n    depth = Infinity;\\r\\n\\r\\n  // recurse this function so we don't reset allParents and allChildren\\r\\n  function _clone(parent, depth) {\\r\\n    // cloning null always returns null\\r\\n    if (parent === null)\\r\\n      return null;\\r\\n\\r\\n    if (depth === 0)\\r\\n      return parent;\\r\\n\\r\\n    var child;\\r\\n    var proto;\\r\\n    if (typeof parent != 'object') {\\r\\n      return parent;\\r\\n    }\\r\\n\\r\\n    if (_instanceof(parent, nativeMap)) {\\r\\n      child = new nativeMap();\\r\\n    } else if (_instanceof(parent, nativeSet)) {\\r\\n      child = new nativeSet();\\r\\n    } else if (_instanceof(parent, nativePromise)) {\\r\\n      child = new nativePromise(function (resolve, reject) {\\r\\n        parent.then(function(value) {\\r\\n          resolve(_clone(value, depth - 1));\\r\\n        }, function(err) {\\r\\n          reject(_clone(err, depth - 1));\\r\\n        });\\r\\n      });\\r\\n    } else if (clone.__isArray(parent)) {\\r\\n      child = [];\\r\\n    } else if (clone.__isRegExp(parent)) {\\r\\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\\r\\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\\r\\n    } else if (clone.__isDate(parent)) {\\r\\n      child = new Date(parent.getTime());\\r\\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\\r\\n      child = new Buffer(parent.length);\\r\\n      parent.copy(child);\\r\\n      return child;\\r\\n    } else if (_instanceof(parent, Error)) {\\r\\n      child = Object.create(parent);\\r\\n    } else {\\r\\n      if (typeof prototype == 'undefined') {\\r\\n        proto = Object.getPrototypeOf(parent);\\r\\n        child = Object.create(proto);\\r\\n      }\\r\\n      else {\\r\\n        child = Object.create(prototype);\\r\\n        proto = prototype;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (circular) {\\r\\n      var index = allParents.indexOf(parent);\\r\\n\\r\\n      if (index != -1) {\\r\\n        return allChildren[index];\\r\\n      }\\r\\n      allParents.push(parent);\\r\\n      allChildren.push(child);\\r\\n    }\\r\\n\\r\\n    if (_instanceof(parent, nativeMap)) {\\r\\n      parent.forEach(function(value, key) {\\r\\n        var keyChild = _clone(key, depth - 1);\\r\\n        var valueChild = _clone(value, depth - 1);\\r\\n        child.set(keyChild, valueChild);\\r\\n      });\\r\\n    }\\r\\n    if (_instanceof(parent, nativeSet)) {\\r\\n      parent.forEach(function(value) {\\r\\n        var entryChild = _clone(value, depth - 1);\\r\\n        child.add(entryChild);\\r\\n      });\\r\\n    }\\r\\n\\r\\n    for (var i in parent) {\\r\\n      var attrs;\\r\\n      if (proto) {\\r\\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\\r\\n      }\\r\\n\\r\\n      if (attrs && attrs.set == null) {\\r\\n        continue;\\r\\n      }\\r\\n      child[i] = _clone(parent[i], depth - 1);\\r\\n    }\\r\\n\\r\\n    if (Object.getOwnPropertySymbols) {\\r\\n      var symbols = Object.getOwnPropertySymbols(parent);\\r\\n      for (var i = 0; i < symbols.length; i++) {\\r\\n        // Don't need to worry about cloning a symbol because it is a primitive,\\r\\n        // like a number or string.\\r\\n        var symbol = symbols[i];\\r\\n        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\\r\\n        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\\r\\n          continue;\\r\\n        }\\r\\n        child[symbol] = _clone(parent[symbol], depth - 1);\\r\\n        if (!descriptor.enumerable) {\\r\\n          Object.defineProperty(child, symbol, {\\r\\n            enumerable: false\\r\\n          });\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (includeNonEnumerable) {\\r\\n      var allPropertyNames = Object.getOwnPropertyNames(parent);\\r\\n      for (var i = 0; i < allPropertyNames.length; i++) {\\r\\n        var propertyName = allPropertyNames[i];\\r\\n        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\\r\\n        if (descriptor && descriptor.enumerable) {\\r\\n          continue;\\r\\n        }\\r\\n        child[propertyName] = _clone(parent[propertyName], depth - 1);\\r\\n        Object.defineProperty(child, propertyName, {\\r\\n          enumerable: false\\r\\n        });\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return child;\\r\\n  }\\r\\n\\r\\n  return _clone(parent, depth);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Simple flat clone using prototype, accepts only objects, usefull for property\\r\\n * override on FLAT configuration object (no nested props).\\r\\n *\\r\\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\\r\\n * works.\\r\\n */\\r\\nclone.clonePrototype = function clonePrototype(parent) {\\r\\n  if (parent === null)\\r\\n    return null;\\r\\n\\r\\n  var c = function () {};\\r\\n  c.prototype = parent;\\r\\n  return new c();\\r\\n};\\r\\n\\r\\n// private utility functions\\r\\n\\r\\nfunction __objToStr(o) {\\r\\n  return Object.prototype.toString.call(o);\\r\\n}\\r\\nclone.__objToStr = __objToStr;\\r\\n\\r\\nfunction __isDate(o) {\\r\\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\\r\\n}\\r\\nclone.__isDate = __isDate;\\r\\n\\r\\nfunction __isArray(o) {\\r\\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\\r\\n}\\r\\nclone.__isArray = __isArray;\\r\\n\\r\\nfunction __isRegExp(o) {\\r\\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\\r\\n}\\r\\nclone.__isRegExp = __isRegExp;\\r\\n\\r\\nfunction __getRegExpFlags(re) {\\r\\n  var flags = '';\\r\\n  if (re.global) flags += 'g';\\r\\n  if (re.ignoreCase) flags += 'i';\\r\\n  if (re.multiline) flags += 'm';\\r\\n  return flags;\\r\\n}\\r\\nclone.__getRegExpFlags = __getRegExpFlags;\\r\\n\\r\\nreturn clone;\\r\\n})();\\r\\n\\r\\nif (typeof module === 'object' && module.exports) {\\r\\n  module.exports = clone;\\r\\n}\\r\\n\\r\\n}).call(this,_dereq_(\\\"buffer\\\").Buffer)\\r\\n},{\\\"buffer\\\":9}],11:[function(_dereq_,module,exports){\\r\\n\\r\\n/**\\r\\n * Expose `Emitter`.\\r\\n */\\r\\n\\r\\nif (typeof module !== 'undefined') {\\r\\n  module.exports = Emitter;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Initialize a new `Emitter`.\\r\\n *\\r\\n * @api public\\r\\n */\\r\\n\\r\\nfunction Emitter(obj) {\\r\\n  if (obj) return mixin(obj);\\r\\n};\\r\\n\\r\\n/**\\r\\n * Mixin the emitter properties.\\r\\n *\\r\\n * @param {Object} obj\\r\\n * @return {Object}\\r\\n * @api private\\r\\n */\\r\\n\\r\\nfunction mixin(obj) {\\r\\n  for (var key in Emitter.prototype) {\\r\\n    obj[key] = Emitter.prototype[key];\\r\\n  }\\r\\n  return obj;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Listen on the given `event` with `fn`.\\r\\n *\\r\\n * @param {String} event\\r\\n * @param {Function} fn\\r\\n * @return {Emitter}\\r\\n * @api public\\r\\n */\\r\\n\\r\\nEmitter.prototype.on =\\r\\nEmitter.prototype.addEventListener = function(event, fn){\\r\\n  this._callbacks = this._callbacks || {};\\r\\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\\r\\n    .push(fn);\\r\\n  return this;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Adds an `event` listener that will be invoked a single\\r\\n * time then automatically removed.\\r\\n *\\r\\n * @param {String} event\\r\\n * @param {Function} fn\\r\\n * @return {Emitter}\\r\\n * @api public\\r\\n */\\r\\n\\r\\nEmitter.prototype.once = function(event, fn){\\r\\n  function on() {\\r\\n    this.off(event, on);\\r\\n    fn.apply(this, arguments);\\r\\n  }\\r\\n\\r\\n  on.fn = fn;\\r\\n  this.on(event, on);\\r\\n  return this;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Remove the given callback for `event` or all\\r\\n * registered callbacks.\\r\\n *\\r\\n * @param {String} event\\r\\n * @param {Function} fn\\r\\n * @return {Emitter}\\r\\n * @api public\\r\\n */\\r\\n\\r\\nEmitter.prototype.off =\\r\\nEmitter.prototype.removeListener =\\r\\nEmitter.prototype.removeAllListeners =\\r\\nEmitter.prototype.removeEventListener = function(event, fn){\\r\\n  this._callbacks = this._callbacks || {};\\r\\n\\r\\n  // all\\r\\n  if (0 == arguments.length) {\\r\\n    this._callbacks = {};\\r\\n    return this;\\r\\n  }\\r\\n\\r\\n  // specific event\\r\\n  var callbacks = this._callbacks['$' + event];\\r\\n  if (!callbacks) return this;\\r\\n\\r\\n  // remove all handlers\\r\\n  if (1 == arguments.length) {\\r\\n    delete this._callbacks['$' + event];\\r\\n    return this;\\r\\n  }\\r\\n\\r\\n  // remove specific handler\\r\\n  var cb;\\r\\n  for (var i = 0; i < callbacks.length; i++) {\\r\\n    cb = callbacks[i];\\r\\n    if (cb === fn || cb.fn === fn) {\\r\\n      callbacks.splice(i, 1);\\r\\n      break;\\r\\n    }\\r\\n  }\\r\\n  return this;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Emit `event` with the given args.\\r\\n *\\r\\n * @param {String} event\\r\\n * @param {Mixed} ...\\r\\n * @return {Emitter}\\r\\n */\\r\\n\\r\\nEmitter.prototype.emit = function(event){\\r\\n  this._callbacks = this._callbacks || {};\\r\\n  var args = [].slice.call(arguments, 1)\\r\\n    , callbacks = this._callbacks['$' + event];\\r\\n\\r\\n  if (callbacks) {\\r\\n    callbacks = callbacks.slice(0);\\r\\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\\r\\n      callbacks[i].apply(this, args);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Return array of callbacks for `event`.\\r\\n *\\r\\n * @param {String} event\\r\\n * @return {Array}\\r\\n * @api public\\r\\n */\\r\\n\\r\\nEmitter.prototype.listeners = function(event){\\r\\n  this._callbacks = this._callbacks || {};\\r\\n  return this._callbacks['$' + event] || [];\\r\\n};\\r\\n\\r\\n/**\\r\\n * Check if this emitter has `event` handlers.\\r\\n *\\r\\n * @param {String} event\\r\\n * @return {Boolean}\\r\\n * @api public\\r\\n */\\r\\n\\r\\nEmitter.prototype.hasListeners = function(event){\\r\\n  return !! this.listeners(event).length;\\r\\n};\\r\\n\\r\\n},{}],12:[function(_dereq_,module,exports){\\r\\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\\r\\n  var e, m\\r\\n  var eLen = (nBytes * 8) - mLen - 1\\r\\n  var eMax = (1 << eLen) - 1\\r\\n  var eBias = eMax >> 1\\r\\n  var nBits = -7\\r\\n  var i = isLE ? (nBytes - 1) : 0\\r\\n  var d = isLE ? -1 : 1\\r\\n  var s = buffer[offset + i]\\r\\n\\r\\n  i += d\\r\\n\\r\\n  e = s & ((1 << (-nBits)) - 1)\\r\\n  s >>= (-nBits)\\r\\n  nBits += eLen\\r\\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\\r\\n\\r\\n  m = e & ((1 << (-nBits)) - 1)\\r\\n  e >>= (-nBits)\\r\\n  nBits += mLen\\r\\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\\r\\n\\r\\n  if (e === 0) {\\r\\n    e = 1 - eBias\\r\\n  } else if (e === eMax) {\\r\\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\\r\\n  } else {\\r\\n    m = m + Math.pow(2, mLen)\\r\\n    e = e - eBias\\r\\n  }\\r\\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\\r\\n}\\r\\n\\r\\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\\r\\n  var e, m, c\\r\\n  var eLen = (nBytes * 8) - mLen - 1\\r\\n  var eMax = (1 << eLen) - 1\\r\\n  var eBias = eMax >> 1\\r\\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\\r\\n  var i = isLE ? 0 : (nBytes - 1)\\r\\n  var d = isLE ? 1 : -1\\r\\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\\r\\n\\r\\n  value = Math.abs(value)\\r\\n\\r\\n  if (isNaN(value) || value === Infinity) {\\r\\n    m = isNaN(value) ? 1 : 0\\r\\n    e = eMax\\r\\n  } else {\\r\\n    e = Math.floor(Math.log(value) / Math.LN2)\\r\\n    if (value * (c = Math.pow(2, -e)) < 1) {\\r\\n      e--\\r\\n      c *= 2\\r\\n    }\\r\\n    if (e + eBias >= 1) {\\r\\n      value += rt / c\\r\\n    } else {\\r\\n      value += rt * Math.pow(2, 1 - eBias)\\r\\n    }\\r\\n    if (value * c >= 2) {\\r\\n      e++\\r\\n      c /= 2\\r\\n    }\\r\\n\\r\\n    if (e + eBias >= eMax) {\\r\\n      m = 0\\r\\n      e = eMax\\r\\n    } else if (e + eBias >= 1) {\\r\\n      m = ((value * c) - 1) * Math.pow(2, mLen)\\r\\n      e = e + eBias\\r\\n    } else {\\r\\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\\r\\n      e = 0\\r\\n    }\\r\\n  }\\r\\n\\r\\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\\r\\n\\r\\n  e = (e << mLen) | m\\r\\n  eLen += mLen\\r\\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\\r\\n\\r\\n  buffer[offset + i - d] |= s * 128\\r\\n}\\r\\n\\r\\n},{}],13:[function(_dereq_,module,exports){\\r\\n'use strict';\\r\\n\\r\\n/**\\r\\n * Constants.\\r\\n */\\r\\n\\r\\nvar errorMessage;\\r\\n\\r\\nerrorMessage = 'An argument without append, prepend, ' +\\r\\n    'or detach methods was given to `List';\\r\\n\\r\\n/**\\r\\n * Creates a new List: A linked list is a bit like an Array, but\\r\\n * knows nothing about how many items are in it, and knows only about its\\r\\n * first (`head`) and last (`tail`) items. Each item (e.g. `head`, `tail`,\\r\\n * &c.) knows which item comes before or after it (its more like the\\r\\n * implementation of the DOM in JavaScript).\\r\\n * @global\\r\\n * @private\\r\\n * @constructor\\r\\n * @class Represents an instance of List.\\r\\n */\\r\\n\\r\\nfunction List(/*items...*/) {\\r\\n    if (arguments.length) {\\r\\n        return List.from(arguments);\\r\\n    }\\r\\n}\\r\\n\\r\\nvar ListPrototype;\\r\\n\\r\\nListPrototype = List.prototype;\\r\\n\\r\\n/**\\r\\n * Creates a new list from the arguments (each a list item) passed in.\\r\\n * @name List.of\\r\\n * @param {...ListItem} [items] - Zero or more items to attach.\\r\\n * @returns {list} - A new instance of List.\\r\\n */\\r\\n\\r\\nList.of = function (/*items...*/) {\\r\\n    return List.from.call(this, arguments);\\r\\n};\\r\\n\\r\\n/**\\r\\n * Creates a new list from the given array-like object (each a list item)\\r\\n * passed in.\\r\\n * @name List.from\\r\\n * @param {ListItem[]} [items] - The items to append.\\r\\n * @returns {list} - A new instance of List.\\r\\n */\\r\\nList.from = function (items) {\\r\\n    var list = new this(), length, iterator, item;\\r\\n\\r\\n    if (items && (length = items.length)) {\\r\\n        iterator = -1;\\r\\n\\r\\n        while (++iterator < length) {\\r\\n            item = items[iterator];\\r\\n\\r\\n            if (item !== null && item !== undefined) {\\r\\n                list.append(item);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return list;\\r\\n};\\r\\n\\r\\n/**\\r\\n * List#head\\r\\n * Default to `null`.\\r\\n */\\r\\nListPrototype.head = null;\\r\\n\\r\\n/**\\r\\n * List#tail\\r\\n * Default to `null`.\\r\\n */\\r\\nListPrototype.tail = null;\\r\\n\\r\\n/**\\r\\n * Returns the list's items as an array. This does *not* detach the items.\\r\\n * @name List#toArray\\r\\n * @returns {ListItem[]} - An array of (still attached) ListItems.\\r\\n */\\r\\nListPrototype.toArray = function () {\\r\\n    var item = this.head,\\r\\n        result = [];\\r\\n\\r\\n    while (item) {\\r\\n        result.push(item);\\r\\n        item = item.next;\\r\\n    }\\r\\n\\r\\n    return result;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Prepends the given item to the list: Item will be the new first item\\r\\n * (`head`).\\r\\n * @name List#prepend\\r\\n * @param {ListItem} item - The item to prepend.\\r\\n * @returns {ListItem} - An instance of ListItem (the given item).\\r\\n */\\r\\nListPrototype.prepend = function (item) {\\r\\n    if (!item) {\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    if (!item.append || !item.prepend || !item.detach) {\\r\\n        throw new Error(errorMessage + '#prepend`.');\\r\\n    }\\r\\n\\r\\n    var self, head;\\r\\n\\r\\n    // Cache self.\\r\\n    self = this;\\r\\n\\r\\n    // If self has a first item, defer prepend to the first items prepend\\r\\n    // method, and return the result.\\r\\n    head = self.head;\\r\\n\\r\\n    if (head) {\\r\\n        return head.prepend(item);\\r\\n    }\\r\\n\\r\\n    // ...otherwise, there is no `head` (or `tail`) item yet.\\r\\n\\r\\n    // Detach the prependee.\\r\\n    item.detach();\\r\\n\\r\\n    // Set the prependees parent list to reference self.\\r\\n    item.list = self;\\r\\n\\r\\n    // Set self's first item to the prependee, and return the item.\\r\\n    self.head = item;\\r\\n\\r\\n    return item;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Appends the given item to the list: Item will be the new last item (`tail`)\\r\\n * if the list had a first item, and its first item (`head`) otherwise.\\r\\n * @name List#append\\r\\n * @param {ListItem} item - The item to append.\\r\\n * @returns {ListItem} - An instance of ListItem (the given item).\\r\\n */\\r\\n\\r\\nListPrototype.append = function (item) {\\r\\n    if (!item) {\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    if (!item.append || !item.prepend || !item.detach) {\\r\\n        throw new Error(errorMessage + '#append`.');\\r\\n    }\\r\\n\\r\\n    var self, head, tail;\\r\\n\\r\\n    // Cache self.\\r\\n    self = this;\\r\\n\\r\\n    // If self has a last item, defer appending to the last items append\\r\\n    // method, and return the result.\\r\\n    tail = self.tail;\\r\\n\\r\\n    if (tail) {\\r\\n        return tail.append(item);\\r\\n    }\\r\\n\\r\\n    // If self has a first item, defer appending to the first items append\\r\\n    // method, and return the result.\\r\\n    head = self.head;\\r\\n\\r\\n    if (head) {\\r\\n        return head.append(item);\\r\\n    }\\r\\n\\r\\n    // ...otherwise, there is no `tail` or `head` item yet.\\r\\n\\r\\n    // Detach the appendee.\\r\\n    item.detach();\\r\\n\\r\\n    // Set the appendees parent list to reference self.\\r\\n    item.list = self;\\r\\n\\r\\n    // Set self's first item to the appendee, and return the item.\\r\\n    self.head = item;\\r\\n\\r\\n    return item;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Creates a new ListItem: A linked list item is a bit like DOM node:\\r\\n * It knows only about its \\\"parent\\\" (`list`), the item before it (`prev`),\\r\\n * and the item after it (`next`).\\r\\n * @global\\r\\n * @private\\r\\n * @constructor\\r\\n * @class Represents an instance of ListItem.\\r\\n */\\r\\n\\r\\nfunction ListItem() {}\\r\\n\\r\\nList.Item = ListItem;\\r\\n\\r\\nvar ListItemPrototype = ListItem.prototype;\\r\\n\\r\\nListItemPrototype.next = null;\\r\\n\\r\\nListItemPrototype.prev = null;\\r\\n\\r\\nListItemPrototype.list = null;\\r\\n\\r\\n/**\\r\\n * Detaches the item operated on from its parent list.\\r\\n * @name ListItem#detach\\r\\n * @returns {ListItem} - The item operated on.\\r\\n */\\r\\nListItemPrototype.detach = function () {\\r\\n    // Cache self, the parent list, and the previous and next items.\\r\\n    var self = this,\\r\\n        list = self.list,\\r\\n        prev = self.prev,\\r\\n        next = self.next;\\r\\n\\r\\n    // If the item is already detached, return self.\\r\\n    if (!list) {\\r\\n        return self;\\r\\n    }\\r\\n\\r\\n    // If self is the last item in the parent list, link the lists last item\\r\\n    // to the previous item.\\r\\n    if (list.tail === self) {\\r\\n        list.tail = prev;\\r\\n    }\\r\\n\\r\\n    // If self is the first item in the parent list, link the lists first item\\r\\n    // to the next item.\\r\\n    if (list.head === self) {\\r\\n        list.head = next;\\r\\n    }\\r\\n\\r\\n    // If both the last and first items in the parent list are the same,\\r\\n    // remove the link to the last item.\\r\\n    if (list.tail === list.head) {\\r\\n        list.tail = null;\\r\\n    }\\r\\n\\r\\n    // If a previous item exists, link its next item to selfs next item.\\r\\n    if (prev) {\\r\\n        prev.next = next;\\r\\n    }\\r\\n\\r\\n    // If a next item exists, link its previous item to selfs previous item.\\r\\n    if (next) {\\r\\n        next.prev = prev;\\r\\n    }\\r\\n\\r\\n    // Remove links from self to both the next and previous items, and to the\\r\\n    // parent list.\\r\\n    self.prev = self.next = self.list = null;\\r\\n\\r\\n    // Return self.\\r\\n    return self;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Prepends the given item *before* the item operated on.\\r\\n * @name ListItem#prepend\\r\\n * @param {ListItem} item - The item to prepend.\\r\\n * @returns {ListItem} - The item operated on, or false when that item is not\\r\\n * attached.\\r\\n */\\r\\nListItemPrototype.prepend = function (item) {\\r\\n    if (!item || !item.append || !item.prepend || !item.detach) {\\r\\n        throw new Error(errorMessage + 'Item#prepend`.');\\r\\n    }\\r\\n\\r\\n    // Cache self, the parent list, and the previous item.\\r\\n    var self = this,\\r\\n        list = self.list,\\r\\n        prev = self.prev;\\r\\n\\r\\n    // If self is detached, return false.\\r\\n    if (!list) {\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    // Detach the prependee.\\r\\n    item.detach();\\r\\n\\r\\n    // If self has a previous item...\\r\\n    if (prev) {\\r\\n        // ...link the prependees previous item, to selfs previous item.\\r\\n        item.prev = prev;\\r\\n\\r\\n        // ...link the previous items next item, to self.\\r\\n        prev.next = item;\\r\\n    }\\r\\n\\r\\n    // Set the prependees next item to self.\\r\\n    item.next = self;\\r\\n\\r\\n    // Set the prependees parent list to selfs parent list.\\r\\n    item.list = list;\\r\\n\\r\\n    // Set the previous item of self to the prependee.\\r\\n    self.prev = item;\\r\\n\\r\\n    // If self is the first item in the parent list, link the lists first item\\r\\n    // to the prependee.\\r\\n    if (self === list.head) {\\r\\n        list.head = item;\\r\\n    }\\r\\n\\r\\n    // If the the parent list has no last item, link the lists last item to\\r\\n    // self.\\r\\n    if (!list.tail) {\\r\\n        list.tail = self;\\r\\n    }\\r\\n\\r\\n    // Return the prependee.\\r\\n    return item;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Appends the given item *after* the item operated on.\\r\\n * @name ListItem#append\\r\\n * @param {ListItem} item - The item to append.\\r\\n * @returns {ListItem} - The item operated on, or false when that item is not\\r\\n * attached.\\r\\n */\\r\\nListItemPrototype.append = function (item) {\\r\\n    // If item is falsey, return false.\\r\\n    if (!item || !item.append || !item.prepend || !item.detach) {\\r\\n        throw new Error(errorMessage + 'Item#append`.');\\r\\n    }\\r\\n\\r\\n    // Cache self, the parent list, and the next item.\\r\\n    var self = this,\\r\\n        list = self.list,\\r\\n        next = self.next;\\r\\n\\r\\n    // If self is detached, return false.\\r\\n    if (!list) {\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    // Detach the appendee.\\r\\n    item.detach();\\r\\n\\r\\n    // If self has a next item...\\r\\n    if (next) {\\r\\n        // ...link the appendees next item, to selfs next item.\\r\\n        item.next = next;\\r\\n\\r\\n        // ...link the next items previous item, to the appendee.\\r\\n        next.prev = item;\\r\\n    }\\r\\n\\r\\n    // Set the appendees previous item to self.\\r\\n    item.prev = self;\\r\\n\\r\\n    // Set the appendees parent list to selfs parent list.\\r\\n    item.list = list;\\r\\n\\r\\n    // Set the next item of self to the appendee.\\r\\n    self.next = item;\\r\\n\\r\\n    // If the the parent list has no last item or if self is the parent lists\\r\\n    // last item, link the lists last item to the appendee.\\r\\n    if (self === list.tail || !list.tail) {\\r\\n        list.tail = item;\\r\\n    }\\r\\n\\r\\n    // Return the appendee.\\r\\n    return item;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Expose `List`.\\r\\n */\\r\\n\\r\\nmodule.exports = List;\\r\\n\\r\\n},{}],14:[function(_dereq_,module,exports){\\r\\n'use strict';\\r\\n\\r\\nmodule.exports = _dereq_('./_source/linked-list.js');\\r\\n\\r\\n},{\\\"./_source/linked-list.js\\\":13}],15:[function(_dereq_,module,exports){\\r\\n// Copyright Joyent, Inc. and other Node contributors.\\r\\n//\\r\\n// Permission is hereby granted, free of charge, to any person obtaining a\\r\\n// copy of this software and associated documentation files (the\\r\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\r\\n// without limitation the rights to use, copy, modify, merge, publish,\\r\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\r\\n// persons to whom the Software is furnished to do so, subject to the\\r\\n// following conditions:\\r\\n//\\r\\n// The above copyright notice and this permission notice shall be included\\r\\n// in all copies or substantial portions of the Software.\\r\\n//\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\r\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\r\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\r\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\r\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\r\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\r\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\r\\n\\r\\n'use strict';\\r\\n\\r\\n// If obj.hasOwnProperty has been overridden, then calling\\r\\n// obj.hasOwnProperty(prop) will break.\\r\\n// See: https://github.com/joyent/node/issues/1707\\r\\nfunction hasOwnProperty(obj, prop) {\\r\\n  return Object.prototype.hasOwnProperty.call(obj, prop);\\r\\n}\\r\\n\\r\\nmodule.exports = function(qs, sep, eq, options) {\\r\\n  sep = sep || '&';\\r\\n  eq = eq || '=';\\r\\n  var obj = {};\\r\\n\\r\\n  if (typeof qs !== 'string' || qs.length === 0) {\\r\\n    return obj;\\r\\n  }\\r\\n\\r\\n  var regexp = /\\\\+/g;\\r\\n  qs = qs.split(sep);\\r\\n\\r\\n  var maxKeys = 1000;\\r\\n  if (options && typeof options.maxKeys === 'number') {\\r\\n    maxKeys = options.maxKeys;\\r\\n  }\\r\\n\\r\\n  var len = qs.length;\\r\\n  // maxKeys <= 0 means that we should not limit keys count\\r\\n  if (maxKeys > 0 && len > maxKeys) {\\r\\n    len = maxKeys;\\r\\n  }\\r\\n\\r\\n  for (var i = 0; i < len; ++i) {\\r\\n    var x = qs[i].replace(regexp, '%20'),\\r\\n        idx = x.indexOf(eq),\\r\\n        kstr, vstr, k, v;\\r\\n\\r\\n    if (idx >= 0) {\\r\\n      kstr = x.substr(0, idx);\\r\\n      vstr = x.substr(idx + 1);\\r\\n    } else {\\r\\n      kstr = x;\\r\\n      vstr = '';\\r\\n    }\\r\\n\\r\\n    k = decodeURIComponent(kstr);\\r\\n    v = decodeURIComponent(vstr);\\r\\n\\r\\n    if (!hasOwnProperty(obj, k)) {\\r\\n      obj[k] = v;\\r\\n    } else if (isArray(obj[k])) {\\r\\n      obj[k].push(v);\\r\\n    } else {\\r\\n      obj[k] = [obj[k], v];\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return obj;\\r\\n};\\r\\n\\r\\nvar isArray = Array.isArray || function (xs) {\\r\\n  return Object.prototype.toString.call(xs) === '[object Array]';\\r\\n};\\r\\n\\r\\n},{}],16:[function(_dereq_,module,exports){\\r\\n// Copyright Joyent, Inc. and other Node contributors.\\r\\n//\\r\\n// Permission is hereby granted, free of charge, to any person obtaining a\\r\\n// copy of this software and associated documentation files (the\\r\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\r\\n// without limitation the rights to use, copy, modify, merge, publish,\\r\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\r\\n// persons to whom the Software is furnished to do so, subject to the\\r\\n// following conditions:\\r\\n//\\r\\n// The above copyright notice and this permission notice shall be included\\r\\n// in all copies or substantial portions of the Software.\\r\\n//\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\r\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\r\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\r\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\r\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\r\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\r\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\r\\n\\r\\n'use strict';\\r\\n\\r\\nvar stringifyPrimitive = function(v) {\\r\\n  switch (typeof v) {\\r\\n    case 'string':\\r\\n      return v;\\r\\n\\r\\n    case 'boolean':\\r\\n      return v ? 'true' : 'false';\\r\\n\\r\\n    case 'number':\\r\\n      return isFinite(v) ? v : '';\\r\\n\\r\\n    default:\\r\\n      return '';\\r\\n  }\\r\\n};\\r\\n\\r\\nmodule.exports = function(obj, sep, eq, name) {\\r\\n  sep = sep || '&';\\r\\n  eq = eq || '=';\\r\\n  if (obj === null) {\\r\\n    obj = undefined;\\r\\n  }\\r\\n\\r\\n  if (typeof obj === 'object') {\\r\\n    return map(objectKeys(obj), function(k) {\\r\\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\\r\\n      if (isArray(obj[k])) {\\r\\n        return map(obj[k], function(v) {\\r\\n          return ks + encodeURIComponent(stringifyPrimitive(v));\\r\\n        }).join(sep);\\r\\n      } else {\\r\\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\\r\\n      }\\r\\n    }).join(sep);\\r\\n\\r\\n  }\\r\\n\\r\\n  if (!name) return '';\\r\\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\\r\\n         encodeURIComponent(stringifyPrimitive(obj));\\r\\n};\\r\\n\\r\\nvar isArray = Array.isArray || function (xs) {\\r\\n  return Object.prototype.toString.call(xs) === '[object Array]';\\r\\n};\\r\\n\\r\\nfunction map (xs, f) {\\r\\n  if (xs.map) return xs.map(f);\\r\\n  var res = [];\\r\\n  for (var i = 0; i < xs.length; i++) {\\r\\n    res.push(f(xs[i], i));\\r\\n  }\\r\\n  return res;\\r\\n}\\r\\n\\r\\nvar objectKeys = Object.keys || function (obj) {\\r\\n  var res = [];\\r\\n  for (var key in obj) {\\r\\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\\r\\n  }\\r\\n  return res;\\r\\n};\\r\\n\\r\\n},{}],17:[function(_dereq_,module,exports){\\r\\n'use strict';\\r\\n\\r\\nexports.decode = exports.parse = _dereq_('./decode');\\r\\nexports.encode = exports.stringify = _dereq_('./encode');\\r\\n\\r\\n},{\\\"./decode\\\":15,\\\"./encode\\\":16}],18:[function(_dereq_,module,exports){\\r\\nvar Emitter = _dereq_('component-emitter');\\r\\n\\r\\nvar SCChannel = function (name, client, options) {\\r\\n  var self = this;\\r\\n\\r\\n  Emitter.call(this);\\r\\n\\r\\n  this.PENDING = 'pending';\\r\\n  this.SUBSCRIBED = 'subscribed';\\r\\n  this.UNSUBSCRIBED = 'unsubscribed';\\r\\n\\r\\n  this.name = name;\\r\\n  this.state = this.UNSUBSCRIBED;\\r\\n  this.client = client;\\r\\n\\r\\n  this.options = options || {};\\r\\n  this.setOptions(this.options);\\r\\n};\\r\\n\\r\\nSCChannel.prototype = Object.create(Emitter.prototype);\\r\\n\\r\\nSCChannel.prototype.setOptions = function (options) {\\r\\n  if (!options) {\\r\\n    options = {};\\r\\n  }\\r\\n  this.waitForAuth = options.waitForAuth || false;\\r\\n  this.batch = options.batch || false;\\r\\n\\r\\n  if (options.data !== undefined) {\\r\\n    this.data = options.data;\\r\\n  }\\r\\n};\\r\\n\\r\\nSCChannel.prototype.getState = function () {\\r\\n  return this.state;\\r\\n};\\r\\n\\r\\nSCChannel.prototype.subscribe = function (options) {\\r\\n  this.client.subscribe(this.name, options);\\r\\n};\\r\\n\\r\\nSCChannel.prototype.unsubscribe = function () {\\r\\n  this.client.unsubscribe(this.name);\\r\\n};\\r\\n\\r\\nSCChannel.prototype.isSubscribed = function (includePending) {\\r\\n  return this.client.isSubscribed(this.name, includePending);\\r\\n};\\r\\n\\r\\nSCChannel.prototype.publish = function (data, callback) {\\r\\n  this.client.publish(this.name, data, callback);\\r\\n};\\r\\n\\r\\nSCChannel.prototype.watch = function (handler) {\\r\\n  this.client.watch(this.name, handler);\\r\\n};\\r\\n\\r\\nSCChannel.prototype.unwatch = function (handler) {\\r\\n  this.client.unwatch(this.name, handler);\\r\\n};\\r\\n\\r\\nSCChannel.prototype.watchers = function () {\\r\\n  return this.client.watchers(this.name);\\r\\n};\\r\\n\\r\\nSCChannel.prototype.destroy = function () {\\r\\n  this.client.destroyChannel(this.name);\\r\\n};\\r\\n\\r\\nmodule.exports.SCChannel = SCChannel;\\r\\n\\r\\n},{\\\"component-emitter\\\":11}],19:[function(_dereq_,module,exports){\\r\\n// Based on https://github.com/dscape/cycle/blob/master/cycle.js\\r\\n\\r\\nmodule.exports = function decycle(object) {\\r\\n// Make a deep copy of an object or array, assuring that there is at most\\r\\n// one instance of each object or array in the resulting structure. The\\r\\n// duplicate references (which might be forming cycles) are replaced with\\r\\n// an object of the form\\r\\n//      {$ref: PATH}\\r\\n// where the PATH is a JSONPath string that locates the first occurance.\\r\\n// So,\\r\\n//      var a = [];\\r\\n//      a[0] = a;\\r\\n//      return JSON.stringify(JSON.decycle(a));\\r\\n// produces the string '[{\\\"$ref\\\":\\\"$\\\"}]'.\\r\\n\\r\\n// JSONPath is used to locate the unique object. $ indicates the top level of\\r\\n// the object or array. [NUMBER] or [STRING] indicates a child member or\\r\\n// property.\\r\\n\\r\\n    var objects = [],   // Keep a reference to each unique object or array\\r\\n        paths = [];     // Keep the path to each unique object or array\\r\\n\\r\\n    return (function derez(value, path) {\\r\\n\\r\\n// The derez recurses through the object, producing the deep copy.\\r\\n\\r\\n        var i,          // The loop counter\\r\\n            name,       // Property name\\r\\n            nu;         // The new object or array\\r\\n\\r\\n// typeof null === 'object', so go on if this value is really an object but not\\r\\n// one of the weird builtin objects.\\r\\n\\r\\n        if (typeof value === 'object' && value !== null &&\\r\\n                !(value instanceof Boolean) &&\\r\\n                !(value instanceof Date)    &&\\r\\n                !(value instanceof Number)  &&\\r\\n                !(value instanceof RegExp)  &&\\r\\n                !(value instanceof String)) {\\r\\n\\r\\n// If the value is an object or array, look to see if we have already\\r\\n// encountered it. If so, return a $ref/path object. This is a hard way,\\r\\n// linear search that will get slower as the number of unique objects grows.\\r\\n\\r\\n            for (i = 0; i < objects.length; i += 1) {\\r\\n                if (objects[i] === value) {\\r\\n                    return {$ref: paths[i]};\\r\\n                }\\r\\n            }\\r\\n\\r\\n// Otherwise, accumulate the unique value and its path.\\r\\n\\r\\n            objects.push(value);\\r\\n            paths.push(path);\\r\\n\\r\\n// If it is an array, replicate the array.\\r\\n\\r\\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\\r\\n                nu = [];\\r\\n                for (i = 0; i < value.length; i += 1) {\\r\\n                    nu[i] = derez(value[i], path + '[' + i + ']');\\r\\n                }\\r\\n            } else {\\r\\n\\r\\n// If it is an object, replicate the object.\\r\\n\\r\\n                nu = {};\\r\\n                for (name in value) {\\r\\n                    if (Object.prototype.hasOwnProperty.call(value, name)) {\\r\\n                        nu[name] = derez(value[name],\\r\\n                            path + '[' + JSON.stringify(name) + ']');\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            return nu;\\r\\n        }\\r\\n        return value;\\r\\n    }(object, '$'));\\r\\n};\\r\\n\\r\\n},{}],20:[function(_dereq_,module,exports){\\r\\nvar decycle = _dereq_('./decycle');\\r\\n\\r\\nvar isStrict = (function () { return !this; })();\\r\\n\\r\\nfunction AuthTokenExpiredError(message, expiry) {\\r\\n  this.name = 'AuthTokenExpiredError';\\r\\n  this.message = message;\\r\\n  this.expiry = expiry;\\r\\n  if (Error.captureStackTrace && !isStrict) {\\r\\n    Error.captureStackTrace(this, arguments.callee);\\r\\n  } else {\\r\\n    this.stack = (new Error()).stack;\\r\\n  }\\r\\n}\\r\\nAuthTokenExpiredError.prototype = Object.create(Error.prototype);\\r\\n\\r\\n\\r\\nfunction AuthTokenInvalidError(message) {\\r\\n  this.name = 'AuthTokenInvalidError';\\r\\n  this.message = message;\\r\\n  if (Error.captureStackTrace && !isStrict) {\\r\\n    Error.captureStackTrace(this, arguments.callee);\\r\\n  } else {\\r\\n    this.stack = (new Error()).stack;\\r\\n  }\\r\\n}\\r\\nAuthTokenInvalidError.prototype = Object.create(Error.prototype);\\r\\n\\r\\n\\r\\nfunction AuthTokenNotBeforeError(message, date) {\\r\\n  this.name = 'AuthTokenNotBeforeError';\\r\\n  this.message = message;\\r\\n  this.date = date;\\r\\n  if (Error.captureStackTrace && !isStrict) {\\r\\n    Error.captureStackTrace(this, arguments.callee);\\r\\n  } else {\\r\\n    this.stack = (new Error()).stack;\\r\\n  }\\r\\n}\\r\\nAuthTokenNotBeforeError.prototype = Object.create(Error.prototype);\\r\\n\\r\\n\\r\\n// For any other auth token error.\\r\\nfunction AuthTokenError(message) {\\r\\n  this.name = 'AuthTokenError';\\r\\n  this.message = message;\\r\\n  if (Error.captureStackTrace && !isStrict) {\\r\\n    Error.captureStackTrace(this, arguments.callee);\\r\\n  } else {\\r\\n    this.stack = (new Error()).stack;\\r\\n  }\\r\\n}\\r\\nAuthTokenError.prototype = Object.create(Error.prototype);\\r\\n\\r\\n\\r\\nfunction SilentMiddlewareBlockedError(message, type) {\\r\\n  this.name = 'SilentMiddlewareBlockedError';\\r\\n  this.message = message;\\r\\n  this.type = type;\\r\\n  if (Error.captureStackTrace && !isStrict) {\\r\\n    Error.captureStackTrace(this, arguments.callee);\\r\\n  } else {\\r\\n    this.stack = (new Error()).stack;\\r\\n  }\\r\\n}\\r\\nSilentMiddlewareBlockedError.prototype = Object.create(Error.prototype);\\r\\n\\r\\n\\r\\nfunction InvalidActionError(message) {\\r\\n  this.name = 'InvalidActionError';\\r\\n  this.message = message;\\r\\n  if (Error.captureStackTrace && !isStrict) {\\r\\n    Error.captureStackTrace(this, arguments.callee);\\r\\n  } else {\\r\\n    this.stack = (new Error()).stack;\\r\\n  }\\r\\n}\\r\\nInvalidActionError.prototype = Object.create(Error.prototype);\\r\\n\\r\\nfunction InvalidArgumentsError(message) {\\r\\n  this.name = 'InvalidArgumentsError';\\r\\n  this.message = message;\\r\\n  if (Error.captureStackTrace && !isStrict) {\\r\\n    Error.captureStackTrace(this, arguments.callee);\\r\\n  } else {\\r\\n    this.stack = (new Error()).stack;\\r\\n  }\\r\\n}\\r\\nInvalidArgumentsError.prototype = Object.create(Error.prototype);\\r\\n\\r\\nfunction InvalidOptionsError(message) {\\r\\n  this.name = 'InvalidOptionsError';\\r\\n  this.message = message;\\r\\n  if (Error.captureStackTrace && !isStrict) {\\r\\n    Error.captureStackTrace(this, arguments.callee);\\r\\n  } else {\\r\\n    this.stack = (new Error()).stack;\\r\\n  }\\r\\n}\\r\\nInvalidOptionsError.prototype = Object.create(Error.prototype);\\r\\n\\r\\n\\r\\nfunction InvalidMessageError(message) {\\r\\n  this.name = 'InvalidMessageError';\\r\\n  this.message = message;\\r\\n  if (Error.captureStackTrace && !isStrict) {\\r\\n    Error.captureStackTrace(this, arguments.callee);\\r\\n  } else {\\r\\n    this.stack = (new Error()).stack;\\r\\n  }\\r\\n}\\r\\nInvalidMessageError.prototype = Object.create(Error.prototype);\\r\\n\\r\\n\\r\\nfunction SocketProtocolError(message, code) {\\r\\n  this.name = 'SocketProtocolError';\\r\\n  this.message = message;\\r\\n  this.code = code;\\r\\n  if (Error.captureStackTrace && !isStrict) {\\r\\n    Error.captureStackTrace(this, arguments.callee);\\r\\n  } else {\\r\\n    this.stack = (new Error()).stack;\\r\\n  }\\r\\n}\\r\\nSocketProtocolError.prototype = Object.create(Error.prototype);\\r\\n\\r\\n\\r\\nfunction ServerProtocolError(message) {\\r\\n  this.name = 'ServerProtocolError';\\r\\n  this.message = message;\\r\\n  if (Error.captureStackTrace && !isStrict) {\\r\\n    Error.captureStackTrace(this, arguments.callee);\\r\\n  } else {\\r\\n    this.stack = (new Error()).stack;\\r\\n  }\\r\\n}\\r\\nServerProtocolError.prototype = Object.create(Error.prototype);\\r\\n\\r\\nfunction HTTPServerError(message) {\\r\\n  this.name = 'HTTPServerError';\\r\\n  this.message = message;\\r\\n  if (Error.captureStackTrace && !isStrict) {\\r\\n    Error.captureStackTrace(this, arguments.callee);\\r\\n  } else {\\r\\n    this.stack = (new Error()).stack;\\r\\n  }\\r\\n}\\r\\nHTTPServerError.prototype = Object.create(Error.prototype);\\r\\n\\r\\n\\r\\nfunction ResourceLimitError(message) {\\r\\n  this.name = 'ResourceLimitError';\\r\\n  this.message = message;\\r\\n  if (Error.captureStackTrace && !isStrict) {\\r\\n    Error.captureStackTrace(this, arguments.callee);\\r\\n  } else {\\r\\n    this.stack = (new Error()).stack;\\r\\n  }\\r\\n}\\r\\nResourceLimitError.prototype = Object.create(Error.prototype);\\r\\n\\r\\n\\r\\nfunction TimeoutError(message) {\\r\\n  this.name = 'TimeoutError';\\r\\n  this.message = message;\\r\\n  if (Error.captureStackTrace && !isStrict) {\\r\\n    Error.captureStackTrace(this, arguments.callee);\\r\\n  } else {\\r\\n    this.stack = (new Error()).stack;\\r\\n  }\\r\\n}\\r\\nTimeoutError.prototype = Object.create(Error.prototype);\\r\\n\\r\\n\\r\\nfunction BadConnectionError(message, type) {\\r\\n  this.name = 'BadConnectionError';\\r\\n  this.message = message;\\r\\n  this.type = type;\\r\\n  if (Error.captureStackTrace && !isStrict) {\\r\\n    Error.captureStackTrace(this, arguments.callee);\\r\\n  } else {\\r\\n    this.stack = (new Error()).stack;\\r\\n  }\\r\\n}\\r\\nBadConnectionError.prototype = Object.create(Error.prototype);\\r\\n\\r\\n\\r\\nfunction BrokerError(message) {\\r\\n  this.name = 'BrokerError';\\r\\n  this.message = message;\\r\\n  if (Error.captureStackTrace && !isStrict) {\\r\\n    Error.captureStackTrace(this, arguments.callee);\\r\\n  } else {\\r\\n    this.stack = (new Error()).stack;\\r\\n  }\\r\\n}\\r\\nBrokerError.prototype = Object.create(Error.prototype);\\r\\n\\r\\n\\r\\nfunction ProcessExitError(message, code) {\\r\\n  this.name = 'ProcessExitError';\\r\\n  this.message = message;\\r\\n  this.code = code;\\r\\n  if (Error.captureStackTrace && !isStrict) {\\r\\n    Error.captureStackTrace(this, arguments.callee);\\r\\n  } else {\\r\\n    this.stack = (new Error()).stack;\\r\\n  }\\r\\n}\\r\\nProcessExitError.prototype = Object.create(Error.prototype);\\r\\n\\r\\n\\r\\nfunction UnknownError(message) {\\r\\n  this.name = 'UnknownError';\\r\\n  this.message = message;\\r\\n  if (Error.captureStackTrace && !isStrict) {\\r\\n    Error.captureStackTrace(this, arguments.callee);\\r\\n  } else {\\r\\n    this.stack = (new Error()).stack;\\r\\n  }\\r\\n}\\r\\nUnknownError.prototype = Object.create(Error.prototype);\\r\\n\\r\\n\\r\\n// Expose all error types.\\r\\n\\r\\nmodule.exports = {\\r\\n  AuthTokenExpiredError: AuthTokenExpiredError,\\r\\n  AuthTokenInvalidError: AuthTokenInvalidError,\\r\\n  AuthTokenNotBeforeError: AuthTokenNotBeforeError,\\r\\n  AuthTokenError: AuthTokenError,\\r\\n  SilentMiddlewareBlockedError: SilentMiddlewareBlockedError,\\r\\n  InvalidActionError: InvalidActionError,\\r\\n  InvalidArgumentsError: InvalidArgumentsError,\\r\\n  InvalidOptionsError: InvalidOptionsError,\\r\\n  InvalidMessageError: InvalidMessageError,\\r\\n  SocketProtocolError: SocketProtocolError,\\r\\n  ServerProtocolError: ServerProtocolError,\\r\\n  HTTPServerError: HTTPServerError,\\r\\n  ResourceLimitError: ResourceLimitError,\\r\\n  TimeoutError: TimeoutError,\\r\\n  BadConnectionError: BadConnectionError,\\r\\n  BrokerError: BrokerError,\\r\\n  ProcessExitError: ProcessExitError,\\r\\n  UnknownError: UnknownError\\r\\n};\\r\\n\\r\\nmodule.exports.socketProtocolErrorStatuses = {\\r\\n  1001: 'Socket was disconnected',\\r\\n  1002: 'A WebSocket protocol error was encountered',\\r\\n  1003: 'Server terminated socket because it received invalid data',\\r\\n  1005: 'Socket closed without status code',\\r\\n  1006: 'Socket hung up',\\r\\n  1007: 'Message format was incorrect',\\r\\n  1008: 'Encountered a policy violation',\\r\\n  1009: 'Message was too big to process',\\r\\n  1010: 'Client ended the connection because the server did not comply with extension requirements',\\r\\n  1011: 'Server encountered an unexpected fatal condition',\\r\\n  4000: 'Server ping timed out',\\r\\n  4001: 'Client pong timed out',\\r\\n  4002: 'Server failed to sign auth token',\\r\\n  4003: 'Failed to complete handshake',\\r\\n  4004: 'Client failed to save auth token',\\r\\n  4005: 'Did not receive #handshake from client before timeout',\\r\\n  4006: 'Failed to bind socket to message broker',\\r\\n  4007: 'Client connection establishment timed out',\\r\\n  4008: 'Server rejected handshake from client'\\r\\n};\\r\\n\\r\\nmodule.exports.socketProtocolIgnoreStatuses = {\\r\\n  1000: 'Socket closed normally',\\r\\n  1001: 'Socket hung up'\\r\\n};\\r\\n\\r\\n// Properties related to error domains cannot be serialized.\\r\\nvar unserializableErrorProperties = {\\r\\n  domain: 1,\\r\\n  domainEmitter: 1,\\r\\n  domainThrown: 1\\r\\n};\\r\\n\\r\\n// Convert an error into a JSON-compatible type which can later be hydrated\\r\\n// back to its *original* form.\\r\\nmodule.exports.dehydrateError = function dehydrateError(error, includeStackTrace) {\\r\\n  var dehydratedError;\\r\\n\\r\\n  if (error && typeof error === 'object') {\\r\\n    dehydratedError = {\\r\\n      message: error.message\\r\\n    };\\r\\n    if (includeStackTrace) {\\r\\n      dehydratedError.stack = error.stack;\\r\\n    }\\r\\n    for (var i in error) {\\r\\n      if (!unserializableErrorProperties[i]) {\\r\\n        dehydratedError[i] = error[i];\\r\\n      }\\r\\n    }\\r\\n  } else if (typeof error === 'function') {\\r\\n    dehydratedError = '[function ' + (error.name || 'anonymous') + ']';\\r\\n  } else {\\r\\n    dehydratedError = error;\\r\\n  }\\r\\n\\r\\n  return decycle(dehydratedError);\\r\\n};\\r\\n\\r\\n// Convert a dehydrated error back to its *original* form.\\r\\nmodule.exports.hydrateError = function hydrateError(error) {\\r\\n  var hydratedError = null;\\r\\n  if (error != null) {\\r\\n    if (typeof error === 'object') {\\r\\n      hydratedError = new Error(error.message);\\r\\n      for (var i in error) {\\r\\n        if (error.hasOwnProperty(i)) {\\r\\n          hydratedError[i] = error[i];\\r\\n        }\\r\\n      }\\r\\n    } else {\\r\\n      hydratedError = error;\\r\\n    }\\r\\n  }\\r\\n  return hydratedError;\\r\\n};\\r\\n\\r\\nmodule.exports.decycle = decycle;\\r\\n\\r\\n},{\\\"./decycle\\\":19}],21:[function(_dereq_,module,exports){\\r\\n(function (global){\\r\\nvar base64Chars = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\r\\nvar validJSONStartRegex = /^[ \\\\n\\\\r\\\\t]*[{\\\\[]/;\\r\\n\\r\\nvar arrayBufferToBase64 = function (arraybuffer) {\\r\\n  var bytes = new Uint8Array(arraybuffer);\\r\\n  var len = bytes.length;\\r\\n  var base64 = '';\\r\\n\\r\\n  for (var i = 0; i < len; i += 3) {\\r\\n    base64 += base64Chars[bytes[i] >> 2];\\r\\n    base64 += base64Chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\\r\\n    base64 += base64Chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\\r\\n    base64 += base64Chars[bytes[i + 2] & 63];\\r\\n  }\\r\\n\\r\\n  if ((len % 3) === 2) {\\r\\n    base64 = base64.substring(0, base64.length - 1) + '=';\\r\\n  } else if (len % 3 === 1) {\\r\\n    base64 = base64.substring(0, base64.length - 2) + '==';\\r\\n  }\\r\\n\\r\\n  return base64;\\r\\n};\\r\\n\\r\\nvar binaryToBase64Replacer = function (key, value) {\\r\\n  if (global.ArrayBuffer && value instanceof global.ArrayBuffer) {\\r\\n    return {\\r\\n      base64: true,\\r\\n      data: arrayBufferToBase64(value)\\r\\n    };\\r\\n  } else if (global.Buffer) {\\r\\n    if (value instanceof global.Buffer){\\r\\n      return {\\r\\n        base64: true,\\r\\n        data: value.toString('base64')\\r\\n      };\\r\\n    }\\r\\n    // Some versions of Node.js convert Buffers to Objects before they are passed to\\r\\n    // the replacer function - Because of this, we need to rehydrate Buffers\\r\\n    // before we can convert them to base64 strings.\\r\\n    if (value && value.type === 'Buffer' && Array.isArray(value.data)) {\\r\\n      var rehydratedBuffer;\\r\\n      if (global.Buffer.from) {\\r\\n        rehydratedBuffer = global.Buffer.from(value.data);\\r\\n      } else {\\r\\n        rehydratedBuffer = new global.Buffer(value.data);\\r\\n      }\\r\\n      return {\\r\\n        base64: true,\\r\\n        data: rehydratedBuffer.toString('base64')\\r\\n      };\\r\\n    }\\r\\n  }\\r\\n  return value;\\r\\n};\\r\\n\\r\\n// Decode the data which was transmitted over the wire to a JavaScript Object in a format which SC understands.\\r\\n// See encode function below for more details.\\r\\nmodule.exports.decode = function (input) {\\r\\n  if (input == null) {\\r\\n   return null;\\r\\n  }\\r\\n  // Leave ping or pong message as is\\r\\n  if (input === '#1' || input === '#2') {\\r\\n    return input;\\r\\n  }\\r\\n  var message = input.toString();\\r\\n\\r\\n  // Performance optimization to detect invalid JSON packet sooner.\\r\\n  if (!validJSONStartRegex.test(message)) {\\r\\n    return message;\\r\\n  }\\r\\n\\r\\n  try {\\r\\n    return JSON.parse(message);\\r\\n  } catch (err) {}\\r\\n  return message;\\r\\n};\\r\\n\\r\\n// Encode a raw JavaScript object (which is in the SC protocol format) into a format for\\r\\n// transfering it over the wire. In this case, we just convert it into a simple JSON string.\\r\\n// If you want to create your own custom codec, you can encode the object into any format\\r\\n// (e.g. binary ArrayBuffer or string with any kind of compression) so long as your decode\\r\\n// function is able to rehydrate that object back into its original JavaScript Object format\\r\\n// (which adheres to the SC protocol).\\r\\n// See https://github.com/SocketCluster/socketcluster/blob/master/socketcluster-protocol.md\\r\\n// for details about the SC protocol.\\r\\nmodule.exports.encode = function (object) {\\r\\n  // Leave ping or pong message as is\\r\\n  if (object === '#1' || object === '#2') {\\r\\n    return object;\\r\\n  }\\r\\n  return JSON.stringify(object, binaryToBase64Replacer);\\r\\n};\\r\\n\\r\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\r\\n},{}],22:[function(_dereq_,module,exports){\\r\\nvar v1 = _dereq_('./v1');\\r\\nvar v4 = _dereq_('./v4');\\r\\n\\r\\nvar uuid = v4;\\r\\nuuid.v1 = v1;\\r\\nuuid.v4 = v4;\\r\\n\\r\\nmodule.exports = uuid;\\r\\n\\r\\n},{\\\"./v1\\\":25,\\\"./v4\\\":26}],23:[function(_dereq_,module,exports){\\r\\n/**\\r\\n * Convert array of 16 byte values to UUID string format of the form:\\r\\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\\r\\n */\\r\\nvar byteToHex = [];\\r\\nfor (var i = 0; i < 256; ++i) {\\r\\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\\r\\n}\\r\\n\\r\\nfunction bytesToUuid(buf, offset) {\\r\\n  var i = offset || 0;\\r\\n  var bth = byteToHex;\\r\\n  return bth[buf[i++]] + bth[buf[i++]] +\\r\\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\\r\\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\\r\\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\\r\\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\\r\\n          bth[buf[i++]] + bth[buf[i++]] +\\r\\n          bth[buf[i++]] + bth[buf[i++]] +\\r\\n          bth[buf[i++]] + bth[buf[i++]];\\r\\n}\\r\\n\\r\\nmodule.exports = bytesToUuid;\\r\\n\\r\\n},{}],24:[function(_dereq_,module,exports){\\r\\n// Unique ID creation requires a high quality random # generator.  In the\\r\\n// browser this is a little complicated due to unknown quality of Math.random()\\r\\n// and inconsistent support for the `crypto` API.  We do the best we can via\\r\\n// feature-detection\\r\\n\\r\\n// getRandomValues needs to be invoked in a context where \\\"this\\\" is a Crypto implementation.\\r\\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues.bind(crypto)) ||\\r\\n                      (typeof(msCrypto) != 'undefined' && msCrypto.getRandomValues.bind(msCrypto));\\r\\nif (getRandomValues) {\\r\\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\\r\\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\\r\\n\\r\\n  module.exports = function whatwgRNG() {\\r\\n    getRandomValues(rnds8);\\r\\n    return rnds8;\\r\\n  };\\r\\n} else {\\r\\n  // Math.random()-based (RNG)\\r\\n  //\\r\\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\\r\\n  // quality.\\r\\n  var rnds = new Array(16);\\r\\n\\r\\n  module.exports = function mathRNG() {\\r\\n    for (var i = 0, r; i < 16; i++) {\\r\\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\\r\\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\\r\\n    }\\r\\n\\r\\n    return rnds;\\r\\n  };\\r\\n}\\r\\n\\r\\n},{}],25:[function(_dereq_,module,exports){\\r\\nvar rng = _dereq_('./lib/rng');\\r\\nvar bytesToUuid = _dereq_('./lib/bytesToUuid');\\r\\n\\r\\n// **`v1()` - Generate time-based UUID**\\r\\n//\\r\\n// Inspired by https://github.com/LiosK/UUID.js\\r\\n// and http://docs.python.org/library/uuid.html\\r\\n\\r\\nvar _nodeId;\\r\\nvar _clockseq;\\r\\n\\r\\n// Previous uuid creation time\\r\\nvar _lastMSecs = 0;\\r\\nvar _lastNSecs = 0;\\r\\n\\r\\n// See https://github.com/broofa/node-uuid for API details\\r\\nfunction v1(options, buf, offset) {\\r\\n  var i = buf && offset || 0;\\r\\n  var b = buf || [];\\r\\n\\r\\n  options = options || {};\\r\\n  var node = options.node || _nodeId;\\r\\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\\r\\n\\r\\n  // node and clockseq need to be initialized to random values if they're not\\r\\n  // specified.  We do this lazily to minimize issues related to insufficient\\r\\n  // system entropy.  See #189\\r\\n  if (node == null || clockseq == null) {\\r\\n    var seedBytes = rng();\\r\\n    if (node == null) {\\r\\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\\r\\n      node = _nodeId = [\\r\\n        seedBytes[0] | 0x01,\\r\\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\\r\\n      ];\\r\\n    }\\r\\n    if (clockseq == null) {\\r\\n      // Per 4.2.2, randomize (14 bit) clockseq\\r\\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\\r\\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\\r\\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\\r\\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\\r\\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\\r\\n\\r\\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\\r\\n  // cycle to simulate higher resolution clock\\r\\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\\r\\n\\r\\n  // Time since last uuid creation (in msecs)\\r\\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\\r\\n\\r\\n  // Per 4.2.1.2, Bump clockseq on clock regression\\r\\n  if (dt < 0 && options.clockseq === undefined) {\\r\\n    clockseq = clockseq + 1 & 0x3fff;\\r\\n  }\\r\\n\\r\\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\\r\\n  // time interval\\r\\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\\r\\n    nsecs = 0;\\r\\n  }\\r\\n\\r\\n  // Per 4.2.1.2 Throw error if too many uuids are requested\\r\\n  if (nsecs >= 10000) {\\r\\n    throw new Error('uuid.v1(): Can\\\\'t create more than 10M uuids/sec');\\r\\n  }\\r\\n\\r\\n  _lastMSecs = msecs;\\r\\n  _lastNSecs = nsecs;\\r\\n  _clockseq = clockseq;\\r\\n\\r\\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\\r\\n  msecs += 12219292800000;\\r\\n\\r\\n  // `time_low`\\r\\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\\r\\n  b[i++] = tl >>> 24 & 0xff;\\r\\n  b[i++] = tl >>> 16 & 0xff;\\r\\n  b[i++] = tl >>> 8 & 0xff;\\r\\n  b[i++] = tl & 0xff;\\r\\n\\r\\n  // `time_mid`\\r\\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\\r\\n  b[i++] = tmh >>> 8 & 0xff;\\r\\n  b[i++] = tmh & 0xff;\\r\\n\\r\\n  // `time_high_and_version`\\r\\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\\r\\n  b[i++] = tmh >>> 16 & 0xff;\\r\\n\\r\\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\\r\\n  b[i++] = clockseq >>> 8 | 0x80;\\r\\n\\r\\n  // `clock_seq_low`\\r\\n  b[i++] = clockseq & 0xff;\\r\\n\\r\\n  // `node`\\r\\n  for (var n = 0; n < 6; ++n) {\\r\\n    b[i + n] = node[n];\\r\\n  }\\r\\n\\r\\n  return buf ? buf : bytesToUuid(b);\\r\\n}\\r\\n\\r\\nmodule.exports = v1;\\r\\n\\r\\n},{\\\"./lib/bytesToUuid\\\":23,\\\"./lib/rng\\\":24}],26:[function(_dereq_,module,exports){\\r\\nvar rng = _dereq_('./lib/rng');\\r\\nvar bytesToUuid = _dereq_('./lib/bytesToUuid');\\r\\n\\r\\nfunction v4(options, buf, offset) {\\r\\n  var i = buf && offset || 0;\\r\\n\\r\\n  if (typeof(options) == 'string') {\\r\\n    buf = options === 'binary' ? new Array(16) : null;\\r\\n    options = null;\\r\\n  }\\r\\n  options = options || {};\\r\\n\\r\\n  var rnds = options.random || (options.rng || rng)();\\r\\n\\r\\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\\r\\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\\r\\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\\r\\n\\r\\n  // Copy bytes to buffer, if provided\\r\\n  if (buf) {\\r\\n    for (var ii = 0; ii < 16; ++ii) {\\r\\n      buf[i + ii] = rnds[ii];\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return buf || bytesToUuid(rnds);\\r\\n}\\r\\n\\r\\nmodule.exports = v4;\\r\\n\\r\\n},{\\\"./lib/bytesToUuid\\\":23,\\\"./lib/rng\\\":24}]},{},[1])(1)\\r\\n});\\r\\n\""
		},
		{
			"name": "sc-codec-min-bin.js",
			"source": "\"(function(f){if(typeof exports===\\\"object\\\"&&typeof module!==\\\"undefined\\\"){module.exports=f()}else if(typeof define===\\\"function\\\"&&define.amd){define([],f)}else{var g;if(typeof window!==\\\"undefined\\\"){g=window}else if(typeof global!==\\\"undefined\\\"){g=global}else if(typeof self!==\\\"undefined\\\"){g=self}else{g=this}g.scCodecMinBin = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\\\"function\\\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\\\"Cannot find module '\\\"+o+\\\"'\\\");throw f.code=\\\"MODULE_NOT_FOUND\\\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\\\"function\\\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\\r\\nvar msgpack = require('msgpack-lite');\\r\\n\\r\\nvar options = {\\r\\n  codec: msgpack.createCodec({\\r\\n    binarraybuffer: true,\\r\\n    preset: false\\r\\n  })\\r\\n};\\r\\n\\r\\nvar compressPublishPacket = function (object) {\\r\\n  if (object.event != '#publish' || object.data == null) {\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  var pubArray = [object.data.channel, object.data.data];\\r\\n\\r\\n  if (object.cid != null) {\\r\\n    pubArray.push(object.cid);\\r\\n  }\\r\\n\\r\\n  object.p = pubArray;\\r\\n\\r\\n  delete object.event;\\r\\n  delete object.data;\\r\\n  delete object.cid;\\r\\n};\\r\\n\\r\\nvar decompressPublishPacket = function (object) {\\r\\n  if (object.p == null) {\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  object.event = '#publish';\\r\\n  object.data = {\\r\\n    channel: object.p[0],\\r\\n    data: object.p[1]\\r\\n  };\\r\\n  if (object.p[2] != null) {\\r\\n    object.cid = object.p[2];\\r\\n  }\\r\\n  delete object.p;\\r\\n};\\r\\n\\r\\nvar compressEmitPacket = function (object) {\\r\\n  if (object.event == null) {\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  object.e = [object.event, object.data];\\r\\n  if (object.cid != null) {\\r\\n    object.e.push(object.cid);\\r\\n  }\\r\\n  delete object.event;\\r\\n  delete object.data;\\r\\n  delete object.cid;\\r\\n};\\r\\n\\r\\nvar decompressEmitPacket = function (object) {\\r\\n  if (object.e == null) {\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  object.event = object.e[0];\\r\\n  object.data = object.e[1];\\r\\n  if (object.e[2] != null) {\\r\\n    object.cid = object.e[2];\\r\\n  }\\r\\n  delete object.e;\\r\\n};\\r\\n\\r\\nvar compressResponsePacket = function (object) {\\r\\n  if (object.rid == null) {\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  object.r = [object.rid, object.error, object.data];\\r\\n\\r\\n  delete object.rid;\\r\\n  delete object.error;\\r\\n  delete object.data;\\r\\n};\\r\\n\\r\\nvar decompressResponsePacket = function (object) {\\r\\n  if (object.r == null) {\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  object.rid = object.r[0];\\r\\n  object.error = object.r[1];\\r\\n  object.data = object.r[2];\\r\\n  delete object.r;\\r\\n};\\r\\n\\r\\nvar clonePacket = function (object) {\\r\\n  var clone = {};\\r\\n  for (var i in object) {\\r\\n    if (object.hasOwnProperty(i)) {\\r\\n      clone[i] = object[i];\\r\\n    }\\r\\n  }\\r\\n  return clone;\\r\\n};\\r\\n\\r\\nvar compressSinglePacket = function (object) {\\r\\n  object = clonePacket(object);\\r\\n  compressPublishPacket(object);\\r\\n  compressEmitPacket(object);\\r\\n  compressResponsePacket(object);\\r\\n  return object;\\r\\n};\\r\\n\\r\\nvar decompressSinglePacket = function (object) {\\r\\n  decompressEmitPacket(object);\\r\\n  decompressPublishPacket(object);\\r\\n  decompressResponsePacket(object);\\r\\n};\\r\\n\\r\\nmodule.exports.encode = function (object) {\\r\\n  if (object) {\\r\\n    if (Array.isArray(object)) {\\r\\n      var len = object.length;\\r\\n      for (var i = 0; i < len; i++) {\\r\\n        object[i] = compressSinglePacket(object[i]);\\r\\n      }\\r\\n    } else if (object.event != null || object.rid != null) {\\r\\n      object = compressSinglePacket(object);\\r\\n    }\\r\\n  }\\r\\n  return msgpack.encode(object, options);\\r\\n};\\r\\n\\r\\nmodule.exports.decode = function (str) {\\r\\n  str = new Uint8Array(str);\\r\\n  var object = msgpack.decode(str, options);\\r\\n  if (Array.isArray(object)) {\\r\\n    var len = object.length;\\r\\n    for (var i = 0; i < len; i++) {\\r\\n      decompressSinglePacket(object[i]);\\r\\n    }\\r\\n  } else {\\r\\n    decompressSinglePacket(object);\\r\\n  }\\r\\n  return object;\\r\\n};\\r\\n\\r\\n},{\\\"msgpack-lite\\\":6}],2:[function(require,module,exports){\\r\\n/**\\r\\n * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)\\r\\n *\\r\\n * @copyright Yusuke Kawasaki\\r\\n * @license MIT\\r\\n * @constructor\\r\\n * @see https://github.com/kawanet/event-lite\\r\\n * @see http://kawanet.github.io/event-lite/EventLite.html\\r\\n * @example\\r\\n * var EventLite = require(\\\"event-lite\\\");\\r\\n *\\r\\n * function MyClass() {...}             // your class\\r\\n *\\r\\n * EventLite.mixin(MyClass.prototype);  // import event methods\\r\\n *\\r\\n * var obj = new MyClass();\\r\\n * obj.on(\\\"foo\\\", function() {...});     // add event listener\\r\\n * obj.once(\\\"bar\\\", function() {...});   // add one-time event listener\\r\\n * obj.emit(\\\"foo\\\");                     // dispatch event\\r\\n * obj.emit(\\\"bar\\\");                     // dispatch another event\\r\\n * obj.off(\\\"foo\\\");                      // remove event listener\\r\\n */\\r\\n\\r\\nfunction EventLite() {\\r\\n  if (!(this instanceof EventLite)) return new EventLite();\\r\\n}\\r\\n\\r\\n(function(EventLite) {\\r\\n  // export the class for node.js\\r\\n  if (\\\"undefined\\\" !== typeof module) module.exports = EventLite;\\r\\n\\r\\n  // property name to hold listeners\\r\\n  var LISTENERS = \\\"listeners\\\";\\r\\n\\r\\n  // methods to export\\r\\n  var methods = {\\r\\n    on: on,\\r\\n    once: once,\\r\\n    off: off,\\r\\n    emit: emit\\r\\n  };\\r\\n\\r\\n  // mixin to self\\r\\n  mixin(EventLite.prototype);\\r\\n\\r\\n  // export mixin function\\r\\n  EventLite.mixin = mixin;\\r\\n\\r\\n  /**\\r\\n   * Import on(), once(), off() and emit() methods into target object.\\r\\n   *\\r\\n   * @function EventLite.mixin\\r\\n   * @param target {Prototype}\\r\\n   */\\r\\n\\r\\n  function mixin(target) {\\r\\n    for (var key in methods) {\\r\\n      target[key] = methods[key];\\r\\n    }\\r\\n    return target;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Add an event listener.\\r\\n   *\\r\\n   * @function EventLite.prototype.on\\r\\n   * @param type {string}\\r\\n   * @param func {Function}\\r\\n   * @returns {EventLite} Self for method chaining\\r\\n   */\\r\\n\\r\\n  function on(type, func) {\\r\\n    getListeners(this, type).push(func);\\r\\n    return this;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Add one-time event listener.\\r\\n   *\\r\\n   * @function EventLite.prototype.once\\r\\n   * @param type {string}\\r\\n   * @param func {Function}\\r\\n   * @returns {EventLite} Self for method chaining\\r\\n   */\\r\\n\\r\\n  function once(type, func) {\\r\\n    var that = this;\\r\\n    wrap.originalListener = func;\\r\\n    getListeners(that, type).push(wrap);\\r\\n    return that;\\r\\n\\r\\n    function wrap() {\\r\\n      off.call(that, type, wrap);\\r\\n      func.apply(this, arguments);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Remove an event listener.\\r\\n   *\\r\\n   * @function EventLite.prototype.off\\r\\n   * @param [type] {string}\\r\\n   * @param [func] {Function}\\r\\n   * @returns {EventLite} Self for method chaining\\r\\n   */\\r\\n\\r\\n  function off(type, func) {\\r\\n    var that = this;\\r\\n    var listners;\\r\\n    if (!arguments.length) {\\r\\n      delete that[LISTENERS];\\r\\n    } else if (!func) {\\r\\n      listners = that[LISTENERS];\\r\\n      if (listners) {\\r\\n        delete listners[type];\\r\\n        if (!Object.keys(listners).length) return off.call(that);\\r\\n      }\\r\\n    } else {\\r\\n      listners = getListeners(that, type, true);\\r\\n      if (listners) {\\r\\n        listners = listners.filter(ne);\\r\\n        if (!listners.length) return off.call(that, type);\\r\\n        that[LISTENERS][type] = listners;\\r\\n      }\\r\\n    }\\r\\n    return that;\\r\\n\\r\\n    function ne(test) {\\r\\n      return test !== func && test.originalListener !== func;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Dispatch (trigger) an event.\\r\\n   *\\r\\n   * @function EventLite.prototype.emit\\r\\n   * @param type {string}\\r\\n   * @param [value] {*}\\r\\n   * @returns {boolean} True when a listener received the event\\r\\n   */\\r\\n\\r\\n  function emit(type, value) {\\r\\n    var that = this;\\r\\n    var listeners = getListeners(that, type, true);\\r\\n    if (!listeners) return false;\\r\\n    var arglen = arguments.length;\\r\\n    if (arglen === 1) {\\r\\n      listeners.forEach(zeroarg);\\r\\n    } else if (arglen === 2) {\\r\\n      listeners.forEach(onearg);\\r\\n    } else {\\r\\n      var args = Array.prototype.slice.call(arguments, 1);\\r\\n      listeners.forEach(moreargs);\\r\\n    }\\r\\n    return !!listeners.length;\\r\\n\\r\\n    function zeroarg(func) {\\r\\n      func.call(that);\\r\\n    }\\r\\n\\r\\n    function onearg(func) {\\r\\n      func.call(that, value);\\r\\n    }\\r\\n\\r\\n    function moreargs(func) {\\r\\n      func.apply(that, args);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @ignore\\r\\n   */\\r\\n\\r\\n  function getListeners(that, type, readonly) {\\r\\n    if (readonly && !that[LISTENERS]) return;\\r\\n    var listeners = that[LISTENERS] || (that[LISTENERS] = {});\\r\\n    return listeners[type] || (listeners[type] = []);\\r\\n  }\\r\\n\\r\\n})(EventLite);\\r\\n\\r\\n},{}],3:[function(require,module,exports){\\r\\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\\r\\n  var e, m\\r\\n  var eLen = nBytes * 8 - mLen - 1\\r\\n  var eMax = (1 << eLen) - 1\\r\\n  var eBias = eMax >> 1\\r\\n  var nBits = -7\\r\\n  var i = isLE ? (nBytes - 1) : 0\\r\\n  var d = isLE ? -1 : 1\\r\\n  var s = buffer[offset + i]\\r\\n\\r\\n  i += d\\r\\n\\r\\n  e = s & ((1 << (-nBits)) - 1)\\r\\n  s >>= (-nBits)\\r\\n  nBits += eLen\\r\\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\\r\\n\\r\\n  m = e & ((1 << (-nBits)) - 1)\\r\\n  e >>= (-nBits)\\r\\n  nBits += mLen\\r\\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\\r\\n\\r\\n  if (e === 0) {\\r\\n    e = 1 - eBias\\r\\n  } else if (e === eMax) {\\r\\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\\r\\n  } else {\\r\\n    m = m + Math.pow(2, mLen)\\r\\n    e = e - eBias\\r\\n  }\\r\\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\\r\\n}\\r\\n\\r\\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\\r\\n  var e, m, c\\r\\n  var eLen = nBytes * 8 - mLen - 1\\r\\n  var eMax = (1 << eLen) - 1\\r\\n  var eBias = eMax >> 1\\r\\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\\r\\n  var i = isLE ? 0 : (nBytes - 1)\\r\\n  var d = isLE ? 1 : -1\\r\\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\\r\\n\\r\\n  value = Math.abs(value)\\r\\n\\r\\n  if (isNaN(value) || value === Infinity) {\\r\\n    m = isNaN(value) ? 1 : 0\\r\\n    e = eMax\\r\\n  } else {\\r\\n    e = Math.floor(Math.log(value) / Math.LN2)\\r\\n    if (value * (c = Math.pow(2, -e)) < 1) {\\r\\n      e--\\r\\n      c *= 2\\r\\n    }\\r\\n    if (e + eBias >= 1) {\\r\\n      value += rt / c\\r\\n    } else {\\r\\n      value += rt * Math.pow(2, 1 - eBias)\\r\\n    }\\r\\n    if (value * c >= 2) {\\r\\n      e++\\r\\n      c /= 2\\r\\n    }\\r\\n\\r\\n    if (e + eBias >= eMax) {\\r\\n      m = 0\\r\\n      e = eMax\\r\\n    } else if (e + eBias >= 1) {\\r\\n      m = (value * c - 1) * Math.pow(2, mLen)\\r\\n      e = e + eBias\\r\\n    } else {\\r\\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\\r\\n      e = 0\\r\\n    }\\r\\n  }\\r\\n\\r\\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\\r\\n\\r\\n  e = (e << mLen) | m\\r\\n  eLen += mLen\\r\\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\\r\\n\\r\\n  buffer[offset + i - d] |= s * 128\\r\\n}\\r\\n\\r\\n},{}],4:[function(require,module,exports){\\r\\n(function (Buffer){\\r\\n// int64-buffer.js\\r\\n\\r\\n/*jshint -W018 */ // Confusing use of '!'.\\r\\n/*jshint -W030 */ // Expected an assignment or function call and instead saw an expression.\\r\\n/*jshint -W093 */ // Did you mean to return a conditional instead of an assignment?\\r\\n\\r\\nvar Uint64BE, Int64BE, Uint64LE, Int64LE;\\r\\n\\r\\n!function(exports) {\\r\\n  // constants\\r\\n\\r\\n  var UNDEFINED = \\\"undefined\\\";\\r\\n  var BUFFER = (UNDEFINED !== typeof Buffer) && Buffer;\\r\\n  var UINT8ARRAY = (UNDEFINED !== typeof Uint8Array) && Uint8Array;\\r\\n  var ARRAYBUFFER = (UNDEFINED !== typeof ArrayBuffer) && ArrayBuffer;\\r\\n  var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];\\r\\n  var isArray = Array.isArray || _isArray;\\r\\n  var BIT32 = 4294967296;\\r\\n  var BIT24 = 16777216;\\r\\n\\r\\n  // storage class\\r\\n\\r\\n  var storage; // Array;\\r\\n\\r\\n  // generate classes\\r\\n\\r\\n  Uint64BE = factory(\\\"Uint64BE\\\", true, true);\\r\\n  Int64BE = factory(\\\"Int64BE\\\", true, false);\\r\\n  Uint64LE = factory(\\\"Uint64LE\\\", false, true);\\r\\n  Int64LE = factory(\\\"Int64LE\\\", false, false);\\r\\n\\r\\n  // class factory\\r\\n\\r\\n  function factory(name, bigendian, unsigned) {\\r\\n    var posH = bigendian ? 0 : 4;\\r\\n    var posL = bigendian ? 4 : 0;\\r\\n    var pos0 = bigendian ? 0 : 3;\\r\\n    var pos1 = bigendian ? 1 : 2;\\r\\n    var pos2 = bigendian ? 2 : 1;\\r\\n    var pos3 = bigendian ? 3 : 0;\\r\\n    var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;\\r\\n    var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;\\r\\n    var proto = Int64.prototype;\\r\\n    var isName = \\\"is\\\" + name;\\r\\n    var _isInt64 = \\\"_\\\" + isName;\\r\\n\\r\\n    // properties\\r\\n    proto.buffer = void 0;\\r\\n    proto.offset = 0;\\r\\n    proto[_isInt64] = true;\\r\\n\\r\\n    // methods\\r\\n    proto.toNumber = toNumber;\\r\\n    proto.toString = toString;\\r\\n    proto.toJSON = toNumber;\\r\\n    proto.toArray = toArray;\\r\\n\\r\\n    // add .toBuffer() method only when Buffer available\\r\\n    if (BUFFER) proto.toBuffer = toBuffer;\\r\\n\\r\\n    // add .toArrayBuffer() method only when Uint8Array available\\r\\n    if (UINT8ARRAY) proto.toArrayBuffer = toArrayBuffer;\\r\\n\\r\\n    // isUint64BE, isInt64BE\\r\\n    Int64[isName] = isInt64;\\r\\n\\r\\n    // CommonJS\\r\\n    exports[name] = Int64;\\r\\n\\r\\n    return Int64;\\r\\n\\r\\n    // constructor\\r\\n    function Int64(buffer, offset, value, raddix) {\\r\\n      if (!(this instanceof Int64)) return new Int64(buffer, offset, value, raddix);\\r\\n      return init(this, buffer, offset, value, raddix);\\r\\n    }\\r\\n\\r\\n    // isUint64BE, isInt64BE\\r\\n    function isInt64(b) {\\r\\n      return !!(b && b[_isInt64]);\\r\\n    }\\r\\n\\r\\n    // initializer\\r\\n    function init(that, buffer, offset, value, raddix) {\\r\\n      if (UINT8ARRAY && ARRAYBUFFER) {\\r\\n        if (buffer instanceof ARRAYBUFFER) buffer = new UINT8ARRAY(buffer);\\r\\n        if (value instanceof ARRAYBUFFER) value = new UINT8ARRAY(value);\\r\\n      }\\r\\n\\r\\n      // Int64BE() style\\r\\n      if (!buffer && !offset && !value && !storage) {\\r\\n        // shortcut to initialize with zero\\r\\n        that.buffer = newArray(ZERO, 0);\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      // Int64BE(value, raddix) style\\r\\n      if (!isValidBuffer(buffer, offset)) {\\r\\n        var _storage = storage || Array;\\r\\n        raddix = offset;\\r\\n        value = buffer;\\r\\n        offset = 0;\\r\\n        buffer = new _storage(8);\\r\\n      }\\r\\n\\r\\n      that.buffer = buffer;\\r\\n      that.offset = offset |= 0;\\r\\n\\r\\n      // Int64BE(buffer, offset) style\\r\\n      if (UNDEFINED === typeof value) return;\\r\\n\\r\\n      // Int64BE(buffer, offset, value, raddix) style\\r\\n      if (\\\"string\\\" === typeof value) {\\r\\n        fromString(buffer, offset, value, raddix || 10);\\r\\n      } else if (isValidBuffer(value, raddix)) {\\r\\n        fromArray(buffer, offset, value, raddix);\\r\\n      } else if (\\\"number\\\" === typeof raddix) {\\r\\n        writeInt32(buffer, offset + posH, value); // high\\r\\n        writeInt32(buffer, offset + posL, raddix); // low\\r\\n      } else if (value > 0) {\\r\\n        fromPositive(buffer, offset, value); // positive\\r\\n      } else if (value < 0) {\\r\\n        fromNegative(buffer, offset, value); // negative\\r\\n      } else {\\r\\n        fromArray(buffer, offset, ZERO, 0); // zero, NaN and others\\r\\n      }\\r\\n    }\\r\\n\\r\\n    function fromString(buffer, offset, str, raddix) {\\r\\n      var pos = 0;\\r\\n      var len = str.length;\\r\\n      var high = 0;\\r\\n      var low = 0;\\r\\n      if (str[0] === \\\"-\\\") pos++;\\r\\n      var sign = pos;\\r\\n      while (pos < len) {\\r\\n        var chr = parseInt(str[pos++], raddix);\\r\\n        if (!(chr >= 0)) break; // NaN\\r\\n        low = low * raddix + chr;\\r\\n        high = high * raddix + Math.floor(low / BIT32);\\r\\n        low %= BIT32;\\r\\n      }\\r\\n      if (sign) {\\r\\n        high = ~high;\\r\\n        if (low) {\\r\\n          low = BIT32 - low;\\r\\n        } else {\\r\\n          high++;\\r\\n        }\\r\\n      }\\r\\n      writeInt32(buffer, offset + posH, high);\\r\\n      writeInt32(buffer, offset + posL, low);\\r\\n    }\\r\\n\\r\\n    function toNumber() {\\r\\n      var buffer = this.buffer;\\r\\n      var offset = this.offset;\\r\\n      var high = readInt32(buffer, offset + posH);\\r\\n      var low = readInt32(buffer, offset + posL);\\r\\n      if (!unsigned) high |= 0; // a trick to get signed\\r\\n      return high ? (high * BIT32 + low) : low;\\r\\n    }\\r\\n\\r\\n    function toString(radix) {\\r\\n      var buffer = this.buffer;\\r\\n      var offset = this.offset;\\r\\n      var high = readInt32(buffer, offset + posH);\\r\\n      var low = readInt32(buffer, offset + posL);\\r\\n      var str = \\\"\\\";\\r\\n      var sign = !unsigned && (high & 0x80000000);\\r\\n      if (sign) {\\r\\n        high = ~high;\\r\\n        low = BIT32 - low;\\r\\n      }\\r\\n      radix = radix || 10;\\r\\n      while (1) {\\r\\n        var mod = (high % radix) * BIT32 + low;\\r\\n        high = Math.floor(high / radix);\\r\\n        low = Math.floor(mod / radix);\\r\\n        str = (mod % radix).toString(radix) + str;\\r\\n        if (!high && !low) break;\\r\\n      }\\r\\n      if (sign) {\\r\\n        str = \\\"-\\\" + str;\\r\\n      }\\r\\n      return str;\\r\\n    }\\r\\n\\r\\n    function writeInt32(buffer, offset, value) {\\r\\n      buffer[offset + pos3] = value & 255;\\r\\n      value = value >> 8;\\r\\n      buffer[offset + pos2] = value & 255;\\r\\n      value = value >> 8;\\r\\n      buffer[offset + pos1] = value & 255;\\r\\n      value = value >> 8;\\r\\n      buffer[offset + pos0] = value & 255;\\r\\n    }\\r\\n\\r\\n    function readInt32(buffer, offset) {\\r\\n      return (buffer[offset + pos0] * BIT24) +\\r\\n        (buffer[offset + pos1] << 16) +\\r\\n        (buffer[offset + pos2] << 8) +\\r\\n        buffer[offset + pos3];\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function toArray(raw) {\\r\\n    var buffer = this.buffer;\\r\\n    var offset = this.offset;\\r\\n    storage = null; // Array\\r\\n    if (raw !== false && offset === 0 && buffer.length === 8 && isArray(buffer)) return buffer;\\r\\n    return newArray(buffer, offset);\\r\\n  }\\r\\n\\r\\n  function toBuffer(raw) {\\r\\n    var buffer = this.buffer;\\r\\n    var offset = this.offset;\\r\\n    storage = BUFFER;\\r\\n    if (raw !== false && offset === 0 && buffer.length === 8 && Buffer.isBuffer(buffer)) return buffer;\\r\\n    var dest = new BUFFER(8);\\r\\n    fromArray(dest, 0, buffer, offset);\\r\\n    return dest;\\r\\n  }\\r\\n\\r\\n  function toArrayBuffer(raw) {\\r\\n    var buffer = this.buffer;\\r\\n    var offset = this.offset;\\r\\n    var arrbuf = buffer.buffer;\\r\\n    storage = UINT8ARRAY;\\r\\n    if (raw !== false && offset === 0 && (arrbuf instanceof ARRAYBUFFER) && arrbuf.byteLength === 8) return arrbuf;\\r\\n    var dest = new UINT8ARRAY(8);\\r\\n    fromArray(dest, 0, buffer, offset);\\r\\n    return dest.buffer;\\r\\n  }\\r\\n\\r\\n  function isValidBuffer(buffer, offset) {\\r\\n    var len = buffer && buffer.length;\\r\\n    offset |= 0;\\r\\n    return len && (offset + 8 <= len) && (\\\"string\\\" !== typeof buffer[offset]);\\r\\n  }\\r\\n\\r\\n  function fromArray(destbuf, destoff, srcbuf, srcoff) {\\r\\n    destoff |= 0;\\r\\n    srcoff |= 0;\\r\\n    for (var i = 0; i < 8; i++) {\\r\\n      destbuf[destoff++] = srcbuf[srcoff++] & 255;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function newArray(buffer, offset) {\\r\\n    return Array.prototype.slice.call(buffer, offset, offset + 8);\\r\\n  }\\r\\n\\r\\n  function fromPositiveBE(buffer, offset, value) {\\r\\n    var pos = offset + 8;\\r\\n    while (pos > offset) {\\r\\n      buffer[--pos] = value & 255;\\r\\n      value /= 256;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function fromNegativeBE(buffer, offset, value) {\\r\\n    var pos = offset + 8;\\r\\n    value++;\\r\\n    while (pos > offset) {\\r\\n      buffer[--pos] = ((-value) & 255) ^ 255;\\r\\n      value /= 256;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function fromPositiveLE(buffer, offset, value) {\\r\\n    var end = offset + 8;\\r\\n    while (offset < end) {\\r\\n      buffer[offset++] = value & 255;\\r\\n      value /= 256;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function fromNegativeLE(buffer, offset, value) {\\r\\n    var end = offset + 8;\\r\\n    value++;\\r\\n    while (offset < end) {\\r\\n      buffer[offset++] = ((-value) & 255) ^ 255;\\r\\n      value /= 256;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // https://github.com/retrofox/is-array\\r\\n  function _isArray(val) {\\r\\n    return !!val && \\\"[object Array]\\\" == Object.prototype.toString.call(val);\\r\\n  }\\r\\n\\r\\n}(typeof exports === 'object' && typeof exports.nodeName !== 'string' ? exports : (this || {}));\\r\\n\\r\\n}).call(this,require(\\\"buffer\\\").Buffer)\\r\\n},{\\\"buffer\\\":35}],5:[function(require,module,exports){\\r\\nvar toString = {}.toString;\\r\\n\\r\\nmodule.exports = Array.isArray || function (arr) {\\r\\n  return toString.call(arr) == '[object Array]';\\r\\n};\\r\\n\\r\\n},{}],6:[function(require,module,exports){\\r\\n// browser.js\\r\\n\\r\\nexports.encode = require(\\\"./encode\\\").encode;\\r\\nexports.decode = require(\\\"./decode\\\").decode;\\r\\n\\r\\nexports.Encoder = require(\\\"./encoder\\\").Encoder;\\r\\nexports.Decoder = require(\\\"./decoder\\\").Decoder;\\r\\n\\r\\nexports.createCodec = require(\\\"./ext\\\").createCodec;\\r\\nexports.codec = require(\\\"./codec\\\").codec;\\r\\n\\r\\n},{\\\"./codec\\\":15,\\\"./decode\\\":17,\\\"./decoder\\\":18,\\\"./encode\\\":20,\\\"./encoder\\\":21,\\\"./ext\\\":25}],7:[function(require,module,exports){\\r\\n(function (Buffer){\\r\\n/* globals Buffer */\\r\\n\\r\\nmodule.exports =\\r\\n  c((\\\"undefined\\\" !== typeof Buffer) && Buffer) ||\\r\\n  c(this.Buffer) ||\\r\\n  c((\\\"undefined\\\" !== typeof window) && window.Buffer) ||\\r\\n  this.Buffer;\\r\\n\\r\\nfunction c(B) {\\r\\n  return B && B.isBuffer && B;\\r\\n}\\r\\n}).call(this,require(\\\"buffer\\\").Buffer)\\r\\n},{\\\"buffer\\\":35}],8:[function(require,module,exports){\\r\\n// buffer-lite.js\\r\\n\\r\\nvar MAXBUFLEN = 8192;\\r\\n\\r\\nexports.copy = copy;\\r\\nexports.toString = toString;\\r\\nexports.write = write;\\r\\n\\r\\n/**\\r\\n * Buffer.prototype.write()\\r\\n *\\r\\n * @param string {String}\\r\\n * @param [offset] {Number}\\r\\n * @returns {Number}\\r\\n */\\r\\n\\r\\nfunction write(string, offset) {\\r\\n  var buffer = this;\\r\\n  var index = offset || (offset |= 0);\\r\\n  var length = string.length;\\r\\n  var chr = 0;\\r\\n  var i = 0;\\r\\n  while (i < length) {\\r\\n    chr = string.charCodeAt(i++);\\r\\n\\r\\n    if (chr < 128) {\\r\\n      buffer[index++] = chr;\\r\\n    } else if (chr < 0x800) {\\r\\n      // 2 bytes\\r\\n      buffer[index++] = 0xC0 | (chr >>> 6);\\r\\n      buffer[index++] = 0x80 | (chr & 0x3F);\\r\\n    } else if (chr < 0xD800 || chr > 0xDFFF) {\\r\\n      // 3 bytes\\r\\n      buffer[index++] = 0xE0 | (chr  >>> 12);\\r\\n      buffer[index++] = 0x80 | ((chr >>> 6)  & 0x3F);\\r\\n      buffer[index++] = 0x80 | (chr          & 0x3F);\\r\\n    } else {\\r\\n      // 4 bytes - surrogate pair\\r\\n      chr = (((chr - 0xD800) << 10) | (string.charCodeAt(i++) - 0xDC00)) + 0x10000;\\r\\n      buffer[index++] = 0xF0 | (chr >>> 18);\\r\\n      buffer[index++] = 0x80 | ((chr >>> 12) & 0x3F);\\r\\n      buffer[index++] = 0x80 | ((chr >>> 6)  & 0x3F);\\r\\n      buffer[index++] = 0x80 | (chr          & 0x3F);\\r\\n    }\\r\\n  }\\r\\n  return index - offset;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Buffer.prototype.toString()\\r\\n *\\r\\n * @param [encoding] {String} ignored\\r\\n * @param [start] {Number}\\r\\n * @param [end] {Number}\\r\\n * @returns {String}\\r\\n */\\r\\n\\r\\nfunction toString(encoding, start, end) {\\r\\n  var buffer = this;\\r\\n  var index = start|0;\\r\\n  if (!end) end = buffer.length;\\r\\n  var string = '';\\r\\n  var chr = 0;\\r\\n\\r\\n  while (index < end) {\\r\\n    chr = buffer[index++];\\r\\n    if (chr < 128) {\\r\\n      string += String.fromCharCode(chr);\\r\\n      continue;\\r\\n    }\\r\\n\\r\\n    if ((chr & 0xE0) === 0xC0) {\\r\\n      // 2 bytes\\r\\n      chr = (chr & 0x1F) << 6 |\\r\\n            (buffer[index++] & 0x3F);\\r\\n\\r\\n    } else if ((chr & 0xF0) === 0xE0) {\\r\\n      // 3 bytes\\r\\n      chr = (chr & 0x0F)             << 12 |\\r\\n            (buffer[index++] & 0x3F) << 6  |\\r\\n            (buffer[index++] & 0x3F);\\r\\n\\r\\n    } else if ((chr & 0xF8) === 0xF0) {\\r\\n      // 4 bytes\\r\\n      chr = (chr & 0x07)             << 18 |\\r\\n            (buffer[index++] & 0x3F) << 12 |\\r\\n            (buffer[index++] & 0x3F) << 6  |\\r\\n            (buffer[index++] & 0x3F);\\r\\n    }\\r\\n\\r\\n    if (chr >= 0x010000) {\\r\\n      // A surrogate pair\\r\\n      chr -= 0x010000;\\r\\n\\r\\n      string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);\\r\\n    } else {\\r\\n      string += String.fromCharCode(chr);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return string;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Buffer.prototype.copy()\\r\\n *\\r\\n * @param target {Buffer}\\r\\n * @param [targetStart] {Number}\\r\\n * @param [start] {Number}\\r\\n * @param [end] {Number}\\r\\n * @returns {number}\\r\\n */\\r\\n\\r\\nfunction copy(target, targetStart, start, end) {\\r\\n  var i;\\r\\n  if (!start) start = 0;\\r\\n  if (!end && end !== 0) end = this.length;\\r\\n  if (!targetStart) targetStart = 0;\\r\\n  var len = end - start;\\r\\n\\r\\n  if (target === this && start < targetStart && targetStart < end) {\\r\\n    // descending\\r\\n    for (i = len - 1; i >= 0; i--) {\\r\\n      target[i + targetStart] = this[i + start];\\r\\n    }\\r\\n  } else {\\r\\n    // ascending\\r\\n    for (i = 0; i < len; i++) {\\r\\n      target[i + targetStart] = this[i + start];\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return len;\\r\\n}\\r\\n\\r\\n},{}],9:[function(require,module,exports){\\r\\n// bufferish-array.js\\r\\n\\r\\nvar Bufferish = require(\\\"./bufferish\\\");\\r\\n\\r\\nvar exports = module.exports = alloc(0);\\r\\n\\r\\nexports.alloc = alloc;\\r\\nexports.concat = Bufferish.concat;\\r\\nexports.from = from;\\r\\n\\r\\n/**\\r\\n * @param size {Number}\\r\\n * @returns {Buffer|Uint8Array|Array}\\r\\n */\\r\\n\\r\\nfunction alloc(size) {\\r\\n  return new Array(size);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @param value {Array|ArrayBuffer|Buffer|String}\\r\\n * @returns {Array}\\r\\n */\\r\\n\\r\\nfunction from(value) {\\r\\n  if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {\\r\\n    // TypedArray to Uint8Array\\r\\n    value = Bufferish.Uint8Array.from(value);\\r\\n  } else if (Bufferish.isArrayBuffer(value)) {\\r\\n    // ArrayBuffer to Uint8Array\\r\\n    value = new Uint8Array(value);\\r\\n  } else if (typeof value === \\\"string\\\") {\\r\\n    // String to Array\\r\\n    return Bufferish.from.call(exports, value);\\r\\n  } else if (typeof value === \\\"number\\\") {\\r\\n    throw new TypeError('\\\"value\\\" argument must not be a number');\\r\\n  }\\r\\n\\r\\n  // Array-like to Array\\r\\n  return Array.prototype.slice.call(value);\\r\\n}\\r\\n\\r\\n},{\\\"./bufferish\\\":13}],10:[function(require,module,exports){\\r\\n// bufferish-buffer.js\\r\\n\\r\\nvar Bufferish = require(\\\"./bufferish\\\");\\r\\nvar Buffer = Bufferish.global;\\r\\n\\r\\nvar exports = module.exports = Bufferish.hasBuffer ? alloc(0) : [];\\r\\n\\r\\nexports.alloc = Bufferish.hasBuffer && Buffer.alloc || alloc;\\r\\nexports.concat = Bufferish.concat;\\r\\nexports.from = from;\\r\\n\\r\\n/**\\r\\n * @param size {Number}\\r\\n * @returns {Buffer|Uint8Array|Array}\\r\\n */\\r\\n\\r\\nfunction alloc(size) {\\r\\n  return new Buffer(size);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @param value {Array|ArrayBuffer|Buffer|String}\\r\\n * @returns {Buffer}\\r\\n */\\r\\n\\r\\nfunction from(value) {\\r\\n  if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {\\r\\n    // TypedArray to Uint8Array\\r\\n    value = Bufferish.Uint8Array.from(value);\\r\\n  } else if (Bufferish.isArrayBuffer(value)) {\\r\\n    // ArrayBuffer to Uint8Array\\r\\n    value = new Uint8Array(value);\\r\\n  } else if (typeof value === \\\"string\\\") {\\r\\n    // String to Buffer\\r\\n    return Bufferish.from.call(exports, value);\\r\\n  } else if (typeof value === \\\"number\\\") {\\r\\n    throw new TypeError('\\\"value\\\" argument must not be a number');\\r\\n  }\\r\\n\\r\\n  // Array-like to Buffer\\r\\n  if (Buffer.from && Buffer.from.length !== 1) {\\r\\n    return Buffer.from(value); // node v6+\\r\\n  } else {\\r\\n    return new Buffer(value); // node v4\\r\\n  }\\r\\n}\\r\\n\\r\\n},{\\\"./bufferish\\\":13}],11:[function(require,module,exports){\\r\\n// bufferish-proto.js\\r\\n\\r\\n/* jshint eqnull:true */\\r\\n\\r\\nvar BufferLite = require(\\\"./buffer-lite\\\");\\r\\n\\r\\nexports.copy = copy;\\r\\nexports.slice = slice;\\r\\nexports.toString = toString;\\r\\nexports.write = gen(\\\"write\\\");\\r\\n\\r\\nvar Bufferish = require(\\\"./bufferish\\\");\\r\\nvar Buffer = Bufferish.global;\\r\\n\\r\\nvar isBufferShim = Bufferish.hasBuffer && (\\\"TYPED_ARRAY_SUPPORT\\\" in Buffer);\\r\\nvar brokenTypedArray = isBufferShim && !Buffer.TYPED_ARRAY_SUPPORT;\\r\\n\\r\\n/**\\r\\n * @param target {Buffer|Uint8Array|Array}\\r\\n * @param [targetStart] {Number}\\r\\n * @param [start] {Number}\\r\\n * @param [end] {Number}\\r\\n * @returns {Buffer|Uint8Array|Array}\\r\\n */\\r\\n\\r\\nfunction copy(target, targetStart, start, end) {\\r\\n  var thisIsBuffer = Bufferish.isBuffer(this);\\r\\n  var targetIsBuffer = Bufferish.isBuffer(target);\\r\\n  if (thisIsBuffer && targetIsBuffer) {\\r\\n    // Buffer to Buffer\\r\\n    return this.copy(target, targetStart, start, end);\\r\\n  } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer &&\\r\\n    Bufferish.isView(this) && Bufferish.isView(target)) {\\r\\n    // Uint8Array to Uint8Array (except for minor some browsers)\\r\\n    var buffer = (start || end != null) ? slice.call(this, start, end) : this;\\r\\n    target.set(buffer, targetStart);\\r\\n    return buffer.length;\\r\\n  } else {\\r\\n    // other cases\\r\\n    return BufferLite.copy.call(this, target, targetStart, start, end);\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @param [start] {Number}\\r\\n * @param [end] {Number}\\r\\n * @returns {Buffer|Uint8Array|Array}\\r\\n */\\r\\n\\r\\nfunction slice(start, end) {\\r\\n  // for Buffer, Uint8Array (except for minor some browsers) and Array\\r\\n  var f = this.slice || (!brokenTypedArray && this.subarray);\\r\\n  if (f) return f.call(this, start, end);\\r\\n\\r\\n  // Uint8Array (for minor some browsers)\\r\\n  var target = Bufferish.alloc.call(this, end - start);\\r\\n  copy.call(this, target, 0, start, end);\\r\\n  return target;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Buffer.prototype.toString()\\r\\n *\\r\\n * @param [encoding] {String} ignored\\r\\n * @param [start] {Number}\\r\\n * @param [end] {Number}\\r\\n * @returns {String}\\r\\n */\\r\\n\\r\\nfunction toString(encoding, start, end) {\\r\\n  var f = (!isBufferShim && Bufferish.isBuffer(this)) ? this.toString : BufferLite.toString;\\r\\n  return f.apply(this, arguments);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @private\\r\\n */\\r\\n\\r\\nfunction gen(method) {\\r\\n  return wrap;\\r\\n\\r\\n  function wrap() {\\r\\n    var f = this[method] || BufferLite[method];\\r\\n    return f.apply(this, arguments);\\r\\n  }\\r\\n}\\r\\n\\r\\n},{\\\"./buffer-lite\\\":8,\\\"./bufferish\\\":13}],12:[function(require,module,exports){\\r\\n// bufferish-uint8array.js\\r\\n\\r\\nvar Bufferish = require(\\\"./bufferish\\\");\\r\\n\\r\\nvar exports = module.exports = Bufferish.hasArrayBuffer ? alloc(0) : [];\\r\\n\\r\\nexports.alloc = alloc;\\r\\nexports.concat = Bufferish.concat;\\r\\nexports.from = from;\\r\\n\\r\\n/**\\r\\n * @param size {Number}\\r\\n * @returns {Buffer|Uint8Array|Array}\\r\\n */\\r\\n\\r\\nfunction alloc(size) {\\r\\n  return new Uint8Array(size);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @param value {Array|ArrayBuffer|Buffer|String}\\r\\n * @returns {Uint8Array}\\r\\n */\\r\\n\\r\\nfunction from(value) {\\r\\n  if (Bufferish.isView(value)) {\\r\\n    // TypedArray to ArrayBuffer\\r\\n    var byteOffset = value.byteOffset;\\r\\n    var byteLength = value.byteLength;\\r\\n    value = value.buffer;\\r\\n    if (value.byteLength !== byteLength) {\\r\\n      if (value.slice) {\\r\\n        value = value.slice(byteOffset, byteOffset + byteLength);\\r\\n      } else {\\r\\n        // Android 4.1 does not have ArrayBuffer.prototype.slice\\r\\n        value = new Uint8Array(value);\\r\\n        if (value.byteLength !== byteLength) {\\r\\n          // TypedArray to ArrayBuffer to Uint8Array to Array\\r\\n          value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength);\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  } else if (typeof value === \\\"string\\\") {\\r\\n    // String to Uint8Array\\r\\n    return Bufferish.from.call(exports, value);\\r\\n  } else if (typeof value === \\\"number\\\") {\\r\\n    throw new TypeError('\\\"value\\\" argument must not be a number');\\r\\n  }\\r\\n\\r\\n  return new Uint8Array(value);\\r\\n}\\r\\n\\r\\n},{\\\"./bufferish\\\":13}],13:[function(require,module,exports){\\r\\n// bufferish.js\\r\\n\\r\\nvar Buffer = exports.global = require(\\\"./buffer-global\\\");\\r\\nvar hasBuffer = exports.hasBuffer = Buffer && !!Buffer.isBuffer;\\r\\nvar hasArrayBuffer = exports.hasArrayBuffer = (\\\"undefined\\\" !== typeof ArrayBuffer);\\r\\n\\r\\nvar isArray = exports.isArray = require(\\\"isarray\\\");\\r\\nexports.isArrayBuffer = hasArrayBuffer ? isArrayBuffer : _false;\\r\\nvar isBuffer = exports.isBuffer = hasBuffer ? Buffer.isBuffer : _false;\\r\\nvar isView = exports.isView = hasArrayBuffer ? (ArrayBuffer.isView || _is(\\\"ArrayBuffer\\\", \\\"buffer\\\")) : _false;\\r\\n\\r\\nexports.alloc = alloc;\\r\\nexports.concat = concat;\\r\\nexports.from = from;\\r\\n\\r\\nvar BufferArray = exports.Array = require(\\\"./bufferish-array\\\");\\r\\nvar BufferBuffer = exports.Buffer = require(\\\"./bufferish-buffer\\\");\\r\\nvar BufferUint8Array = exports.Uint8Array = require(\\\"./bufferish-uint8array\\\");\\r\\nvar BufferProto = exports.prototype = require(\\\"./bufferish-proto\\\");\\r\\n\\r\\n/**\\r\\n * @param value {Array|ArrayBuffer|Buffer|String}\\r\\n * @returns {Buffer|Uint8Array|Array}\\r\\n */\\r\\n\\r\\nfunction from(value) {\\r\\n  if (typeof value === \\\"string\\\") {\\r\\n    return fromString.call(this, value);\\r\\n  } else {\\r\\n    return auto(this).from(value);\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @param size {Number}\\r\\n * @returns {Buffer|Uint8Array|Array}\\r\\n */\\r\\n\\r\\nfunction alloc(size) {\\r\\n  return auto(this).alloc(size);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @param list {Array} array of (Buffer|Uint8Array|Array)s\\r\\n * @param [length]\\r\\n * @returns {Buffer|Uint8Array|Array}\\r\\n */\\r\\n\\r\\nfunction concat(list, length) {\\r\\n  if (!length) {\\r\\n    length = 0;\\r\\n    Array.prototype.forEach.call(list, dryrun);\\r\\n  }\\r\\n  var ref = (this !== exports) && this || list[0];\\r\\n  var result = alloc.call(ref, length);\\r\\n  var offset = 0;\\r\\n  Array.prototype.forEach.call(list, append);\\r\\n  return result;\\r\\n\\r\\n  function dryrun(buffer) {\\r\\n    length += buffer.length;\\r\\n  }\\r\\n\\r\\n  function append(buffer) {\\r\\n    offset += BufferProto.copy.call(buffer, result, offset);\\r\\n  }\\r\\n}\\r\\n\\r\\nvar _isArrayBuffer = _is(\\\"ArrayBuffer\\\");\\r\\n\\r\\nfunction isArrayBuffer(value) {\\r\\n  return (value instanceof ArrayBuffer) || _isArrayBuffer(value);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @private\\r\\n */\\r\\n\\r\\nfunction fromString(value) {\\r\\n  var expected = value.length * 3;\\r\\n  var that = alloc.call(this, expected);\\r\\n  var actual = BufferProto.write.call(that, value);\\r\\n  if (expected !== actual) {\\r\\n    that = BufferProto.slice.call(that, 0, actual);\\r\\n  }\\r\\n  return that;\\r\\n}\\r\\n\\r\\nfunction auto(that) {\\r\\n  return isBuffer(that) ? BufferBuffer\\r\\n    : isView(that) ? BufferUint8Array\\r\\n    : isArray(that) ? BufferArray\\r\\n    : hasBuffer ? BufferBuffer\\r\\n    : hasArrayBuffer ? BufferUint8Array\\r\\n    : BufferArray;\\r\\n}\\r\\n\\r\\nfunction _false() {\\r\\n  return false;\\r\\n}\\r\\n\\r\\nfunction _is(name, key) {\\r\\n  /* jshint eqnull:true */\\r\\n  name = \\\"[object \\\" + name + \\\"]\\\";\\r\\n  return function(value) {\\r\\n    return (value != null) && {}.toString.call(key ? value[key] : value) === name;\\r\\n  };\\r\\n}\\r\\n},{\\\"./buffer-global\\\":7,\\\"./bufferish-array\\\":9,\\\"./bufferish-buffer\\\":10,\\\"./bufferish-proto\\\":11,\\\"./bufferish-uint8array\\\":12,\\\"isarray\\\":5}],14:[function(require,module,exports){\\r\\n// codec-base.js\\r\\n\\r\\nvar IS_ARRAY = require(\\\"isarray\\\");\\r\\n\\r\\nexports.createCodec = createCodec;\\r\\nexports.install = install;\\r\\nexports.filter = filter;\\r\\n\\r\\nvar Bufferish = require(\\\"./bufferish\\\");\\r\\n\\r\\nfunction Codec(options) {\\r\\n  if (!(this instanceof Codec)) return new Codec(options);\\r\\n  this.options = options;\\r\\n  this.init();\\r\\n}\\r\\n\\r\\nCodec.prototype.init = function() {\\r\\n  var options = this.options;\\r\\n\\r\\n  if (options && options.uint8array) {\\r\\n    this.bufferish = Bufferish.Uint8Array;\\r\\n  }\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\nfunction install(props) {\\r\\n  for (var key in props) {\\r\\n    Codec.prototype[key] = add(Codec.prototype[key], props[key]);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction add(a, b) {\\r\\n  return (a && b) ? ab : (a || b);\\r\\n\\r\\n  function ab() {\\r\\n    a.apply(this, arguments);\\r\\n    return b.apply(this, arguments);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction join(filters) {\\r\\n  filters = filters.slice();\\r\\n\\r\\n  return function(value) {\\r\\n    return filters.reduce(iterator, value);\\r\\n  };\\r\\n\\r\\n  function iterator(value, filter) {\\r\\n    return filter(value);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction filter(filter) {\\r\\n  return IS_ARRAY(filter) ? join(filter) : filter;\\r\\n}\\r\\n\\r\\n// @public\\r\\n// msgpack.createCodec()\\r\\n\\r\\nfunction createCodec(options) {\\r\\n  return new Codec(options);\\r\\n}\\r\\n\\r\\n// default shared codec\\r\\n\\r\\nexports.preset = createCodec({preset: true});\\r\\n\\r\\n},{\\\"./bufferish\\\":13,\\\"isarray\\\":5}],15:[function(require,module,exports){\\r\\n// codec.js\\r\\n\\r\\n// load both interfaces\\r\\nrequire(\\\"./read-core\\\");\\r\\nrequire(\\\"./write-core\\\");\\r\\n\\r\\n// @public\\r\\n// msgpack.codec.preset\\r\\n\\r\\nexports.codec = {\\r\\n  preset: require(\\\"./codec-base\\\").preset\\r\\n};\\r\\n\\r\\n},{\\\"./codec-base\\\":14,\\\"./read-core\\\":27,\\\"./write-core\\\":30}],16:[function(require,module,exports){\\r\\n// decode-buffer.js\\r\\n\\r\\nexports.DecodeBuffer = DecodeBuffer;\\r\\n\\r\\nvar preset = require(\\\"./read-core\\\").preset;\\r\\n\\r\\nvar FlexDecoder = require(\\\"./flex-buffer\\\").FlexDecoder;\\r\\n\\r\\nFlexDecoder.mixin(DecodeBuffer.prototype);\\r\\n\\r\\nfunction DecodeBuffer(options) {\\r\\n  if (!(this instanceof DecodeBuffer)) return new DecodeBuffer(options);\\r\\n\\r\\n  if (options) {\\r\\n    this.options = options;\\r\\n    if (options.codec) {\\r\\n      var codec = this.codec = options.codec;\\r\\n      if (codec.bufferish) this.bufferish = codec.bufferish;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nDecodeBuffer.prototype.codec = preset;\\r\\n\\r\\nDecodeBuffer.prototype.fetch = function() {\\r\\n  return this.codec.decode(this);\\r\\n};\\r\\n\\r\\n},{\\\"./flex-buffer\\\":26,\\\"./read-core\\\":27}],17:[function(require,module,exports){\\r\\n// decode.js\\r\\n\\r\\nexports.decode = decode;\\r\\n\\r\\nvar DecodeBuffer = require(\\\"./decode-buffer\\\").DecodeBuffer;\\r\\n\\r\\nfunction decode(input, options) {\\r\\n  var decoder = new DecodeBuffer(options);\\r\\n  decoder.write(input);\\r\\n  return decoder.read();\\r\\n}\\r\\n},{\\\"./decode-buffer\\\":16}],18:[function(require,module,exports){\\r\\n// decoder.js\\r\\n\\r\\nexports.Decoder = Decoder;\\r\\n\\r\\nvar EventLite = require(\\\"event-lite\\\");\\r\\nvar DecodeBuffer = require(\\\"./decode-buffer\\\").DecodeBuffer;\\r\\n\\r\\nfunction Decoder(options) {\\r\\n  if (!(this instanceof Decoder)) return new Decoder(options);\\r\\n  DecodeBuffer.call(this, options);\\r\\n}\\r\\n\\r\\nDecoder.prototype = new DecodeBuffer();\\r\\n\\r\\nEventLite.mixin(Decoder.prototype);\\r\\n\\r\\nDecoder.prototype.decode = function(chunk) {\\r\\n  if (arguments.length) this.write(chunk);\\r\\n  this.flush();\\r\\n};\\r\\n\\r\\nDecoder.prototype.push = function(chunk) {\\r\\n  this.emit(\\\"data\\\", chunk);\\r\\n};\\r\\n\\r\\nDecoder.prototype.end = function(chunk) {\\r\\n  this.decode(chunk);\\r\\n  this.emit(\\\"end\\\");\\r\\n};\\r\\n\\r\\n},{\\\"./decode-buffer\\\":16,\\\"event-lite\\\":2}],19:[function(require,module,exports){\\r\\n// encode-buffer.js\\r\\n\\r\\nexports.EncodeBuffer = EncodeBuffer;\\r\\n\\r\\nvar preset = require(\\\"./write-core\\\").preset;\\r\\n\\r\\nvar FlexEncoder = require(\\\"./flex-buffer\\\").FlexEncoder;\\r\\n\\r\\nFlexEncoder.mixin(EncodeBuffer.prototype);\\r\\n\\r\\nfunction EncodeBuffer(options) {\\r\\n  if (!(this instanceof EncodeBuffer)) return new EncodeBuffer(options);\\r\\n\\r\\n  if (options) {\\r\\n    this.options = options;\\r\\n    if (options.codec) {\\r\\n      var codec = this.codec = options.codec;\\r\\n      if (codec.bufferish) this.bufferish = codec.bufferish;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nEncodeBuffer.prototype.codec = preset;\\r\\n\\r\\nEncodeBuffer.prototype.write = function(input) {\\r\\n  this.codec.encode(this, input);\\r\\n};\\r\\n\\r\\n},{\\\"./flex-buffer\\\":26,\\\"./write-core\\\":30}],20:[function(require,module,exports){\\r\\n// encode.js\\r\\n\\r\\nexports.encode = encode;\\r\\n\\r\\nvar EncodeBuffer = require(\\\"./encode-buffer\\\").EncodeBuffer;\\r\\n\\r\\nfunction encode(input, options) {\\r\\n  var encoder = new EncodeBuffer(options);\\r\\n  encoder.write(input);\\r\\n  return encoder.read();\\r\\n}\\r\\n\\r\\n},{\\\"./encode-buffer\\\":19}],21:[function(require,module,exports){\\r\\n// encoder.js\\r\\n\\r\\nexports.Encoder = Encoder;\\r\\n\\r\\nvar EventLite = require(\\\"event-lite\\\");\\r\\nvar EncodeBuffer = require(\\\"./encode-buffer\\\").EncodeBuffer;\\r\\n\\r\\nfunction Encoder(options) {\\r\\n  if (!(this instanceof Encoder)) return new Encoder(options);\\r\\n  EncodeBuffer.call(this, options);\\r\\n}\\r\\n\\r\\nEncoder.prototype = new EncodeBuffer();\\r\\n\\r\\nEventLite.mixin(Encoder.prototype);\\r\\n\\r\\nEncoder.prototype.encode = function(chunk) {\\r\\n  this.write(chunk);\\r\\n  this.emit(\\\"data\\\", this.read());\\r\\n};\\r\\n\\r\\nEncoder.prototype.end = function(chunk) {\\r\\n  if (arguments.length) this.encode(chunk);\\r\\n  this.flush();\\r\\n  this.emit(\\\"end\\\");\\r\\n};\\r\\n\\r\\n},{\\\"./encode-buffer\\\":19,\\\"event-lite\\\":2}],22:[function(require,module,exports){\\r\\n// ext-buffer.js\\r\\n\\r\\nexports.ExtBuffer = ExtBuffer;\\r\\n\\r\\nvar Bufferish = require(\\\"./bufferish\\\");\\r\\n\\r\\nfunction ExtBuffer(buffer, type) {\\r\\n  if (!(this instanceof ExtBuffer)) return new ExtBuffer(buffer, type);\\r\\n  this.buffer = Bufferish.from(buffer);\\r\\n  this.type = type;\\r\\n}\\r\\n\\r\\n},{\\\"./bufferish\\\":13}],23:[function(require,module,exports){\\r\\n// ext-packer.js\\r\\n\\r\\nexports.setExtPackers = setExtPackers;\\r\\n\\r\\nvar Bufferish = require(\\\"./bufferish\\\");\\r\\nvar Buffer = Bufferish.global;\\r\\nvar packTypedArray = Bufferish.Uint8Array.from;\\r\\nvar _encode;\\r\\n\\r\\nvar ERROR_COLUMNS = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};\\r\\n\\r\\nfunction setExtPackers(codec) {\\r\\n  codec.addExtPacker(0x0E, Error, [packError, encode]);\\r\\n  codec.addExtPacker(0x01, EvalError, [packError, encode]);\\r\\n  codec.addExtPacker(0x02, RangeError, [packError, encode]);\\r\\n  codec.addExtPacker(0x03, ReferenceError, [packError, encode]);\\r\\n  codec.addExtPacker(0x04, SyntaxError, [packError, encode]);\\r\\n  codec.addExtPacker(0x05, TypeError, [packError, encode]);\\r\\n  codec.addExtPacker(0x06, URIError, [packError, encode]);\\r\\n\\r\\n  codec.addExtPacker(0x0A, RegExp, [packRegExp, encode]);\\r\\n  codec.addExtPacker(0x0B, Boolean, [packValueOf, encode]);\\r\\n  codec.addExtPacker(0x0C, String, [packValueOf, encode]);\\r\\n  codec.addExtPacker(0x0D, Date, [Number, encode]);\\r\\n  codec.addExtPacker(0x0F, Number, [packValueOf, encode]);\\r\\n\\r\\n  if (\\\"undefined\\\" !== typeof Uint8Array) {\\r\\n    codec.addExtPacker(0x11, Int8Array, packTypedArray);\\r\\n    codec.addExtPacker(0x12, Uint8Array, packTypedArray);\\r\\n    codec.addExtPacker(0x13, Int16Array, packTypedArray);\\r\\n    codec.addExtPacker(0x14, Uint16Array, packTypedArray);\\r\\n    codec.addExtPacker(0x15, Int32Array, packTypedArray);\\r\\n    codec.addExtPacker(0x16, Uint32Array, packTypedArray);\\r\\n    codec.addExtPacker(0x17, Float32Array, packTypedArray);\\r\\n\\r\\n    // PhantomJS/1.9.7 doesn't have Float64Array\\r\\n    if (\\\"undefined\\\" !== typeof Float64Array) {\\r\\n      codec.addExtPacker(0x18, Float64Array, packTypedArray);\\r\\n    }\\r\\n\\r\\n    // IE10 doesn't have Uint8ClampedArray\\r\\n    if (\\\"undefined\\\" !== typeof Uint8ClampedArray) {\\r\\n      codec.addExtPacker(0x19, Uint8ClampedArray, packTypedArray);\\r\\n    }\\r\\n\\r\\n    codec.addExtPacker(0x1A, ArrayBuffer, packTypedArray);\\r\\n    codec.addExtPacker(0x1D, DataView, packTypedArray);\\r\\n  }\\r\\n\\r\\n  if (Bufferish.hasBuffer) {\\r\\n    codec.addExtPacker(0x1B, Buffer, Bufferish.from);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction encode(input) {\\r\\n  if (!_encode) _encode = require(\\\"./encode\\\").encode; // lazy load\\r\\n  return _encode(input);\\r\\n}\\r\\n\\r\\nfunction packValueOf(value) {\\r\\n  return (value).valueOf();\\r\\n}\\r\\n\\r\\nfunction packRegExp(value) {\\r\\n  value = RegExp.prototype.toString.call(value).split(\\\"/\\\");\\r\\n  value.shift();\\r\\n  var out = [value.pop()];\\r\\n  out.unshift(value.join(\\\"/\\\"));\\r\\n  return out;\\r\\n}\\r\\n\\r\\nfunction packError(value) {\\r\\n  var out = {};\\r\\n  for (var key in ERROR_COLUMNS) {\\r\\n    out[key] = value[key];\\r\\n  }\\r\\n  return out;\\r\\n}\\r\\n\\r\\n},{\\\"./bufferish\\\":13,\\\"./encode\\\":20}],24:[function(require,module,exports){\\r\\n// ext-unpacker.js\\r\\n\\r\\nexports.setExtUnpackers = setExtUnpackers;\\r\\n\\r\\nvar Bufferish = require(\\\"./bufferish\\\");\\r\\nvar Buffer = Bufferish.global;\\r\\nvar _decode;\\r\\n\\r\\nvar ERROR_COLUMNS = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};\\r\\n\\r\\nfunction setExtUnpackers(codec) {\\r\\n  codec.addExtUnpacker(0x0E, [decode, unpackError(Error)]);\\r\\n  codec.addExtUnpacker(0x01, [decode, unpackError(EvalError)]);\\r\\n  codec.addExtUnpacker(0x02, [decode, unpackError(RangeError)]);\\r\\n  codec.addExtUnpacker(0x03, [decode, unpackError(ReferenceError)]);\\r\\n  codec.addExtUnpacker(0x04, [decode, unpackError(SyntaxError)]);\\r\\n  codec.addExtUnpacker(0x05, [decode, unpackError(TypeError)]);\\r\\n  codec.addExtUnpacker(0x06, [decode, unpackError(URIError)]);\\r\\n\\r\\n  codec.addExtUnpacker(0x0A, [decode, unpackRegExp]);\\r\\n  codec.addExtUnpacker(0x0B, [decode, unpackClass(Boolean)]);\\r\\n  codec.addExtUnpacker(0x0C, [decode, unpackClass(String)]);\\r\\n  codec.addExtUnpacker(0x0D, [decode, unpackClass(Date)]);\\r\\n  codec.addExtUnpacker(0x0F, [decode, unpackClass(Number)]);\\r\\n\\r\\n  if (\\\"undefined\\\" !== typeof Uint8Array) {\\r\\n    codec.addExtUnpacker(0x11, unpackClass(Int8Array));\\r\\n    codec.addExtUnpacker(0x12, unpackClass(Uint8Array));\\r\\n    codec.addExtUnpacker(0x13, [unpackArrayBuffer, unpackClass(Int16Array)]);\\r\\n    codec.addExtUnpacker(0x14, [unpackArrayBuffer, unpackClass(Uint16Array)]);\\r\\n    codec.addExtUnpacker(0x15, [unpackArrayBuffer, unpackClass(Int32Array)]);\\r\\n    codec.addExtUnpacker(0x16, [unpackArrayBuffer, unpackClass(Uint32Array)]);\\r\\n    codec.addExtUnpacker(0x17, [unpackArrayBuffer, unpackClass(Float32Array)]);\\r\\n\\r\\n    // PhantomJS/1.9.7 doesn't have Float64Array\\r\\n    if (\\\"undefined\\\" !== typeof Float64Array) {\\r\\n      codec.addExtUnpacker(0x18, [unpackArrayBuffer, unpackClass(Float64Array)]);\\r\\n    }\\r\\n\\r\\n    // IE10 doesn't have Uint8ClampedArray\\r\\n    if (\\\"undefined\\\" !== typeof Uint8ClampedArray) {\\r\\n      codec.addExtUnpacker(0x19, unpackClass(Uint8ClampedArray));\\r\\n    }\\r\\n\\r\\n    codec.addExtUnpacker(0x1A, unpackArrayBuffer);\\r\\n    codec.addExtUnpacker(0x1D, [unpackArrayBuffer, unpackClass(DataView)]);\\r\\n  }\\r\\n\\r\\n  if (Bufferish.hasBuffer) {\\r\\n    codec.addExtUnpacker(0x1B, unpackClass(Buffer));\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction decode(input) {\\r\\n  if (!_decode) _decode = require(\\\"./decode\\\").decode; // lazy load\\r\\n  return _decode(input);\\r\\n}\\r\\n\\r\\nfunction unpackRegExp(value) {\\r\\n  return RegExp.apply(null, value);\\r\\n}\\r\\n\\r\\nfunction unpackError(Class) {\\r\\n  return function(value) {\\r\\n    var out = new Class();\\r\\n    for (var key in ERROR_COLUMNS) {\\r\\n      out[key] = value[key];\\r\\n    }\\r\\n    return out;\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction unpackClass(Class) {\\r\\n  return function(value) {\\r\\n    return new Class(value);\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction unpackArrayBuffer(value) {\\r\\n  return (new Uint8Array(value)).buffer;\\r\\n}\\r\\n\\r\\n},{\\\"./bufferish\\\":13,\\\"./decode\\\":17}],25:[function(require,module,exports){\\r\\n// ext.js\\r\\n\\r\\n// load both interfaces\\r\\nrequire(\\\"./read-core\\\");\\r\\nrequire(\\\"./write-core\\\");\\r\\n\\r\\nexports.createCodec = require(\\\"./codec-base\\\").createCodec;\\r\\n\\r\\n},{\\\"./codec-base\\\":14,\\\"./read-core\\\":27,\\\"./write-core\\\":30}],26:[function(require,module,exports){\\r\\n// flex-buffer.js\\r\\n\\r\\nexports.FlexDecoder = FlexDecoder;\\r\\nexports.FlexEncoder = FlexEncoder;\\r\\n\\r\\nvar Bufferish = require(\\\"./bufferish\\\");\\r\\n\\r\\nvar MIN_BUFFER_SIZE = 2048;\\r\\nvar MAX_BUFFER_SIZE = 65536;\\r\\nvar BUFFER_SHORTAGE = \\\"BUFFER_SHORTAGE\\\";\\r\\n\\r\\nfunction FlexDecoder() {\\r\\n  if (!(this instanceof FlexDecoder)) return new FlexDecoder();\\r\\n}\\r\\n\\r\\nfunction FlexEncoder() {\\r\\n  if (!(this instanceof FlexEncoder)) return new FlexEncoder();\\r\\n}\\r\\n\\r\\nFlexDecoder.mixin = mixinFactory(getDecoderMethods());\\r\\nFlexDecoder.mixin(FlexDecoder.prototype);\\r\\n\\r\\nFlexEncoder.mixin = mixinFactory(getEncoderMethods());\\r\\nFlexEncoder.mixin(FlexEncoder.prototype);\\r\\n\\r\\nfunction getDecoderMethods() {\\r\\n  return {\\r\\n    bufferish: Bufferish,\\r\\n    write: write,\\r\\n    fetch: fetch,\\r\\n    flush: flush,\\r\\n    push: push,\\r\\n    pull: pull,\\r\\n    read: read,\\r\\n    reserve: reserve,\\r\\n    offset: 0\\r\\n  };\\r\\n\\r\\n  function write(chunk) {\\r\\n    var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;\\r\\n    this.buffer = prev ? (chunk ? this.bufferish.concat([prev, chunk]) : prev) : chunk;\\r\\n    this.offset = 0;\\r\\n  }\\r\\n\\r\\n  function flush() {\\r\\n    while (this.offset < this.buffer.length) {\\r\\n      var start = this.offset;\\r\\n      var value;\\r\\n      try {\\r\\n        value = this.fetch();\\r\\n      } catch (e) {\\r\\n        if (e && e.message != BUFFER_SHORTAGE) throw e;\\r\\n        // rollback\\r\\n        this.offset = start;\\r\\n        break;\\r\\n      }\\r\\n      this.push(value);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function reserve(length) {\\r\\n    var start = this.offset;\\r\\n    var end = start + length;\\r\\n    if (end > this.buffer.length) throw new Error(BUFFER_SHORTAGE);\\r\\n    this.offset = end;\\r\\n    return start;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction getEncoderMethods() {\\r\\n  return {\\r\\n    bufferish: Bufferish,\\r\\n    write: write,\\r\\n    fetch: fetch,\\r\\n    flush: flush,\\r\\n    push: push,\\r\\n    pull: pull,\\r\\n    read: read,\\r\\n    reserve: reserve,\\r\\n    send: send,\\r\\n    maxBufferSize: MAX_BUFFER_SIZE,\\r\\n    minBufferSize: MIN_BUFFER_SIZE,\\r\\n    offset: 0,\\r\\n    start: 0\\r\\n  };\\r\\n\\r\\n  function fetch() {\\r\\n    var start = this.start;\\r\\n    if (start < this.offset) {\\r\\n      var end = this.start = this.offset;\\r\\n      return Bufferish.prototype.slice.call(this.buffer, start, end);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function flush() {\\r\\n    while (this.start < this.offset) {\\r\\n      var value = this.fetch();\\r\\n      if (value) this.push(value);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function pull() {\\r\\n    var buffers = this.buffers || (this.buffers = []);\\r\\n    var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];\\r\\n    buffers.length = 0; // buffer exhausted\\r\\n    return chunk;\\r\\n  }\\r\\n\\r\\n  function reserve(length) {\\r\\n    var req = length | 0;\\r\\n\\r\\n    if (this.buffer) {\\r\\n      var size = this.buffer.length;\\r\\n      var start = this.offset | 0;\\r\\n      var end = start + req;\\r\\n\\r\\n      // is it long enough?\\r\\n      if (end < size) {\\r\\n        this.offset = end;\\r\\n        return start;\\r\\n      }\\r\\n\\r\\n      // flush current buffer\\r\\n      this.flush();\\r\\n\\r\\n      // resize it to 2x current length\\r\\n      length = Math.max(length, Math.min(size * 2, this.maxBufferSize));\\r\\n    }\\r\\n\\r\\n    // minimum buffer size\\r\\n    length = Math.max(length, this.minBufferSize);\\r\\n\\r\\n    // allocate new buffer\\r\\n    this.buffer = this.bufferish.alloc(length);\\r\\n    this.start = 0;\\r\\n    this.offset = req;\\r\\n    return 0;\\r\\n  }\\r\\n\\r\\n  function send(buffer) {\\r\\n    var length = buffer.length;\\r\\n    if (length > this.minBufferSize) {\\r\\n      this.flush();\\r\\n      this.push(buffer);\\r\\n    } else {\\r\\n      var offset = this.reserve(length);\\r\\n      Bufferish.prototype.copy.call(buffer, this.buffer, offset);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n// common methods\\r\\n\\r\\nfunction write() {\\r\\n  throw new Error(\\\"method not implemented: write()\\\");\\r\\n}\\r\\n\\r\\nfunction fetch() {\\r\\n  throw new Error(\\\"method not implemented: fetch()\\\");\\r\\n}\\r\\n\\r\\nfunction read() {\\r\\n  var length = this.buffers && this.buffers.length;\\r\\n\\r\\n  // fetch the first result\\r\\n  if (!length) return this.fetch();\\r\\n\\r\\n  // flush current buffer\\r\\n  this.flush();\\r\\n\\r\\n  // read from the results\\r\\n  return this.pull();\\r\\n}\\r\\n\\r\\nfunction push(chunk) {\\r\\n  var buffers = this.buffers || (this.buffers = []);\\r\\n  buffers.push(chunk);\\r\\n}\\r\\n\\r\\nfunction pull() {\\r\\n  var buffers = this.buffers || (this.buffers = []);\\r\\n  return buffers.shift();\\r\\n}\\r\\n\\r\\nfunction mixinFactory(source) {\\r\\n  return mixin;\\r\\n\\r\\n  function mixin(target) {\\r\\n    for (var key in source) {\\r\\n      target[key] = source[key];\\r\\n    }\\r\\n    return target;\\r\\n  }\\r\\n}\\r\\n\\r\\n},{\\\"./bufferish\\\":13}],27:[function(require,module,exports){\\r\\n// read-core.js\\r\\n\\r\\nvar ExtBuffer = require(\\\"./ext-buffer\\\").ExtBuffer;\\r\\nvar ExtUnpacker = require(\\\"./ext-unpacker\\\");\\r\\nvar readUint8 = require(\\\"./read-format\\\").readUint8;\\r\\nvar ReadToken = require(\\\"./read-token\\\");\\r\\nvar CodecBase = require(\\\"./codec-base\\\");\\r\\n\\r\\nCodecBase.install({\\r\\n  addExtUnpacker: addExtUnpacker,\\r\\n  getExtUnpacker: getExtUnpacker,\\r\\n  init: init\\r\\n});\\r\\n\\r\\nexports.preset = init.call(CodecBase.preset);\\r\\n\\r\\nfunction getDecoder(options) {\\r\\n  var readToken = ReadToken.getReadToken(options);\\r\\n  return decode;\\r\\n\\r\\n  function decode(decoder) {\\r\\n    var type = readUint8(decoder);\\r\\n    var func = readToken[type];\\r\\n    if (!func) throw new Error(\\\"Invalid type: \\\" + (type ? (\\\"0x\\\" + type.toString(16)) : type));\\r\\n    return func(decoder);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction init() {\\r\\n  var options = this.options;\\r\\n  this.decode = getDecoder(options);\\r\\n\\r\\n  if (options && options.preset) {\\r\\n    ExtUnpacker.setExtUnpackers(this);\\r\\n  }\\r\\n\\r\\n  return this;\\r\\n}\\r\\n\\r\\nfunction addExtUnpacker(etype, unpacker) {\\r\\n  var unpackers = this.extUnpackers || (this.extUnpackers = []);\\r\\n  unpackers[etype] = CodecBase.filter(unpacker);\\r\\n}\\r\\n\\r\\nfunction getExtUnpacker(type) {\\r\\n  var unpackers = this.extUnpackers || (this.extUnpackers = []);\\r\\n  return unpackers[type] || extUnpacker;\\r\\n\\r\\n  function extUnpacker(buffer) {\\r\\n    return new ExtBuffer(buffer, type);\\r\\n  }\\r\\n}\\r\\n\\r\\n},{\\\"./codec-base\\\":14,\\\"./ext-buffer\\\":22,\\\"./ext-unpacker\\\":24,\\\"./read-format\\\":28,\\\"./read-token\\\":29}],28:[function(require,module,exports){\\r\\n// read-format.js\\r\\n\\r\\nvar ieee754 = require(\\\"ieee754\\\");\\r\\nvar Int64Buffer = require(\\\"int64-buffer\\\");\\r\\nvar Uint64BE = Int64Buffer.Uint64BE;\\r\\nvar Int64BE = Int64Buffer.Int64BE;\\r\\n\\r\\nexports.getReadFormat = getReadFormat;\\r\\nexports.readUint8 = uint8;\\r\\n\\r\\nvar Bufferish = require(\\\"./bufferish\\\");\\r\\nvar BufferProto = require(\\\"./bufferish-proto\\\");\\r\\n\\r\\nvar HAS_MAP = (\\\"undefined\\\" !== typeof Map);\\r\\nvar NO_ASSERT = true;\\r\\n\\r\\nfunction getReadFormat(options) {\\r\\n  var binarraybuffer = Bufferish.hasArrayBuffer && options && options.binarraybuffer;\\r\\n  var int64 = options && options.int64;\\r\\n  var usemap = HAS_MAP && options && options.usemap;\\r\\n\\r\\n  var readFormat = {\\r\\n    map: (usemap ? map_to_map : map_to_obj),\\r\\n    array: array,\\r\\n    str: str,\\r\\n    bin: (binarraybuffer ? bin_arraybuffer : bin_buffer),\\r\\n    ext: ext,\\r\\n    uint8: uint8,\\r\\n    uint16: uint16,\\r\\n    uint32: uint32,\\r\\n    uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),\\r\\n    int8: int8,\\r\\n    int16: int16,\\r\\n    int32: int32,\\r\\n    int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),\\r\\n    float32: read(4, readFloatBE),\\r\\n    float64: read(8, readDoubleBE)\\r\\n  };\\r\\n\\r\\n  return readFormat;\\r\\n}\\r\\n\\r\\nfunction map_to_obj(decoder, len) {\\r\\n  var value = {};\\r\\n  var i;\\r\\n  var k = new Array(len);\\r\\n  var v = new Array(len);\\r\\n\\r\\n  var decode = decoder.codec.decode;\\r\\n  for (i = 0; i < len; i++) {\\r\\n    k[i] = decode(decoder);\\r\\n    v[i] = decode(decoder);\\r\\n  }\\r\\n  for (i = 0; i < len; i++) {\\r\\n    value[k[i]] = v[i];\\r\\n  }\\r\\n  return value;\\r\\n}\\r\\n\\r\\nfunction map_to_map(decoder, len) {\\r\\n  var value = new Map();\\r\\n  var i;\\r\\n  var k = new Array(len);\\r\\n  var v = new Array(len);\\r\\n\\r\\n  var decode = decoder.codec.decode;\\r\\n  for (i = 0; i < len; i++) {\\r\\n    k[i] = decode(decoder);\\r\\n    v[i] = decode(decoder);\\r\\n  }\\r\\n  for (i = 0; i < len; i++) {\\r\\n    value.set(k[i], v[i]);\\r\\n  }\\r\\n  return value;\\r\\n}\\r\\n\\r\\nfunction array(decoder, len) {\\r\\n  var value = new Array(len);\\r\\n  var decode = decoder.codec.decode;\\r\\n  for (var i = 0; i < len; i++) {\\r\\n    value[i] = decode(decoder);\\r\\n  }\\r\\n  return value;\\r\\n}\\r\\n\\r\\nfunction str(decoder, len) {\\r\\n  var start = decoder.reserve(len);\\r\\n  var end = start + len;\\r\\n  return BufferProto.toString.call(decoder.buffer, \\\"utf-8\\\", start, end);\\r\\n}\\r\\n\\r\\nfunction bin_buffer(decoder, len) {\\r\\n  var start = decoder.reserve(len);\\r\\n  var end = start + len;\\r\\n  var buf = BufferProto.slice.call(decoder.buffer, start, end);\\r\\n  return Bufferish.from(buf);\\r\\n}\\r\\n\\r\\nfunction bin_arraybuffer(decoder, len) {\\r\\n  var start = decoder.reserve(len);\\r\\n  var end = start + len;\\r\\n  var buf = BufferProto.slice.call(decoder.buffer, start, end);\\r\\n  return Bufferish.Uint8Array.from(buf).buffer;\\r\\n}\\r\\n\\r\\nfunction ext(decoder, len) {\\r\\n  var start = decoder.reserve(len+1);\\r\\n  var type = decoder.buffer[start++];\\r\\n  var end = start + len;\\r\\n  var unpack = decoder.codec.getExtUnpacker(type);\\r\\n  if (!unpack) throw new Error(\\\"Invalid ext type: \\\" + (type ? (\\\"0x\\\" + type.toString(16)) : type));\\r\\n  var buf = BufferProto.slice.call(decoder.buffer, start, end);\\r\\n  return unpack(buf);\\r\\n}\\r\\n\\r\\nfunction uint8(decoder) {\\r\\n  var start = decoder.reserve(1);\\r\\n  return decoder.buffer[start];\\r\\n}\\r\\n\\r\\nfunction int8(decoder) {\\r\\n  var start = decoder.reserve(1);\\r\\n  var value = decoder.buffer[start];\\r\\n  return (value & 0x80) ? value - 0x100 : value;\\r\\n}\\r\\n\\r\\nfunction uint16(decoder) {\\r\\n  var start = decoder.reserve(2);\\r\\n  var buffer = decoder.buffer;\\r\\n  return (buffer[start++] << 8) | buffer[start];\\r\\n}\\r\\n\\r\\nfunction int16(decoder) {\\r\\n  var start = decoder.reserve(2);\\r\\n  var buffer = decoder.buffer;\\r\\n  var value = (buffer[start++] << 8) | buffer[start];\\r\\n  return (value & 0x8000) ? value - 0x10000 : value;\\r\\n}\\r\\n\\r\\nfunction uint32(decoder) {\\r\\n  var start = decoder.reserve(4);\\r\\n  var buffer = decoder.buffer;\\r\\n  return (buffer[start++] * 16777216) + (buffer[start++] << 16) + (buffer[start++] << 8) + buffer[start];\\r\\n}\\r\\n\\r\\nfunction int32(decoder) {\\r\\n  var start = decoder.reserve(4);\\r\\n  var buffer = decoder.buffer;\\r\\n  return (buffer[start++] << 24) | (buffer[start++] << 16) | (buffer[start++] << 8) | buffer[start];\\r\\n}\\r\\n\\r\\nfunction read(len, method) {\\r\\n  return function(decoder) {\\r\\n    var start = decoder.reserve(len);\\r\\n    return method.call(decoder.buffer, start, NO_ASSERT);\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction readUInt64BE(start) {\\r\\n  return new Uint64BE(this, start).toNumber();\\r\\n}\\r\\n\\r\\nfunction readInt64BE(start) {\\r\\n  return new Int64BE(this, start).toNumber();\\r\\n}\\r\\n\\r\\nfunction readUInt64BE_int64(start) {\\r\\n  return new Uint64BE(this, start);\\r\\n}\\r\\n\\r\\nfunction readInt64BE_int64(start) {\\r\\n  return new Int64BE(this, start);\\r\\n}\\r\\n\\r\\nfunction readFloatBE(start) {\\r\\n  return ieee754.read(this, start, false, 23, 4);\\r\\n}\\r\\n\\r\\nfunction readDoubleBE(start) {\\r\\n  return ieee754.read(this, start, false, 52, 8);\\r\\n}\\r\\n},{\\\"./bufferish\\\":13,\\\"./bufferish-proto\\\":11,\\\"ieee754\\\":3,\\\"int64-buffer\\\":4}],29:[function(require,module,exports){\\r\\n// read-token.js\\r\\n\\r\\nvar ReadFormat = require(\\\"./read-format\\\");\\r\\n\\r\\nexports.getReadToken = getReadToken;\\r\\n\\r\\nfunction getReadToken(options) {\\r\\n  var format = ReadFormat.getReadFormat(options);\\r\\n\\r\\n  if (options && options.useraw) {\\r\\n    return init_useraw(format);\\r\\n  } else {\\r\\n    return init_token(format);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction init_token(format) {\\r\\n  var i;\\r\\n  var token = new Array(256);\\r\\n\\r\\n  // positive fixint -- 0x00 - 0x7f\\r\\n  for (i = 0x00; i <= 0x7f; i++) {\\r\\n    token[i] = constant(i);\\r\\n  }\\r\\n\\r\\n  // fixmap -- 0x80 - 0x8f\\r\\n  for (i = 0x80; i <= 0x8f; i++) {\\r\\n    token[i] = fix(i - 0x80, format.map);\\r\\n  }\\r\\n\\r\\n  // fixarray -- 0x90 - 0x9f\\r\\n  for (i = 0x90; i <= 0x9f; i++) {\\r\\n    token[i] = fix(i - 0x90, format.array);\\r\\n  }\\r\\n\\r\\n  // fixstr -- 0xa0 - 0xbf\\r\\n  for (i = 0xa0; i <= 0xbf; i++) {\\r\\n    token[i] = fix(i - 0xa0, format.str);\\r\\n  }\\r\\n\\r\\n  // nil -- 0xc0\\r\\n  token[0xc0] = constant(null);\\r\\n\\r\\n  // (never used) -- 0xc1\\r\\n  token[0xc1] = null;\\r\\n\\r\\n  // false -- 0xc2\\r\\n  // true -- 0xc3\\r\\n  token[0xc2] = constant(false);\\r\\n  token[0xc3] = constant(true);\\r\\n\\r\\n  // bin 8 -- 0xc4\\r\\n  // bin 16 -- 0xc5\\r\\n  // bin 32 -- 0xc6\\r\\n  token[0xc4] = flex(format.uint8, format.bin);\\r\\n  token[0xc5] = flex(format.uint16, format.bin);\\r\\n  token[0xc6] = flex(format.uint32, format.bin);\\r\\n\\r\\n  // ext 8 -- 0xc7\\r\\n  // ext 16 -- 0xc8\\r\\n  // ext 32 -- 0xc9\\r\\n  token[0xc7] = flex(format.uint8, format.ext);\\r\\n  token[0xc8] = flex(format.uint16, format.ext);\\r\\n  token[0xc9] = flex(format.uint32, format.ext);\\r\\n\\r\\n  // float 32 -- 0xca\\r\\n  // float 64 -- 0xcb\\r\\n  token[0xca] = format.float32;\\r\\n  token[0xcb] = format.float64;\\r\\n\\r\\n  // uint 8 -- 0xcc\\r\\n  // uint 16 -- 0xcd\\r\\n  // uint 32 -- 0xce\\r\\n  // uint 64 -- 0xcf\\r\\n  token[0xcc] = format.uint8;\\r\\n  token[0xcd] = format.uint16;\\r\\n  token[0xce] = format.uint32;\\r\\n  token[0xcf] = format.uint64;\\r\\n\\r\\n  // int 8 -- 0xd0\\r\\n  // int 16 -- 0xd1\\r\\n  // int 32 -- 0xd2\\r\\n  // int 64 -- 0xd3\\r\\n  token[0xd0] = format.int8;\\r\\n  token[0xd1] = format.int16;\\r\\n  token[0xd2] = format.int32;\\r\\n  token[0xd3] = format.int64;\\r\\n\\r\\n  // fixext 1 -- 0xd4\\r\\n  // fixext 2 -- 0xd5\\r\\n  // fixext 4 -- 0xd6\\r\\n  // fixext 8 -- 0xd7\\r\\n  // fixext 16 -- 0xd8\\r\\n  token[0xd4] = fix(1, format.ext);\\r\\n  token[0xd5] = fix(2, format.ext);\\r\\n  token[0xd6] = fix(4, format.ext);\\r\\n  token[0xd7] = fix(8, format.ext);\\r\\n  token[0xd8] = fix(16, format.ext);\\r\\n\\r\\n  // str 8 -- 0xd9\\r\\n  // str 16 -- 0xda\\r\\n  // str 32 -- 0xdb\\r\\n  token[0xd9] = flex(format.uint8, format.str);\\r\\n  token[0xda] = flex(format.uint16, format.str);\\r\\n  token[0xdb] = flex(format.uint32, format.str);\\r\\n\\r\\n  // array 16 -- 0xdc\\r\\n  // array 32 -- 0xdd\\r\\n  token[0xdc] = flex(format.uint16, format.array);\\r\\n  token[0xdd] = flex(format.uint32, format.array);\\r\\n\\r\\n  // map 16 -- 0xde\\r\\n  // map 32 -- 0xdf\\r\\n  token[0xde] = flex(format.uint16, format.map);\\r\\n  token[0xdf] = flex(format.uint32, format.map);\\r\\n\\r\\n  // negative fixint -- 0xe0 - 0xff\\r\\n  for (i = 0xe0; i <= 0xff; i++) {\\r\\n    token[i] = constant(i - 0x100);\\r\\n  }\\r\\n\\r\\n  return token;\\r\\n}\\r\\n\\r\\nfunction init_useraw(format) {\\r\\n  var i;\\r\\n  var token = init_token(format).slice();\\r\\n\\r\\n  // raw 8 -- 0xd9\\r\\n  // raw 16 -- 0xda\\r\\n  // raw 32 -- 0xdb\\r\\n  token[0xd9] = token[0xc4];\\r\\n  token[0xda] = token[0xc5];\\r\\n  token[0xdb] = token[0xc6];\\r\\n\\r\\n  // fixraw -- 0xa0 - 0xbf\\r\\n  for (i = 0xa0; i <= 0xbf; i++) {\\r\\n    token[i] = fix(i - 0xa0, format.bin);\\r\\n  }\\r\\n\\r\\n  return token;\\r\\n}\\r\\n\\r\\nfunction constant(value) {\\r\\n  return function() {\\r\\n    return value;\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction flex(lenFunc, decodeFunc) {\\r\\n  return function(decoder) {\\r\\n    var len = lenFunc(decoder);\\r\\n    return decodeFunc(decoder, len);\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction fix(len, method) {\\r\\n  return function(decoder) {\\r\\n    return method(decoder, len);\\r\\n  };\\r\\n}\\r\\n\\r\\n},{\\\"./read-format\\\":28}],30:[function(require,module,exports){\\r\\n// write-core.js\\r\\n\\r\\nvar ExtBuffer = require(\\\"./ext-buffer\\\").ExtBuffer;\\r\\nvar ExtPacker = require(\\\"./ext-packer\\\");\\r\\nvar WriteType = require(\\\"./write-type\\\");\\r\\nvar CodecBase = require(\\\"./codec-base\\\");\\r\\n\\r\\nCodecBase.install({\\r\\n  addExtPacker: addExtPacker,\\r\\n  getExtPacker: getExtPacker,\\r\\n  init: init\\r\\n});\\r\\n\\r\\nexports.preset = init.call(CodecBase.preset);\\r\\n\\r\\nfunction getEncoder(options) {\\r\\n  var writeType = WriteType.getWriteType(options);\\r\\n  return encode;\\r\\n\\r\\n  function encode(encoder, value) {\\r\\n    var func = writeType[typeof value];\\r\\n    if (!func) throw new Error(\\\"Unsupported type \\\\\\\"\\\" + (typeof value) + \\\"\\\\\\\": \\\" + value);\\r\\n    func(encoder, value);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction init() {\\r\\n  var options = this.options;\\r\\n  this.encode = getEncoder(options);\\r\\n\\r\\n  if (options && options.preset) {\\r\\n    ExtPacker.setExtPackers(this);\\r\\n  }\\r\\n\\r\\n  return this;\\r\\n}\\r\\n\\r\\nfunction addExtPacker(etype, Class, packer) {\\r\\n  packer = CodecBase.filter(packer);\\r\\n  var name = Class.name;\\r\\n  if (name && name !== \\\"Object\\\") {\\r\\n    var packers = this.extPackers || (this.extPackers = {});\\r\\n    packers[name] = extPacker;\\r\\n  } else {\\r\\n    // fallback for IE\\r\\n    var list = this.extEncoderList || (this.extEncoderList = []);\\r\\n    list.unshift([Class, extPacker]);\\r\\n  }\\r\\n\\r\\n  function extPacker(value) {\\r\\n    if (packer) value = packer(value);\\r\\n    return new ExtBuffer(value, etype);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction getExtPacker(value) {\\r\\n  var packers = this.extPackers || (this.extPackers = {});\\r\\n  var c = value.constructor;\\r\\n  var e = c && c.name && packers[c.name];\\r\\n  if (e) return e;\\r\\n\\r\\n  // fallback for IE\\r\\n  var list = this.extEncoderList || (this.extEncoderList = []);\\r\\n  var len = list.length;\\r\\n  for (var i = 0; i < len; i++) {\\r\\n    var pair = list[i];\\r\\n    if (c === pair[0]) return pair[1];\\r\\n  }\\r\\n}\\r\\n\\r\\n},{\\\"./codec-base\\\":14,\\\"./ext-buffer\\\":22,\\\"./ext-packer\\\":23,\\\"./write-type\\\":32}],31:[function(require,module,exports){\\r\\n// write-token.js\\r\\n\\r\\nvar ieee754 = require(\\\"ieee754\\\");\\r\\nvar Int64Buffer = require(\\\"int64-buffer\\\");\\r\\nvar Uint64BE = Int64Buffer.Uint64BE;\\r\\nvar Int64BE = Int64Buffer.Int64BE;\\r\\n\\r\\nvar uint8 = require(\\\"./write-uint8\\\").uint8;\\r\\nvar Bufferish = require(\\\"./bufferish\\\");\\r\\nvar Buffer = Bufferish.global;\\r\\nvar IS_BUFFER_SHIM = Bufferish.hasBuffer && (\\\"TYPED_ARRAY_SUPPORT\\\" in Buffer);\\r\\nvar NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer.TYPED_ARRAY_SUPPORT;\\r\\nvar Buffer_prototype = Bufferish.hasBuffer && Buffer.prototype || {};\\r\\n\\r\\nexports.getWriteToken = getWriteToken;\\r\\n\\r\\nfunction getWriteToken(options) {\\r\\n  if (options && options.uint8array) {\\r\\n    return init_uint8array();\\r\\n  } else if (NO_TYPED_ARRAY || (Bufferish.hasBuffer && options && options.safe)) {\\r\\n    return init_safe();\\r\\n  } else {\\r\\n    return init_token();\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction init_uint8array() {\\r\\n  var token = init_token();\\r\\n\\r\\n  // float 32 -- 0xca\\r\\n  // float 64 -- 0xcb\\r\\n  token[0xca] = writeN(0xca, 4, writeFloatBE);\\r\\n  token[0xcb] = writeN(0xcb, 8, writeDoubleBE);\\r\\n\\r\\n  return token;\\r\\n}\\r\\n\\r\\n// Node.js and browsers with TypedArray\\r\\n\\r\\nfunction init_token() {\\r\\n  // (immediate values)\\r\\n  // positive fixint -- 0x00 - 0x7f\\r\\n  // nil -- 0xc0\\r\\n  // false -- 0xc2\\r\\n  // true -- 0xc3\\r\\n  // negative fixint -- 0xe0 - 0xff\\r\\n  var token = uint8.slice();\\r\\n\\r\\n  // bin 8 -- 0xc4\\r\\n  // bin 16 -- 0xc5\\r\\n  // bin 32 -- 0xc6\\r\\n  token[0xc4] = write1(0xc4);\\r\\n  token[0xc5] = write2(0xc5);\\r\\n  token[0xc6] = write4(0xc6);\\r\\n\\r\\n  // ext 8 -- 0xc7\\r\\n  // ext 16 -- 0xc8\\r\\n  // ext 32 -- 0xc9\\r\\n  token[0xc7] = write1(0xc7);\\r\\n  token[0xc8] = write2(0xc8);\\r\\n  token[0xc9] = write4(0xc9);\\r\\n\\r\\n  // float 32 -- 0xca\\r\\n  // float 64 -- 0xcb\\r\\n  token[0xca] = writeN(0xca, 4, (Buffer_prototype.writeFloatBE || writeFloatBE), true);\\r\\n  token[0xcb] = writeN(0xcb, 8, (Buffer_prototype.writeDoubleBE || writeDoubleBE), true);\\r\\n\\r\\n  // uint 8 -- 0xcc\\r\\n  // uint 16 -- 0xcd\\r\\n  // uint 32 -- 0xce\\r\\n  // uint 64 -- 0xcf\\r\\n  token[0xcc] = write1(0xcc);\\r\\n  token[0xcd] = write2(0xcd);\\r\\n  token[0xce] = write4(0xce);\\r\\n  token[0xcf] = writeN(0xcf, 8, writeUInt64BE);\\r\\n\\r\\n  // int 8 -- 0xd0\\r\\n  // int 16 -- 0xd1\\r\\n  // int 32 -- 0xd2\\r\\n  // int 64 -- 0xd3\\r\\n  token[0xd0] = write1(0xd0);\\r\\n  token[0xd1] = write2(0xd1);\\r\\n  token[0xd2] = write4(0xd2);\\r\\n  token[0xd3] = writeN(0xd3, 8, writeInt64BE);\\r\\n\\r\\n  // str 8 -- 0xd9\\r\\n  // str 16 -- 0xda\\r\\n  // str 32 -- 0xdb\\r\\n  token[0xd9] = write1(0xd9);\\r\\n  token[0xda] = write2(0xda);\\r\\n  token[0xdb] = write4(0xdb);\\r\\n\\r\\n  // array 16 -- 0xdc\\r\\n  // array 32 -- 0xdd\\r\\n  token[0xdc] = write2(0xdc);\\r\\n  token[0xdd] = write4(0xdd);\\r\\n\\r\\n  // map 16 -- 0xde\\r\\n  // map 32 -- 0xdf\\r\\n  token[0xde] = write2(0xde);\\r\\n  token[0xdf] = write4(0xdf);\\r\\n\\r\\n  return token;\\r\\n}\\r\\n\\r\\n// safe mode: for old browsers and who needs asserts\\r\\n\\r\\nfunction init_safe() {\\r\\n  // (immediate values)\\r\\n  // positive fixint -- 0x00 - 0x7f\\r\\n  // nil -- 0xc0\\r\\n  // false -- 0xc2\\r\\n  // true -- 0xc3\\r\\n  // negative fixint -- 0xe0 - 0xff\\r\\n  var token = uint8.slice();\\r\\n\\r\\n  // bin 8 -- 0xc4\\r\\n  // bin 16 -- 0xc5\\r\\n  // bin 32 -- 0xc6\\r\\n  token[0xc4] = writeN(0xc4, 1, Buffer.prototype.writeUInt8);\\r\\n  token[0xc5] = writeN(0xc5, 2, Buffer.prototype.writeUInt16BE);\\r\\n  token[0xc6] = writeN(0xc6, 4, Buffer.prototype.writeUInt32BE);\\r\\n\\r\\n  // ext 8 -- 0xc7\\r\\n  // ext 16 -- 0xc8\\r\\n  // ext 32 -- 0xc9\\r\\n  token[0xc7] = writeN(0xc7, 1, Buffer.prototype.writeUInt8);\\r\\n  token[0xc8] = writeN(0xc8, 2, Buffer.prototype.writeUInt16BE);\\r\\n  token[0xc9] = writeN(0xc9, 4, Buffer.prototype.writeUInt32BE);\\r\\n\\r\\n  // float 32 -- 0xca\\r\\n  // float 64 -- 0xcb\\r\\n  token[0xca] = writeN(0xca, 4, Buffer.prototype.writeFloatBE);\\r\\n  token[0xcb] = writeN(0xcb, 8, Buffer.prototype.writeDoubleBE);\\r\\n\\r\\n  // uint 8 -- 0xcc\\r\\n  // uint 16 -- 0xcd\\r\\n  // uint 32 -- 0xce\\r\\n  // uint 64 -- 0xcf\\r\\n  token[0xcc] = writeN(0xcc, 1, Buffer.prototype.writeUInt8);\\r\\n  token[0xcd] = writeN(0xcd, 2, Buffer.prototype.writeUInt16BE);\\r\\n  token[0xce] = writeN(0xce, 4, Buffer.prototype.writeUInt32BE);\\r\\n  token[0xcf] = writeN(0xcf, 8, writeUInt64BE);\\r\\n\\r\\n  // int 8 -- 0xd0\\r\\n  // int 16 -- 0xd1\\r\\n  // int 32 -- 0xd2\\r\\n  // int 64 -- 0xd3\\r\\n  token[0xd0] = writeN(0xd0, 1, Buffer.prototype.writeInt8);\\r\\n  token[0xd1] = writeN(0xd1, 2, Buffer.prototype.writeInt16BE);\\r\\n  token[0xd2] = writeN(0xd2, 4, Buffer.prototype.writeInt32BE);\\r\\n  token[0xd3] = writeN(0xd3, 8, writeInt64BE);\\r\\n\\r\\n  // str 8 -- 0xd9\\r\\n  // str 16 -- 0xda\\r\\n  // str 32 -- 0xdb\\r\\n  token[0xd9] = writeN(0xd9, 1, Buffer.prototype.writeUInt8);\\r\\n  token[0xda] = writeN(0xda, 2, Buffer.prototype.writeUInt16BE);\\r\\n  token[0xdb] = writeN(0xdb, 4, Buffer.prototype.writeUInt32BE);\\r\\n\\r\\n  // array 16 -- 0xdc\\r\\n  // array 32 -- 0xdd\\r\\n  token[0xdc] = writeN(0xdc, 2, Buffer.prototype.writeUInt16BE);\\r\\n  token[0xdd] = writeN(0xdd, 4, Buffer.prototype.writeUInt32BE);\\r\\n\\r\\n  // map 16 -- 0xde\\r\\n  // map 32 -- 0xdf\\r\\n  token[0xde] = writeN(0xde, 2, Buffer.prototype.writeUInt16BE);\\r\\n  token[0xdf] = writeN(0xdf, 4, Buffer.prototype.writeUInt32BE);\\r\\n\\r\\n  return token;\\r\\n}\\r\\n\\r\\nfunction write1(type) {\\r\\n  return function(encoder, value) {\\r\\n    var offset = encoder.reserve(2);\\r\\n    var buffer = encoder.buffer;\\r\\n    buffer[offset++] = type;\\r\\n    buffer[offset] = value;\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction write2(type) {\\r\\n  return function(encoder, value) {\\r\\n    var offset = encoder.reserve(3);\\r\\n    var buffer = encoder.buffer;\\r\\n    buffer[offset++] = type;\\r\\n    buffer[offset++] = value >>> 8;\\r\\n    buffer[offset] = value;\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction write4(type) {\\r\\n  return function(encoder, value) {\\r\\n    var offset = encoder.reserve(5);\\r\\n    var buffer = encoder.buffer;\\r\\n    buffer[offset++] = type;\\r\\n    buffer[offset++] = value >>> 24;\\r\\n    buffer[offset++] = value >>> 16;\\r\\n    buffer[offset++] = value >>> 8;\\r\\n    buffer[offset] = value;\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction writeN(type, len, method, noAssert) {\\r\\n  return function(encoder, value) {\\r\\n    var offset = encoder.reserve(len + 1);\\r\\n    encoder.buffer[offset++] = type;\\r\\n    method.call(encoder.buffer, value, offset, noAssert);\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction writeUInt64BE(value, offset) {\\r\\n  new Uint64BE(this, offset, value);\\r\\n}\\r\\n\\r\\nfunction writeInt64BE(value, offset) {\\r\\n  new Int64BE(this, offset, value);\\r\\n}\\r\\n\\r\\nfunction writeFloatBE(value, offset) {\\r\\n  ieee754.write(this, value, offset, false, 23, 4);\\r\\n}\\r\\n\\r\\nfunction writeDoubleBE(value, offset) {\\r\\n  ieee754.write(this, value, offset, false, 52, 8);\\r\\n}\\r\\n\\r\\n},{\\\"./bufferish\\\":13,\\\"./write-uint8\\\":33,\\\"ieee754\\\":3,\\\"int64-buffer\\\":4}],32:[function(require,module,exports){\\r\\n// write-type.js\\r\\n\\r\\nvar IS_ARRAY = require(\\\"isarray\\\");\\r\\nvar Int64Buffer = require(\\\"int64-buffer\\\");\\r\\nvar Uint64BE = Int64Buffer.Uint64BE;\\r\\nvar Int64BE = Int64Buffer.Int64BE;\\r\\n\\r\\nvar Bufferish = require(\\\"./bufferish\\\");\\r\\nvar BufferProto = require(\\\"./bufferish-proto\\\");\\r\\nvar WriteToken = require(\\\"./write-token\\\");\\r\\nvar uint8 = require(\\\"./write-uint8\\\").uint8;\\r\\nvar ExtBuffer = require(\\\"./ext-buffer\\\").ExtBuffer;\\r\\n\\r\\nvar HAS_UINT8ARRAY = (\\\"undefined\\\" !== typeof Uint8Array);\\r\\nvar HAS_MAP = (\\\"undefined\\\" !== typeof Map);\\r\\n\\r\\nvar extmap = [];\\r\\nextmap[1] = 0xd4;\\r\\nextmap[2] = 0xd5;\\r\\nextmap[4] = 0xd6;\\r\\nextmap[8] = 0xd7;\\r\\nextmap[16] = 0xd8;\\r\\n\\r\\nexports.getWriteType = getWriteType;\\r\\n\\r\\nfunction getWriteType(options) {\\r\\n  var token = WriteToken.getWriteToken(options);\\r\\n  var useraw = options && options.useraw;\\r\\n  var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;\\r\\n  var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;\\r\\n  var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;\\r\\n  var usemap = HAS_MAP && options && options.usemap;\\r\\n  var map = usemap ? map_to_map : obj_to_map;\\r\\n\\r\\n  var writeType = {\\r\\n    \\\"boolean\\\": bool,\\r\\n    \\\"function\\\": nil,\\r\\n    \\\"number\\\": number,\\r\\n    \\\"object\\\": (useraw ? object_raw : object),\\r\\n    \\\"string\\\": _string(useraw ? raw_head_size : str_head_size),\\r\\n    \\\"symbol\\\": nil,\\r\\n    \\\"undefined\\\": nil\\r\\n  };\\r\\n\\r\\n  return writeType;\\r\\n\\r\\n  // false -- 0xc2\\r\\n  // true -- 0xc3\\r\\n  function bool(encoder, value) {\\r\\n    var type = value ? 0xc3 : 0xc2;\\r\\n    token[type](encoder, value);\\r\\n  }\\r\\n\\r\\n  function number(encoder, value) {\\r\\n    var ivalue = value | 0;\\r\\n    var type;\\r\\n    if (value !== ivalue) {\\r\\n      // float 64 -- 0xcb\\r\\n      type = 0xcb;\\r\\n      token[type](encoder, value);\\r\\n      return;\\r\\n    } else if (-0x20 <= ivalue && ivalue <= 0x7F) {\\r\\n      // positive fixint -- 0x00 - 0x7f\\r\\n      // negative fixint -- 0xe0 - 0xff\\r\\n      type = ivalue & 0xFF;\\r\\n    } else if (0 <= ivalue) {\\r\\n      // uint 8 -- 0xcc\\r\\n      // uint 16 -- 0xcd\\r\\n      // uint 32 -- 0xce\\r\\n      type = (ivalue <= 0xFF) ? 0xcc : (ivalue <= 0xFFFF) ? 0xcd : 0xce;\\r\\n    } else {\\r\\n      // int 8 -- 0xd0\\r\\n      // int 16 -- 0xd1\\r\\n      // int 32 -- 0xd2\\r\\n      type = (-0x80 <= ivalue) ? 0xd0 : (-0x8000 <= ivalue) ? 0xd1 : 0xd2;\\r\\n    }\\r\\n    token[type](encoder, ivalue);\\r\\n  }\\r\\n\\r\\n  // uint 64 -- 0xcf\\r\\n  function uint64(encoder, value) {\\r\\n    var type = 0xcf;\\r\\n    token[type](encoder, value.toArray());\\r\\n  }\\r\\n\\r\\n  // int 64 -- 0xd3\\r\\n  function int64(encoder, value) {\\r\\n    var type = 0xd3;\\r\\n    token[type](encoder, value.toArray());\\r\\n  }\\r\\n\\r\\n  // str 8 -- 0xd9\\r\\n  // str 16 -- 0xda\\r\\n  // str 32 -- 0xdb\\r\\n  // fixstr -- 0xa0 - 0xbf\\r\\n  function str_head_size(length) {\\r\\n    return (length < 32) ? 1 : (length <= 0xFF) ? 2 : (length <= 0xFFFF) ? 3 : 5;\\r\\n  }\\r\\n\\r\\n  // raw 16 -- 0xda\\r\\n  // raw 32 -- 0xdb\\r\\n  // fixraw -- 0xa0 - 0xbf\\r\\n  function raw_head_size(length) {\\r\\n    return (length < 32) ? 1 : (length <= 0xFFFF) ? 3 : 5;\\r\\n  }\\r\\n\\r\\n  function _string(head_size) {\\r\\n    return string;\\r\\n\\r\\n    function string(encoder, value) {\\r\\n      // prepare buffer\\r\\n      var length = value.length;\\r\\n      var maxsize = 5 + length * 3;\\r\\n      encoder.offset = encoder.reserve(maxsize);\\r\\n      var buffer = encoder.buffer;\\r\\n\\r\\n      // expected header size\\r\\n      var expected = head_size(length);\\r\\n\\r\\n      // expected start point\\r\\n      var start = encoder.offset + expected;\\r\\n\\r\\n      // write string\\r\\n      length = BufferProto.write.call(buffer, value, start);\\r\\n\\r\\n      // actual header size\\r\\n      var actual = head_size(length);\\r\\n\\r\\n      // move content when needed\\r\\n      if (expected !== actual) {\\r\\n        var targetStart = start + actual - expected;\\r\\n        var end = start + length;\\r\\n        BufferProto.copy.call(buffer, buffer, targetStart, start, end);\\r\\n      }\\r\\n\\r\\n      // write header\\r\\n      var type = (actual === 1) ? (0xa0 + length) : (actual <= 3) ? (0xd7 + actual) : 0xdb;\\r\\n      token[type](encoder, length);\\r\\n\\r\\n      // move cursor\\r\\n      encoder.offset += length;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function object(encoder, value) {\\r\\n    // null\\r\\n    if (value === null) return nil(encoder, value);\\r\\n\\r\\n    // Buffer\\r\\n    if (isBuffer(value)) return bin(encoder, value);\\r\\n\\r\\n    // Array\\r\\n    if (IS_ARRAY(value)) return array(encoder, value);\\r\\n\\r\\n    // int64-buffer objects\\r\\n    if (Uint64BE.isUint64BE(value)) return uint64(encoder, value);\\r\\n    if (Int64BE.isInt64BE(value)) return int64(encoder, value);\\r\\n\\r\\n    // ext formats\\r\\n    var packer = encoder.codec.getExtPacker(value);\\r\\n    if (packer) value = packer(value);\\r\\n    if (value instanceof ExtBuffer) return ext(encoder, value);\\r\\n\\r\\n    // plain old Objects or Map\\r\\n    map(encoder, value);\\r\\n  }\\r\\n\\r\\n  function object_raw(encoder, value) {\\r\\n    // Buffer\\r\\n    if (isBuffer(value)) return raw(encoder, value);\\r\\n\\r\\n    // others\\r\\n    object(encoder, value);\\r\\n  }\\r\\n\\r\\n  // nil -- 0xc0\\r\\n  function nil(encoder, value) {\\r\\n    var type = 0xc0;\\r\\n    token[type](encoder, value);\\r\\n  }\\r\\n\\r\\n  // fixarray -- 0x90 - 0x9f\\r\\n  // array 16 -- 0xdc\\r\\n  // array 32 -- 0xdd\\r\\n  function array(encoder, value) {\\r\\n    var length = value.length;\\r\\n    var type = (length < 16) ? (0x90 + length) : (length <= 0xFFFF) ? 0xdc : 0xdd;\\r\\n    token[type](encoder, length);\\r\\n\\r\\n    var encode = encoder.codec.encode;\\r\\n    for (var i = 0; i < length; i++) {\\r\\n      encode(encoder, value[i]);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // bin 8 -- 0xc4\\r\\n  // bin 16 -- 0xc5\\r\\n  // bin 32 -- 0xc6\\r\\n  function bin_buffer(encoder, value) {\\r\\n    var length = value.length;\\r\\n    var type = (length < 0xFF) ? 0xc4 : (length <= 0xFFFF) ? 0xc5 : 0xc6;\\r\\n    token[type](encoder, length);\\r\\n    encoder.send(value);\\r\\n  }\\r\\n\\r\\n  function bin_arraybuffer(encoder, value) {\\r\\n    bin_buffer(encoder, new Uint8Array(value));\\r\\n  }\\r\\n\\r\\n  // fixext 1 -- 0xd4\\r\\n  // fixext 2 -- 0xd5\\r\\n  // fixext 4 -- 0xd6\\r\\n  // fixext 8 -- 0xd7\\r\\n  // fixext 16 -- 0xd8\\r\\n  // ext 8 -- 0xc7\\r\\n  // ext 16 -- 0xc8\\r\\n  // ext 32 -- 0xc9\\r\\n  function ext(encoder, value) {\\r\\n    var buffer = value.buffer;\\r\\n    var length = buffer.length;\\r\\n    var type = extmap[length] || ((length < 0xFF) ? 0xc7 : (length <= 0xFFFF) ? 0xc8 : 0xc9);\\r\\n    token[type](encoder, length);\\r\\n    uint8[value.type](encoder);\\r\\n    encoder.send(buffer);\\r\\n  }\\r\\n\\r\\n  // fixmap -- 0x80 - 0x8f\\r\\n  // map 16 -- 0xde\\r\\n  // map 32 -- 0xdf\\r\\n  function obj_to_map(encoder, value) {\\r\\n    var keys = Object.keys(value);\\r\\n    var length = keys.length;\\r\\n    var type = (length < 16) ? (0x80 + length) : (length <= 0xFFFF) ? 0xde : 0xdf;\\r\\n    token[type](encoder, length);\\r\\n\\r\\n    var encode = encoder.codec.encode;\\r\\n    keys.forEach(function(key) {\\r\\n      encode(encoder, key);\\r\\n      encode(encoder, value[key]);\\r\\n    });\\r\\n  }\\r\\n\\r\\n  // fixmap -- 0x80 - 0x8f\\r\\n  // map 16 -- 0xde\\r\\n  // map 32 -- 0xdf\\r\\n  function map_to_map(encoder, value) {\\r\\n    if (!(value instanceof Map)) return obj_to_map(encoder, value);\\r\\n\\r\\n    var length = value.size;\\r\\n    var type = (length < 16) ? (0x80 + length) : (length <= 0xFFFF) ? 0xde : 0xdf;\\r\\n    token[type](encoder, length);\\r\\n\\r\\n    var encode = encoder.codec.encode;\\r\\n    value.forEach(function(val, key, m) {\\r\\n      encode(encoder, key);\\r\\n      encode(encoder, val);\\r\\n    });\\r\\n  }\\r\\n\\r\\n  // raw 16 -- 0xda\\r\\n  // raw 32 -- 0xdb\\r\\n  // fixraw -- 0xa0 - 0xbf\\r\\n  function raw(encoder, value) {\\r\\n    var length = value.length;\\r\\n    var type = (length < 32) ? (0xa0 + length) : (length <= 0xFFFF) ? 0xda : 0xdb;\\r\\n    token[type](encoder, length);\\r\\n    encoder.send(value);\\r\\n  }\\r\\n}\\r\\n\\r\\n},{\\\"./bufferish\\\":13,\\\"./bufferish-proto\\\":11,\\\"./ext-buffer\\\":22,\\\"./write-token\\\":31,\\\"./write-uint8\\\":33,\\\"int64-buffer\\\":4,\\\"isarray\\\":5}],33:[function(require,module,exports){\\r\\n// write-unit8.js\\r\\n\\r\\nvar constant = exports.uint8 = new Array(256);\\r\\n\\r\\nfor (var i = 0x00; i <= 0xFF; i++) {\\r\\n  constant[i] = write0(i);\\r\\n}\\r\\n\\r\\nfunction write0(type) {\\r\\n  return function(encoder) {\\r\\n    var offset = encoder.reserve(1);\\r\\n    encoder.buffer[offset] = type;\\r\\n  };\\r\\n}\\r\\n\\r\\n},{}],34:[function(require,module,exports){\\r\\n'use strict'\\r\\n\\r\\nexports.byteLength = byteLength\\r\\nexports.toByteArray = toByteArray\\r\\nexports.fromByteArray = fromByteArray\\r\\n\\r\\nvar lookup = []\\r\\nvar revLookup = []\\r\\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\\r\\n\\r\\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\\r\\nfor (var i = 0, len = code.length; i < len; ++i) {\\r\\n  lookup[i] = code[i]\\r\\n  revLookup[code.charCodeAt(i)] = i\\r\\n}\\r\\n\\r\\nrevLookup['-'.charCodeAt(0)] = 62\\r\\nrevLookup['_'.charCodeAt(0)] = 63\\r\\n\\r\\nfunction placeHoldersCount (b64) {\\r\\n  var len = b64.length\\r\\n  if (len % 4 > 0) {\\r\\n    throw new Error('Invalid string. Length must be a multiple of 4')\\r\\n  }\\r\\n\\r\\n  // the number of equal signs (place holders)\\r\\n  // if there are two placeholders, than the two characters before it\\r\\n  // represent one byte\\r\\n  // if there is only one, then the three characters before it represent 2 bytes\\r\\n  // this is just a cheap hack to not do indexOf twice\\r\\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\\r\\n}\\r\\n\\r\\nfunction byteLength (b64) {\\r\\n  // base64 is 4/3 + up to two characters of the original data\\r\\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\\r\\n}\\r\\n\\r\\nfunction toByteArray (b64) {\\r\\n  var i, l, tmp, placeHolders, arr\\r\\n  var len = b64.length\\r\\n  placeHolders = placeHoldersCount(b64)\\r\\n\\r\\n  arr = new Arr((len * 3 / 4) - placeHolders)\\r\\n\\r\\n  // if there are placeholders, only get up to the last complete 4 chars\\r\\n  l = placeHolders > 0 ? len - 4 : len\\r\\n\\r\\n  var L = 0\\r\\n\\r\\n  for (i = 0; i < l; i += 4) {\\r\\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\\r\\n    arr[L++] = (tmp >> 16) & 0xFF\\r\\n    arr[L++] = (tmp >> 8) & 0xFF\\r\\n    arr[L++] = tmp & 0xFF\\r\\n  }\\r\\n\\r\\n  if (placeHolders === 2) {\\r\\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\\r\\n    arr[L++] = tmp & 0xFF\\r\\n  } else if (placeHolders === 1) {\\r\\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\\r\\n    arr[L++] = (tmp >> 8) & 0xFF\\r\\n    arr[L++] = tmp & 0xFF\\r\\n  }\\r\\n\\r\\n  return arr\\r\\n}\\r\\n\\r\\nfunction tripletToBase64 (num) {\\r\\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\\r\\n}\\r\\n\\r\\nfunction encodeChunk (uint8, start, end) {\\r\\n  var tmp\\r\\n  var output = []\\r\\n  for (var i = start; i < end; i += 3) {\\r\\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\\r\\n    output.push(tripletToBase64(tmp))\\r\\n  }\\r\\n  return output.join('')\\r\\n}\\r\\n\\r\\nfunction fromByteArray (uint8) {\\r\\n  var tmp\\r\\n  var len = uint8.length\\r\\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\\r\\n  var output = ''\\r\\n  var parts = []\\r\\n  var maxChunkLength = 16383 // must be multiple of 3\\r\\n\\r\\n  // go through the array every three bytes, we'll deal with trailing stuff later\\r\\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\\r\\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\\r\\n  }\\r\\n\\r\\n  // pad the end with zeros, but make sure to not forget the extra bytes\\r\\n  if (extraBytes === 1) {\\r\\n    tmp = uint8[len - 1]\\r\\n    output += lookup[tmp >> 2]\\r\\n    output += lookup[(tmp << 4) & 0x3F]\\r\\n    output += '=='\\r\\n  } else if (extraBytes === 2) {\\r\\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\\r\\n    output += lookup[tmp >> 10]\\r\\n    output += lookup[(tmp >> 4) & 0x3F]\\r\\n    output += lookup[(tmp << 2) & 0x3F]\\r\\n    output += '='\\r\\n  }\\r\\n\\r\\n  parts.push(output)\\r\\n\\r\\n  return parts.join('')\\r\\n}\\r\\n\\r\\n},{}],35:[function(require,module,exports){\\r\\n/*!\\r\\n * The buffer module from node.js, for the browser.\\r\\n *\\r\\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\\r\\n * @license  MIT\\r\\n */\\r\\n/* eslint-disable no-proto */\\r\\n\\r\\n'use strict'\\r\\n\\r\\nvar base64 = require('base64-js')\\r\\nvar ieee754 = require('ieee754')\\r\\n\\r\\nexports.Buffer = Buffer\\r\\nexports.SlowBuffer = SlowBuffer\\r\\nexports.INSPECT_MAX_BYTES = 50\\r\\n\\r\\nvar K_MAX_LENGTH = 0x7fffffff\\r\\nexports.kMaxLength = K_MAX_LENGTH\\r\\n\\r\\n/**\\r\\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\\r\\n *   === true    Use Uint8Array implementation (fastest)\\r\\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\\r\\n *               implementation (most compatible, even IE6)\\r\\n *\\r\\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\\r\\n * Opera 11.6+, iOS 4.2+.\\r\\n *\\r\\n * We report that the browser does not support typed arrays if the are not subclassable\\r\\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\\r\\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\\r\\n * for __proto__ and has a buggy typed array implementation.\\r\\n */\\r\\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\\r\\n\\r\\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\\r\\n    typeof console.error === 'function') {\\r\\n  console.error(\\r\\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\\r\\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction typedArraySupport () {\\r\\n  // Can typed array instances can be augmented?\\r\\n  try {\\r\\n    var arr = new Uint8Array(1)\\r\\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\\r\\n    return arr.foo() === 42\\r\\n  } catch (e) {\\r\\n    return false\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction createBuffer (length) {\\r\\n  if (length > K_MAX_LENGTH) {\\r\\n    throw new RangeError('Invalid typed array length')\\r\\n  }\\r\\n  // Return an augmented `Uint8Array` instance\\r\\n  var buf = new Uint8Array(length)\\r\\n  buf.__proto__ = Buffer.prototype\\r\\n  return buf\\r\\n}\\r\\n\\r\\n/**\\r\\n * The Buffer constructor returns instances of `Uint8Array` that have their\\r\\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\\r\\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\\r\\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\\r\\n * returns a single octet.\\r\\n *\\r\\n * The `Uint8Array` prototype remains unmodified.\\r\\n */\\r\\n\\r\\nfunction Buffer (arg, encodingOrOffset, length) {\\r\\n  // Common case.\\r\\n  if (typeof arg === 'number') {\\r\\n    if (typeof encodingOrOffset === 'string') {\\r\\n      throw new Error(\\r\\n        'If encoding is specified then the first argument must be a string'\\r\\n      )\\r\\n    }\\r\\n    return allocUnsafe(arg)\\r\\n  }\\r\\n  return from(arg, encodingOrOffset, length)\\r\\n}\\r\\n\\r\\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\\r\\nif (typeof Symbol !== 'undefined' && Symbol.species &&\\r\\n    Buffer[Symbol.species] === Buffer) {\\r\\n  Object.defineProperty(Buffer, Symbol.species, {\\r\\n    value: null,\\r\\n    configurable: true,\\r\\n    enumerable: false,\\r\\n    writable: false\\r\\n  })\\r\\n}\\r\\n\\r\\nBuffer.poolSize = 8192 // not used by this implementation\\r\\n\\r\\nfunction from (value, encodingOrOffset, length) {\\r\\n  if (typeof value === 'number') {\\r\\n    throw new TypeError('\\\"value\\\" argument must not be a number')\\r\\n  }\\r\\n\\r\\n  if (isArrayBuffer(value)) {\\r\\n    return fromArrayBuffer(value, encodingOrOffset, length)\\r\\n  }\\r\\n\\r\\n  if (typeof value === 'string') {\\r\\n    return fromString(value, encodingOrOffset)\\r\\n  }\\r\\n\\r\\n  return fromObject(value)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\\r\\n * if value is a number.\\r\\n * Buffer.from(str[, encoding])\\r\\n * Buffer.from(array)\\r\\n * Buffer.from(buffer)\\r\\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\\r\\n **/\\r\\nBuffer.from = function (value, encodingOrOffset, length) {\\r\\n  return from(value, encodingOrOffset, length)\\r\\n}\\r\\n\\r\\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\\r\\n// https://github.com/feross/buffer/pull/148\\r\\nBuffer.prototype.__proto__ = Uint8Array.prototype\\r\\nBuffer.__proto__ = Uint8Array\\r\\n\\r\\nfunction assertSize (size) {\\r\\n  if (typeof size !== 'number') {\\r\\n    throw new TypeError('\\\"size\\\" argument must be a number')\\r\\n  } else if (size < 0) {\\r\\n    throw new RangeError('\\\"size\\\" argument must not be negative')\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction alloc (size, fill, encoding) {\\r\\n  assertSize(size)\\r\\n  if (size <= 0) {\\r\\n    return createBuffer(size)\\r\\n  }\\r\\n  if (fill !== undefined) {\\r\\n    // Only pay attention to encoding if it's a string. This\\r\\n    // prevents accidentally sending in a number that would\\r\\n    // be interpretted as a start offset.\\r\\n    return typeof encoding === 'string'\\r\\n      ? createBuffer(size).fill(fill, encoding)\\r\\n      : createBuffer(size).fill(fill)\\r\\n  }\\r\\n  return createBuffer(size)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a new filled Buffer instance.\\r\\n * alloc(size[, fill[, encoding]])\\r\\n **/\\r\\nBuffer.alloc = function (size, fill, encoding) {\\r\\n  return alloc(size, fill, encoding)\\r\\n}\\r\\n\\r\\nfunction allocUnsafe (size) {\\r\\n  assertSize(size)\\r\\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\\r\\n * */\\r\\nBuffer.allocUnsafe = function (size) {\\r\\n  return allocUnsafe(size)\\r\\n}\\r\\n/**\\r\\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\\r\\n */\\r\\nBuffer.allocUnsafeSlow = function (size) {\\r\\n  return allocUnsafe(size)\\r\\n}\\r\\n\\r\\nfunction fromString (string, encoding) {\\r\\n  if (typeof encoding !== 'string' || encoding === '') {\\r\\n    encoding = 'utf8'\\r\\n  }\\r\\n\\r\\n  if (!Buffer.isEncoding(encoding)) {\\r\\n    throw new TypeError('\\\"encoding\\\" must be a valid string encoding')\\r\\n  }\\r\\n\\r\\n  var length = byteLength(string, encoding) | 0\\r\\n  var buf = createBuffer(length)\\r\\n\\r\\n  var actual = buf.write(string, encoding)\\r\\n\\r\\n  if (actual !== length) {\\r\\n    // Writing a hex string, for example, that contains invalid characters will\\r\\n    // cause everything after the first invalid character to be ignored. (e.g.\\r\\n    // 'abxxcd' will be treated as 'ab')\\r\\n    buf = buf.slice(0, actual)\\r\\n  }\\r\\n\\r\\n  return buf\\r\\n}\\r\\n\\r\\nfunction fromArrayLike (array) {\\r\\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\\r\\n  var buf = createBuffer(length)\\r\\n  for (var i = 0; i < length; i += 1) {\\r\\n    buf[i] = array[i] & 255\\r\\n  }\\r\\n  return buf\\r\\n}\\r\\n\\r\\nfunction fromArrayBuffer (array, byteOffset, length) {\\r\\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\\r\\n    throw new RangeError('\\\\'offset\\\\' is out of bounds')\\r\\n  }\\r\\n\\r\\n  if (array.byteLength < byteOffset + (length || 0)) {\\r\\n    throw new RangeError('\\\\'length\\\\' is out of bounds')\\r\\n  }\\r\\n\\r\\n  var buf\\r\\n  if (byteOffset === undefined && length === undefined) {\\r\\n    buf = new Uint8Array(array)\\r\\n  } else if (length === undefined) {\\r\\n    buf = new Uint8Array(array, byteOffset)\\r\\n  } else {\\r\\n    buf = new Uint8Array(array, byteOffset, length)\\r\\n  }\\r\\n\\r\\n  // Return an augmented `Uint8Array` instance\\r\\n  buf.__proto__ = Buffer.prototype\\r\\n  return buf\\r\\n}\\r\\n\\r\\nfunction fromObject (obj) {\\r\\n  if (Buffer.isBuffer(obj)) {\\r\\n    var len = checked(obj.length) | 0\\r\\n    var buf = createBuffer(len)\\r\\n\\r\\n    if (buf.length === 0) {\\r\\n      return buf\\r\\n    }\\r\\n\\r\\n    obj.copy(buf, 0, 0, len)\\r\\n    return buf\\r\\n  }\\r\\n\\r\\n  if (obj) {\\r\\n    if (isArrayBufferView(obj) || 'length' in obj) {\\r\\n      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\\r\\n        return createBuffer(0)\\r\\n      }\\r\\n      return fromArrayLike(obj)\\r\\n    }\\r\\n\\r\\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\\r\\n      return fromArrayLike(obj.data)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\\r\\n}\\r\\n\\r\\nfunction checked (length) {\\r\\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\\r\\n  // length is NaN (which is otherwise coerced to zero.)\\r\\n  if (length >= K_MAX_LENGTH) {\\r\\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\\r\\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\\r\\n  }\\r\\n  return length | 0\\r\\n}\\r\\n\\r\\nfunction SlowBuffer (length) {\\r\\n  if (+length != length) { // eslint-disable-line eqeqeq\\r\\n    length = 0\\r\\n  }\\r\\n  return Buffer.alloc(+length)\\r\\n}\\r\\n\\r\\nBuffer.isBuffer = function isBuffer (b) {\\r\\n  return b != null && b._isBuffer === true\\r\\n}\\r\\n\\r\\nBuffer.compare = function compare (a, b) {\\r\\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\\r\\n    throw new TypeError('Arguments must be Buffers')\\r\\n  }\\r\\n\\r\\n  if (a === b) return 0\\r\\n\\r\\n  var x = a.length\\r\\n  var y = b.length\\r\\n\\r\\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\\r\\n    if (a[i] !== b[i]) {\\r\\n      x = a[i]\\r\\n      y = b[i]\\r\\n      break\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (x < y) return -1\\r\\n  if (y < x) return 1\\r\\n  return 0\\r\\n}\\r\\n\\r\\nBuffer.isEncoding = function isEncoding (encoding) {\\r\\n  switch (String(encoding).toLowerCase()) {\\r\\n    case 'hex':\\r\\n    case 'utf8':\\r\\n    case 'utf-8':\\r\\n    case 'ascii':\\r\\n    case 'latin1':\\r\\n    case 'binary':\\r\\n    case 'base64':\\r\\n    case 'ucs2':\\r\\n    case 'ucs-2':\\r\\n    case 'utf16le':\\r\\n    case 'utf-16le':\\r\\n      return true\\r\\n    default:\\r\\n      return false\\r\\n  }\\r\\n}\\r\\n\\r\\nBuffer.concat = function concat (list, length) {\\r\\n  if (!Array.isArray(list)) {\\r\\n    throw new TypeError('\\\"list\\\" argument must be an Array of Buffers')\\r\\n  }\\r\\n\\r\\n  if (list.length === 0) {\\r\\n    return Buffer.alloc(0)\\r\\n  }\\r\\n\\r\\n  var i\\r\\n  if (length === undefined) {\\r\\n    length = 0\\r\\n    for (i = 0; i < list.length; ++i) {\\r\\n      length += list[i].length\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var buffer = Buffer.allocUnsafe(length)\\r\\n  var pos = 0\\r\\n  for (i = 0; i < list.length; ++i) {\\r\\n    var buf = list[i]\\r\\n    if (!Buffer.isBuffer(buf)) {\\r\\n      throw new TypeError('\\\"list\\\" argument must be an Array of Buffers')\\r\\n    }\\r\\n    buf.copy(buffer, pos)\\r\\n    pos += buf.length\\r\\n  }\\r\\n  return buffer\\r\\n}\\r\\n\\r\\nfunction byteLength (string, encoding) {\\r\\n  if (Buffer.isBuffer(string)) {\\r\\n    return string.length\\r\\n  }\\r\\n  if (isArrayBufferView(string) || isArrayBuffer(string)) {\\r\\n    return string.byteLength\\r\\n  }\\r\\n  if (typeof string !== 'string') {\\r\\n    string = '' + string\\r\\n  }\\r\\n\\r\\n  var len = string.length\\r\\n  if (len === 0) return 0\\r\\n\\r\\n  // Use a for loop to avoid recursion\\r\\n  var loweredCase = false\\r\\n  for (;;) {\\r\\n    switch (encoding) {\\r\\n      case 'ascii':\\r\\n      case 'latin1':\\r\\n      case 'binary':\\r\\n        return len\\r\\n      case 'utf8':\\r\\n      case 'utf-8':\\r\\n      case undefined:\\r\\n        return utf8ToBytes(string).length\\r\\n      case 'ucs2':\\r\\n      case 'ucs-2':\\r\\n      case 'utf16le':\\r\\n      case 'utf-16le':\\r\\n        return len * 2\\r\\n      case 'hex':\\r\\n        return len >>> 1\\r\\n      case 'base64':\\r\\n        return base64ToBytes(string).length\\r\\n      default:\\r\\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\\r\\n        encoding = ('' + encoding).toLowerCase()\\r\\n        loweredCase = true\\r\\n    }\\r\\n  }\\r\\n}\\r\\nBuffer.byteLength = byteLength\\r\\n\\r\\nfunction slowToString (encoding, start, end) {\\r\\n  var loweredCase = false\\r\\n\\r\\n  // No need to verify that \\\"this.length <= MAX_UINT32\\\" since it's a read-only\\r\\n  // property of a typed array.\\r\\n\\r\\n  // This behaves neither like String nor Uint8Array in that we set start/end\\r\\n  // to their upper/lower bounds if the value passed is out of range.\\r\\n  // undefined is handled specially as per ECMA-262 6th Edition,\\r\\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\\r\\n  if (start === undefined || start < 0) {\\r\\n    start = 0\\r\\n  }\\r\\n  // Return early if start > this.length. Done here to prevent potential uint32\\r\\n  // coercion fail below.\\r\\n  if (start > this.length) {\\r\\n    return ''\\r\\n  }\\r\\n\\r\\n  if (end === undefined || end > this.length) {\\r\\n    end = this.length\\r\\n  }\\r\\n\\r\\n  if (end <= 0) {\\r\\n    return ''\\r\\n  }\\r\\n\\r\\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\\r\\n  end >>>= 0\\r\\n  start >>>= 0\\r\\n\\r\\n  if (end <= start) {\\r\\n    return ''\\r\\n  }\\r\\n\\r\\n  if (!encoding) encoding = 'utf8'\\r\\n\\r\\n  while (true) {\\r\\n    switch (encoding) {\\r\\n      case 'hex':\\r\\n        return hexSlice(this, start, end)\\r\\n\\r\\n      case 'utf8':\\r\\n      case 'utf-8':\\r\\n        return utf8Slice(this, start, end)\\r\\n\\r\\n      case 'ascii':\\r\\n        return asciiSlice(this, start, end)\\r\\n\\r\\n      case 'latin1':\\r\\n      case 'binary':\\r\\n        return latin1Slice(this, start, end)\\r\\n\\r\\n      case 'base64':\\r\\n        return base64Slice(this, start, end)\\r\\n\\r\\n      case 'ucs2':\\r\\n      case 'ucs-2':\\r\\n      case 'utf16le':\\r\\n      case 'utf-16le':\\r\\n        return utf16leSlice(this, start, end)\\r\\n\\r\\n      default:\\r\\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\\r\\n        encoding = (encoding + '').toLowerCase()\\r\\n        loweredCase = true\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\\r\\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\\r\\n// reliably in a browserify context because there could be multiple different\\r\\n// copies of the 'buffer' package in use. This method works even for Buffer\\r\\n// instances that were created from another copy of the `buffer` package.\\r\\n// See: https://github.com/feross/buffer/issues/154\\r\\nBuffer.prototype._isBuffer = true\\r\\n\\r\\nfunction swap (b, n, m) {\\r\\n  var i = b[n]\\r\\n  b[n] = b[m]\\r\\n  b[m] = i\\r\\n}\\r\\n\\r\\nBuffer.prototype.swap16 = function swap16 () {\\r\\n  var len = this.length\\r\\n  if (len % 2 !== 0) {\\r\\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\\r\\n  }\\r\\n  for (var i = 0; i < len; i += 2) {\\r\\n    swap(this, i, i + 1)\\r\\n  }\\r\\n  return this\\r\\n}\\r\\n\\r\\nBuffer.prototype.swap32 = function swap32 () {\\r\\n  var len = this.length\\r\\n  if (len % 4 !== 0) {\\r\\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\\r\\n  }\\r\\n  for (var i = 0; i < len; i += 4) {\\r\\n    swap(this, i, i + 3)\\r\\n    swap(this, i + 1, i + 2)\\r\\n  }\\r\\n  return this\\r\\n}\\r\\n\\r\\nBuffer.prototype.swap64 = function swap64 () {\\r\\n  var len = this.length\\r\\n  if (len % 8 !== 0) {\\r\\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\\r\\n  }\\r\\n  for (var i = 0; i < len; i += 8) {\\r\\n    swap(this, i, i + 7)\\r\\n    swap(this, i + 1, i + 6)\\r\\n    swap(this, i + 2, i + 5)\\r\\n    swap(this, i + 3, i + 4)\\r\\n  }\\r\\n  return this\\r\\n}\\r\\n\\r\\nBuffer.prototype.toString = function toString () {\\r\\n  var length = this.length\\r\\n  if (length === 0) return ''\\r\\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\\r\\n  return slowToString.apply(this, arguments)\\r\\n}\\r\\n\\r\\nBuffer.prototype.equals = function equals (b) {\\r\\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\\r\\n  if (this === b) return true\\r\\n  return Buffer.compare(this, b) === 0\\r\\n}\\r\\n\\r\\nBuffer.prototype.inspect = function inspect () {\\r\\n  var str = ''\\r\\n  var max = exports.INSPECT_MAX_BYTES\\r\\n  if (this.length > 0) {\\r\\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\\r\\n    if (this.length > max) str += ' ... '\\r\\n  }\\r\\n  return '<Buffer ' + str + '>'\\r\\n}\\r\\n\\r\\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\\r\\n  if (!Buffer.isBuffer(target)) {\\r\\n    throw new TypeError('Argument must be a Buffer')\\r\\n  }\\r\\n\\r\\n  if (start === undefined) {\\r\\n    start = 0\\r\\n  }\\r\\n  if (end === undefined) {\\r\\n    end = target ? target.length : 0\\r\\n  }\\r\\n  if (thisStart === undefined) {\\r\\n    thisStart = 0\\r\\n  }\\r\\n  if (thisEnd === undefined) {\\r\\n    thisEnd = this.length\\r\\n  }\\r\\n\\r\\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\\r\\n    throw new RangeError('out of range index')\\r\\n  }\\r\\n\\r\\n  if (thisStart >= thisEnd && start >= end) {\\r\\n    return 0\\r\\n  }\\r\\n  if (thisStart >= thisEnd) {\\r\\n    return -1\\r\\n  }\\r\\n  if (start >= end) {\\r\\n    return 1\\r\\n  }\\r\\n\\r\\n  start >>>= 0\\r\\n  end >>>= 0\\r\\n  thisStart >>>= 0\\r\\n  thisEnd >>>= 0\\r\\n\\r\\n  if (this === target) return 0\\r\\n\\r\\n  var x = thisEnd - thisStart\\r\\n  var y = end - start\\r\\n  var len = Math.min(x, y)\\r\\n\\r\\n  var thisCopy = this.slice(thisStart, thisEnd)\\r\\n  var targetCopy = target.slice(start, end)\\r\\n\\r\\n  for (var i = 0; i < len; ++i) {\\r\\n    if (thisCopy[i] !== targetCopy[i]) {\\r\\n      x = thisCopy[i]\\r\\n      y = targetCopy[i]\\r\\n      break\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (x < y) return -1\\r\\n  if (y < x) return 1\\r\\n  return 0\\r\\n}\\r\\n\\r\\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\\r\\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\\r\\n//\\r\\n// Arguments:\\r\\n// - buffer - a Buffer to search\\r\\n// - val - a string, Buffer, or number\\r\\n// - byteOffset - an index into `buffer`; will be clamped to an int32\\r\\n// - encoding - an optional encoding, relevant is val is a string\\r\\n// - dir - true for indexOf, false for lastIndexOf\\r\\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\\r\\n  // Empty buffer means no match\\r\\n  if (buffer.length === 0) return -1\\r\\n\\r\\n  // Normalize byteOffset\\r\\n  if (typeof byteOffset === 'string') {\\r\\n    encoding = byteOffset\\r\\n    byteOffset = 0\\r\\n  } else if (byteOffset > 0x7fffffff) {\\r\\n    byteOffset = 0x7fffffff\\r\\n  } else if (byteOffset < -0x80000000) {\\r\\n    byteOffset = -0x80000000\\r\\n  }\\r\\n  byteOffset = +byteOffset  // Coerce to Number.\\r\\n  if (numberIsNaN(byteOffset)) {\\r\\n    // byteOffset: it it's undefined, null, NaN, \\\"foo\\\", etc, search whole buffer\\r\\n    byteOffset = dir ? 0 : (buffer.length - 1)\\r\\n  }\\r\\n\\r\\n  // Normalize byteOffset: negative offsets start from the end of the buffer\\r\\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\\r\\n  if (byteOffset >= buffer.length) {\\r\\n    if (dir) return -1\\r\\n    else byteOffset = buffer.length - 1\\r\\n  } else if (byteOffset < 0) {\\r\\n    if (dir) byteOffset = 0\\r\\n    else return -1\\r\\n  }\\r\\n\\r\\n  // Normalize val\\r\\n  if (typeof val === 'string') {\\r\\n    val = Buffer.from(val, encoding)\\r\\n  }\\r\\n\\r\\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\\r\\n  if (Buffer.isBuffer(val)) {\\r\\n    // Special case: looking for empty string/buffer always fails\\r\\n    if (val.length === 0) {\\r\\n      return -1\\r\\n    }\\r\\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\\r\\n  } else if (typeof val === 'number') {\\r\\n    val = val & 0xFF // Search for a byte value [0-255]\\r\\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\\r\\n      if (dir) {\\r\\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\\r\\n      } else {\\r\\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\\r\\n      }\\r\\n    }\\r\\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\\r\\n  }\\r\\n\\r\\n  throw new TypeError('val must be string, number or Buffer')\\r\\n}\\r\\n\\r\\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\\r\\n  var indexSize = 1\\r\\n  var arrLength = arr.length\\r\\n  var valLength = val.length\\r\\n\\r\\n  if (encoding !== undefined) {\\r\\n    encoding = String(encoding).toLowerCase()\\r\\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\\r\\n        encoding === 'utf16le' || encoding === 'utf-16le') {\\r\\n      if (arr.length < 2 || val.length < 2) {\\r\\n        return -1\\r\\n      }\\r\\n      indexSize = 2\\r\\n      arrLength /= 2\\r\\n      valLength /= 2\\r\\n      byteOffset /= 2\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function read (buf, i) {\\r\\n    if (indexSize === 1) {\\r\\n      return buf[i]\\r\\n    } else {\\r\\n      return buf.readUInt16BE(i * indexSize)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var i\\r\\n  if (dir) {\\r\\n    var foundIndex = -1\\r\\n    for (i = byteOffset; i < arrLength; i++) {\\r\\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\\r\\n        if (foundIndex === -1) foundIndex = i\\r\\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\\r\\n      } else {\\r\\n        if (foundIndex !== -1) i -= i - foundIndex\\r\\n        foundIndex = -1\\r\\n      }\\r\\n    }\\r\\n  } else {\\r\\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\\r\\n    for (i = byteOffset; i >= 0; i--) {\\r\\n      var found = true\\r\\n      for (var j = 0; j < valLength; j++) {\\r\\n        if (read(arr, i + j) !== read(val, j)) {\\r\\n          found = false\\r\\n          break\\r\\n        }\\r\\n      }\\r\\n      if (found) return i\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return -1\\r\\n}\\r\\n\\r\\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\\r\\n  return this.indexOf(val, byteOffset, encoding) !== -1\\r\\n}\\r\\n\\r\\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\\r\\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\\r\\n}\\r\\n\\r\\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\\r\\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\\r\\n}\\r\\n\\r\\nfunction hexWrite (buf, string, offset, length) {\\r\\n  offset = Number(offset) || 0\\r\\n  var remaining = buf.length - offset\\r\\n  if (!length) {\\r\\n    length = remaining\\r\\n  } else {\\r\\n    length = Number(length)\\r\\n    if (length > remaining) {\\r\\n      length = remaining\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // must be an even number of digits\\r\\n  var strLen = string.length\\r\\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\\r\\n\\r\\n  if (length > strLen / 2) {\\r\\n    length = strLen / 2\\r\\n  }\\r\\n  for (var i = 0; i < length; ++i) {\\r\\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\\r\\n    if (numberIsNaN(parsed)) return i\\r\\n    buf[offset + i] = parsed\\r\\n  }\\r\\n  return i\\r\\n}\\r\\n\\r\\nfunction utf8Write (buf, string, offset, length) {\\r\\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\\r\\n}\\r\\n\\r\\nfunction asciiWrite (buf, string, offset, length) {\\r\\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\\r\\n}\\r\\n\\r\\nfunction latin1Write (buf, string, offset, length) {\\r\\n  return asciiWrite(buf, string, offset, length)\\r\\n}\\r\\n\\r\\nfunction base64Write (buf, string, offset, length) {\\r\\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\\r\\n}\\r\\n\\r\\nfunction ucs2Write (buf, string, offset, length) {\\r\\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\\r\\n}\\r\\n\\r\\nBuffer.prototype.write = function write (string, offset, length, encoding) {\\r\\n  // Buffer#write(string)\\r\\n  if (offset === undefined) {\\r\\n    encoding = 'utf8'\\r\\n    length = this.length\\r\\n    offset = 0\\r\\n  // Buffer#write(string, encoding)\\r\\n  } else if (length === undefined && typeof offset === 'string') {\\r\\n    encoding = offset\\r\\n    length = this.length\\r\\n    offset = 0\\r\\n  // Buffer#write(string, offset[, length][, encoding])\\r\\n  } else if (isFinite(offset)) {\\r\\n    offset = offset >>> 0\\r\\n    if (isFinite(length)) {\\r\\n      length = length >>> 0\\r\\n      if (encoding === undefined) encoding = 'utf8'\\r\\n    } else {\\r\\n      encoding = length\\r\\n      length = undefined\\r\\n    }\\r\\n  } else {\\r\\n    throw new Error(\\r\\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\\r\\n    )\\r\\n  }\\r\\n\\r\\n  var remaining = this.length - offset\\r\\n  if (length === undefined || length > remaining) length = remaining\\r\\n\\r\\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\\r\\n    throw new RangeError('Attempt to write outside buffer bounds')\\r\\n  }\\r\\n\\r\\n  if (!encoding) encoding = 'utf8'\\r\\n\\r\\n  var loweredCase = false\\r\\n  for (;;) {\\r\\n    switch (encoding) {\\r\\n      case 'hex':\\r\\n        return hexWrite(this, string, offset, length)\\r\\n\\r\\n      case 'utf8':\\r\\n      case 'utf-8':\\r\\n        return utf8Write(this, string, offset, length)\\r\\n\\r\\n      case 'ascii':\\r\\n        return asciiWrite(this, string, offset, length)\\r\\n\\r\\n      case 'latin1':\\r\\n      case 'binary':\\r\\n        return latin1Write(this, string, offset, length)\\r\\n\\r\\n      case 'base64':\\r\\n        // Warning: maxLength not taken into account in base64Write\\r\\n        return base64Write(this, string, offset, length)\\r\\n\\r\\n      case 'ucs2':\\r\\n      case 'ucs-2':\\r\\n      case 'utf16le':\\r\\n      case 'utf-16le':\\r\\n        return ucs2Write(this, string, offset, length)\\r\\n\\r\\n      default:\\r\\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\\r\\n        encoding = ('' + encoding).toLowerCase()\\r\\n        loweredCase = true\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nBuffer.prototype.toJSON = function toJSON () {\\r\\n  return {\\r\\n    type: 'Buffer',\\r\\n    data: Array.prototype.slice.call(this._arr || this, 0)\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction base64Slice (buf, start, end) {\\r\\n  if (start === 0 && end === buf.length) {\\r\\n    return base64.fromByteArray(buf)\\r\\n  } else {\\r\\n    return base64.fromByteArray(buf.slice(start, end))\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction utf8Slice (buf, start, end) {\\r\\n  end = Math.min(buf.length, end)\\r\\n  var res = []\\r\\n\\r\\n  var i = start\\r\\n  while (i < end) {\\r\\n    var firstByte = buf[i]\\r\\n    var codePoint = null\\r\\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\\r\\n      : (firstByte > 0xDF) ? 3\\r\\n      : (firstByte > 0xBF) ? 2\\r\\n      : 1\\r\\n\\r\\n    if (i + bytesPerSequence <= end) {\\r\\n      var secondByte, thirdByte, fourthByte, tempCodePoint\\r\\n\\r\\n      switch (bytesPerSequence) {\\r\\n        case 1:\\r\\n          if (firstByte < 0x80) {\\r\\n            codePoint = firstByte\\r\\n          }\\r\\n          break\\r\\n        case 2:\\r\\n          secondByte = buf[i + 1]\\r\\n          if ((secondByte & 0xC0) === 0x80) {\\r\\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\\r\\n            if (tempCodePoint > 0x7F) {\\r\\n              codePoint = tempCodePoint\\r\\n            }\\r\\n          }\\r\\n          break\\r\\n        case 3:\\r\\n          secondByte = buf[i + 1]\\r\\n          thirdByte = buf[i + 2]\\r\\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\\r\\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\\r\\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\\r\\n              codePoint = tempCodePoint\\r\\n            }\\r\\n          }\\r\\n          break\\r\\n        case 4:\\r\\n          secondByte = buf[i + 1]\\r\\n          thirdByte = buf[i + 2]\\r\\n          fourthByte = buf[i + 3]\\r\\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\\r\\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\\r\\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\\r\\n              codePoint = tempCodePoint\\r\\n            }\\r\\n          }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (codePoint === null) {\\r\\n      // we did not generate a valid codePoint so insert a\\r\\n      // replacement char (U+FFFD) and advance only 1 byte\\r\\n      codePoint = 0xFFFD\\r\\n      bytesPerSequence = 1\\r\\n    } else if (codePoint > 0xFFFF) {\\r\\n      // encode to utf16 (surrogate pair dance)\\r\\n      codePoint -= 0x10000\\r\\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\\r\\n      codePoint = 0xDC00 | codePoint & 0x3FF\\r\\n    }\\r\\n\\r\\n    res.push(codePoint)\\r\\n    i += bytesPerSequence\\r\\n  }\\r\\n\\r\\n  return decodeCodePointsArray(res)\\r\\n}\\r\\n\\r\\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\\r\\n// the lowest limit is Chrome, with 0x10000 args.\\r\\n// We go 1 magnitude less, for safety\\r\\nvar MAX_ARGUMENTS_LENGTH = 0x1000\\r\\n\\r\\nfunction decodeCodePointsArray (codePoints) {\\r\\n  var len = codePoints.length\\r\\n  if (len <= MAX_ARGUMENTS_LENGTH) {\\r\\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\\r\\n  }\\r\\n\\r\\n  // Decode in chunks to avoid \\\"call stack size exceeded\\\".\\r\\n  var res = ''\\r\\n  var i = 0\\r\\n  while (i < len) {\\r\\n    res += String.fromCharCode.apply(\\r\\n      String,\\r\\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\\r\\n    )\\r\\n  }\\r\\n  return res\\r\\n}\\r\\n\\r\\nfunction asciiSlice (buf, start, end) {\\r\\n  var ret = ''\\r\\n  end = Math.min(buf.length, end)\\r\\n\\r\\n  for (var i = start; i < end; ++i) {\\r\\n    ret += String.fromCharCode(buf[i] & 0x7F)\\r\\n  }\\r\\n  return ret\\r\\n}\\r\\n\\r\\nfunction latin1Slice (buf, start, end) {\\r\\n  var ret = ''\\r\\n  end = Math.min(buf.length, end)\\r\\n\\r\\n  for (var i = start; i < end; ++i) {\\r\\n    ret += String.fromCharCode(buf[i])\\r\\n  }\\r\\n  return ret\\r\\n}\\r\\n\\r\\nfunction hexSlice (buf, start, end) {\\r\\n  var len = buf.length\\r\\n\\r\\n  if (!start || start < 0) start = 0\\r\\n  if (!end || end < 0 || end > len) end = len\\r\\n\\r\\n  var out = ''\\r\\n  for (var i = start; i < end; ++i) {\\r\\n    out += toHex(buf[i])\\r\\n  }\\r\\n  return out\\r\\n}\\r\\n\\r\\nfunction utf16leSlice (buf, start, end) {\\r\\n  var bytes = buf.slice(start, end)\\r\\n  var res = ''\\r\\n  for (var i = 0; i < bytes.length; i += 2) {\\r\\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\\r\\n  }\\r\\n  return res\\r\\n}\\r\\n\\r\\nBuffer.prototype.slice = function slice (start, end) {\\r\\n  var len = this.length\\r\\n  start = ~~start\\r\\n  end = end === undefined ? len : ~~end\\r\\n\\r\\n  if (start < 0) {\\r\\n    start += len\\r\\n    if (start < 0) start = 0\\r\\n  } else if (start > len) {\\r\\n    start = len\\r\\n  }\\r\\n\\r\\n  if (end < 0) {\\r\\n    end += len\\r\\n    if (end < 0) end = 0\\r\\n  } else if (end > len) {\\r\\n    end = len\\r\\n  }\\r\\n\\r\\n  if (end < start) end = start\\r\\n\\r\\n  var newBuf = this.subarray(start, end)\\r\\n  // Return an augmented `Uint8Array` instance\\r\\n  newBuf.__proto__ = Buffer.prototype\\r\\n  return newBuf\\r\\n}\\r\\n\\r\\n/*\\r\\n * Need to make sure that buffer isn't trying to write out of bounds.\\r\\n */\\r\\nfunction checkOffset (offset, ext, length) {\\r\\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\\r\\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  byteLength = byteLength >>> 0\\r\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\r\\n\\r\\n  var val = this[offset]\\r\\n  var mul = 1\\r\\n  var i = 0\\r\\n  while (++i < byteLength && (mul *= 0x100)) {\\r\\n    val += this[offset + i] * mul\\r\\n  }\\r\\n\\r\\n  return val\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  byteLength = byteLength >>> 0\\r\\n  if (!noAssert) {\\r\\n    checkOffset(offset, byteLength, this.length)\\r\\n  }\\r\\n\\r\\n  var val = this[offset + --byteLength]\\r\\n  var mul = 1\\r\\n  while (byteLength > 0 && (mul *= 0x100)) {\\r\\n    val += this[offset + --byteLength] * mul\\r\\n  }\\r\\n\\r\\n  return val\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 1, this.length)\\r\\n  return this[offset]\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\r\\n  return this[offset] | (this[offset + 1] << 8)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\r\\n  return (this[offset] << 8) | this[offset + 1]\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\r\\n\\r\\n  return ((this[offset]) |\\r\\n      (this[offset + 1] << 8) |\\r\\n      (this[offset + 2] << 16)) +\\r\\n      (this[offset + 3] * 0x1000000)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\r\\n\\r\\n  return (this[offset] * 0x1000000) +\\r\\n    ((this[offset + 1] << 16) |\\r\\n    (this[offset + 2] << 8) |\\r\\n    this[offset + 3])\\r\\n}\\r\\n\\r\\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  byteLength = byteLength >>> 0\\r\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\r\\n\\r\\n  var val = this[offset]\\r\\n  var mul = 1\\r\\n  var i = 0\\r\\n  while (++i < byteLength && (mul *= 0x100)) {\\r\\n    val += this[offset + i] * mul\\r\\n  }\\r\\n  mul *= 0x80\\r\\n\\r\\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\\r\\n\\r\\n  return val\\r\\n}\\r\\n\\r\\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  byteLength = byteLength >>> 0\\r\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\r\\n\\r\\n  var i = byteLength\\r\\n  var mul = 1\\r\\n  var val = this[offset + --i]\\r\\n  while (i > 0 && (mul *= 0x100)) {\\r\\n    val += this[offset + --i] * mul\\r\\n  }\\r\\n  mul *= 0x80\\r\\n\\r\\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\\r\\n\\r\\n  return val\\r\\n}\\r\\n\\r\\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 1, this.length)\\r\\n  if (!(this[offset] & 0x80)) return (this[offset])\\r\\n  return ((0xff - this[offset] + 1) * -1)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\r\\n  var val = this[offset] | (this[offset + 1] << 8)\\r\\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\\r\\n}\\r\\n\\r\\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\r\\n  var val = this[offset + 1] | (this[offset] << 8)\\r\\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\\r\\n}\\r\\n\\r\\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\r\\n\\r\\n  return (this[offset]) |\\r\\n    (this[offset + 1] << 8) |\\r\\n    (this[offset + 2] << 16) |\\r\\n    (this[offset + 3] << 24)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\r\\n\\r\\n  return (this[offset] << 24) |\\r\\n    (this[offset + 1] << 16) |\\r\\n    (this[offset + 2] << 8) |\\r\\n    (this[offset + 3])\\r\\n}\\r\\n\\r\\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\r\\n  return ieee754.read(this, offset, true, 23, 4)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\r\\n  return ieee754.read(this, offset, false, 23, 4)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 8, this.length)\\r\\n  return ieee754.read(this, offset, true, 52, 8)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 8, this.length)\\r\\n  return ieee754.read(this, offset, false, 52, 8)\\r\\n}\\r\\n\\r\\nfunction checkInt (buf, value, offset, ext, max, min) {\\r\\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\\\"buffer\\\" argument must be a Buffer instance')\\r\\n  if (value > max || value < min) throw new RangeError('\\\"value\\\" argument is out of bounds')\\r\\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  byteLength = byteLength >>> 0\\r\\n  if (!noAssert) {\\r\\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\\r\\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\\r\\n  }\\r\\n\\r\\n  var mul = 1\\r\\n  var i = 0\\r\\n  this[offset] = value & 0xFF\\r\\n  while (++i < byteLength && (mul *= 0x100)) {\\r\\n    this[offset + i] = (value / mul) & 0xFF\\r\\n  }\\r\\n\\r\\n  return offset + byteLength\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  byteLength = byteLength >>> 0\\r\\n  if (!noAssert) {\\r\\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\\r\\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\\r\\n  }\\r\\n\\r\\n  var i = byteLength - 1\\r\\n  var mul = 1\\r\\n  this[offset + i] = value & 0xFF\\r\\n  while (--i >= 0 && (mul *= 0x100)) {\\r\\n    this[offset + i] = (value / mul) & 0xFF\\r\\n  }\\r\\n\\r\\n  return offset + byteLength\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\\r\\n  this[offset] = (value & 0xff)\\r\\n  return offset + 1\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\\r\\n  this[offset] = (value & 0xff)\\r\\n  this[offset + 1] = (value >>> 8)\\r\\n  return offset + 2\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\\r\\n  this[offset] = (value >>> 8)\\r\\n  this[offset + 1] = (value & 0xff)\\r\\n  return offset + 2\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\\r\\n  this[offset + 3] = (value >>> 24)\\r\\n  this[offset + 2] = (value >>> 16)\\r\\n  this[offset + 1] = (value >>> 8)\\r\\n  this[offset] = (value & 0xff)\\r\\n  return offset + 4\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\\r\\n  this[offset] = (value >>> 24)\\r\\n  this[offset + 1] = (value >>> 16)\\r\\n  this[offset + 2] = (value >>> 8)\\r\\n  this[offset + 3] = (value & 0xff)\\r\\n  return offset + 4\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) {\\r\\n    var limit = Math.pow(2, (8 * byteLength) - 1)\\r\\n\\r\\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\\r\\n  }\\r\\n\\r\\n  var i = 0\\r\\n  var mul = 1\\r\\n  var sub = 0\\r\\n  this[offset] = value & 0xFF\\r\\n  while (++i < byteLength && (mul *= 0x100)) {\\r\\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\\r\\n      sub = 1\\r\\n    }\\r\\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\\r\\n  }\\r\\n\\r\\n  return offset + byteLength\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) {\\r\\n    var limit = Math.pow(2, (8 * byteLength) - 1)\\r\\n\\r\\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\\r\\n  }\\r\\n\\r\\n  var i = byteLength - 1\\r\\n  var mul = 1\\r\\n  var sub = 0\\r\\n  this[offset + i] = value & 0xFF\\r\\n  while (--i >= 0 && (mul *= 0x100)) {\\r\\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\\r\\n      sub = 1\\r\\n    }\\r\\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\\r\\n  }\\r\\n\\r\\n  return offset + byteLength\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\\r\\n  if (value < 0) value = 0xff + value + 1\\r\\n  this[offset] = (value & 0xff)\\r\\n  return offset + 1\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\\r\\n  this[offset] = (value & 0xff)\\r\\n  this[offset + 1] = (value >>> 8)\\r\\n  return offset + 2\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\\r\\n  this[offset] = (value >>> 8)\\r\\n  this[offset + 1] = (value & 0xff)\\r\\n  return offset + 2\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\\r\\n  this[offset] = (value & 0xff)\\r\\n  this[offset + 1] = (value >>> 8)\\r\\n  this[offset + 2] = (value >>> 16)\\r\\n  this[offset + 3] = (value >>> 24)\\r\\n  return offset + 4\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\\r\\n  if (value < 0) value = 0xffffffff + value + 1\\r\\n  this[offset] = (value >>> 24)\\r\\n  this[offset + 1] = (value >>> 16)\\r\\n  this[offset + 2] = (value >>> 8)\\r\\n  this[offset + 3] = (value & 0xff)\\r\\n  return offset + 4\\r\\n}\\r\\n\\r\\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\\r\\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\\r\\n  if (offset < 0) throw new RangeError('Index out of range')\\r\\n}\\r\\n\\r\\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) {\\r\\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\\r\\n  }\\r\\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\\r\\n  return offset + 4\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\\r\\n  return writeFloat(this, value, offset, true, noAssert)\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\\r\\n  return writeFloat(this, value, offset, false, noAssert)\\r\\n}\\r\\n\\r\\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) {\\r\\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\\r\\n  }\\r\\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\\r\\n  return offset + 8\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\\r\\n  return writeDouble(this, value, offset, true, noAssert)\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\\r\\n  return writeDouble(this, value, offset, false, noAssert)\\r\\n}\\r\\n\\r\\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\\r\\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\\r\\n  if (!start) start = 0\\r\\n  if (!end && end !== 0) end = this.length\\r\\n  if (targetStart >= target.length) targetStart = target.length\\r\\n  if (!targetStart) targetStart = 0\\r\\n  if (end > 0 && end < start) end = start\\r\\n\\r\\n  // Copy 0 bytes; we're done\\r\\n  if (end === start) return 0\\r\\n  if (target.length === 0 || this.length === 0) return 0\\r\\n\\r\\n  // Fatal error conditions\\r\\n  if (targetStart < 0) {\\r\\n    throw new RangeError('targetStart out of bounds')\\r\\n  }\\r\\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\\r\\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\\r\\n\\r\\n  // Are we oob?\\r\\n  if (end > this.length) end = this.length\\r\\n  if (target.length - targetStart < end - start) {\\r\\n    end = target.length - targetStart + start\\r\\n  }\\r\\n\\r\\n  var len = end - start\\r\\n  var i\\r\\n\\r\\n  if (this === target && start < targetStart && targetStart < end) {\\r\\n    // descending copy from end\\r\\n    for (i = len - 1; i >= 0; --i) {\\r\\n      target[i + targetStart] = this[i + start]\\r\\n    }\\r\\n  } else if (len < 1000) {\\r\\n    // ascending copy from start\\r\\n    for (i = 0; i < len; ++i) {\\r\\n      target[i + targetStart] = this[i + start]\\r\\n    }\\r\\n  } else {\\r\\n    Uint8Array.prototype.set.call(\\r\\n      target,\\r\\n      this.subarray(start, start + len),\\r\\n      targetStart\\r\\n    )\\r\\n  }\\r\\n\\r\\n  return len\\r\\n}\\r\\n\\r\\n// Usage:\\r\\n//    buffer.fill(number[, offset[, end]])\\r\\n//    buffer.fill(buffer[, offset[, end]])\\r\\n//    buffer.fill(string[, offset[, end]][, encoding])\\r\\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\\r\\n  // Handle string cases:\\r\\n  if (typeof val === 'string') {\\r\\n    if (typeof start === 'string') {\\r\\n      encoding = start\\r\\n      start = 0\\r\\n      end = this.length\\r\\n    } else if (typeof end === 'string') {\\r\\n      encoding = end\\r\\n      end = this.length\\r\\n    }\\r\\n    if (val.length === 1) {\\r\\n      var code = val.charCodeAt(0)\\r\\n      if (code < 256) {\\r\\n        val = code\\r\\n      }\\r\\n    }\\r\\n    if (encoding !== undefined && typeof encoding !== 'string') {\\r\\n      throw new TypeError('encoding must be a string')\\r\\n    }\\r\\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\\r\\n      throw new TypeError('Unknown encoding: ' + encoding)\\r\\n    }\\r\\n  } else if (typeof val === 'number') {\\r\\n    val = val & 255\\r\\n  }\\r\\n\\r\\n  // Invalid ranges are not set to a default, so can range check early.\\r\\n  if (start < 0 || this.length < start || this.length < end) {\\r\\n    throw new RangeError('Out of range index')\\r\\n  }\\r\\n\\r\\n  if (end <= start) {\\r\\n    return this\\r\\n  }\\r\\n\\r\\n  start = start >>> 0\\r\\n  end = end === undefined ? this.length : end >>> 0\\r\\n\\r\\n  if (!val) val = 0\\r\\n\\r\\n  var i\\r\\n  if (typeof val === 'number') {\\r\\n    for (i = start; i < end; ++i) {\\r\\n      this[i] = val\\r\\n    }\\r\\n  } else {\\r\\n    var bytes = Buffer.isBuffer(val)\\r\\n      ? val\\r\\n      : new Buffer(val, encoding)\\r\\n    var len = bytes.length\\r\\n    for (i = 0; i < end - start; ++i) {\\r\\n      this[i + start] = bytes[i % len]\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return this\\r\\n}\\r\\n\\r\\n// HELPER FUNCTIONS\\r\\n// ================\\r\\n\\r\\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\\r\\n\\r\\nfunction base64clean (str) {\\r\\n  // Node strips out invalid characters like \\\\n and \\\\t from the string, base64-js does not\\r\\n  str = str.trim().replace(INVALID_BASE64_RE, '')\\r\\n  // Node converts strings with length < 2 to ''\\r\\n  if (str.length < 2) return ''\\r\\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\\r\\n  while (str.length % 4 !== 0) {\\r\\n    str = str + '='\\r\\n  }\\r\\n  return str\\r\\n}\\r\\n\\r\\nfunction toHex (n) {\\r\\n  if (n < 16) return '0' + n.toString(16)\\r\\n  return n.toString(16)\\r\\n}\\r\\n\\r\\nfunction utf8ToBytes (string, units) {\\r\\n  units = units || Infinity\\r\\n  var codePoint\\r\\n  var length = string.length\\r\\n  var leadSurrogate = null\\r\\n  var bytes = []\\r\\n\\r\\n  for (var i = 0; i < length; ++i) {\\r\\n    codePoint = string.charCodeAt(i)\\r\\n\\r\\n    // is surrogate component\\r\\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\\r\\n      // last char was a lead\\r\\n      if (!leadSurrogate) {\\r\\n        // no lead yet\\r\\n        if (codePoint > 0xDBFF) {\\r\\n          // unexpected trail\\r\\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\r\\n          continue\\r\\n        } else if (i + 1 === length) {\\r\\n          // unpaired lead\\r\\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\r\\n          continue\\r\\n        }\\r\\n\\r\\n        // valid lead\\r\\n        leadSurrogate = codePoint\\r\\n\\r\\n        continue\\r\\n      }\\r\\n\\r\\n      // 2 leads in a row\\r\\n      if (codePoint < 0xDC00) {\\r\\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\r\\n        leadSurrogate = codePoint\\r\\n        continue\\r\\n      }\\r\\n\\r\\n      // valid surrogate pair\\r\\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\\r\\n    } else if (leadSurrogate) {\\r\\n      // valid bmp char, but last char was a lead\\r\\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\r\\n    }\\r\\n\\r\\n    leadSurrogate = null\\r\\n\\r\\n    // encode utf8\\r\\n    if (codePoint < 0x80) {\\r\\n      if ((units -= 1) < 0) break\\r\\n      bytes.push(codePoint)\\r\\n    } else if (codePoint < 0x800) {\\r\\n      if ((units -= 2) < 0) break\\r\\n      bytes.push(\\r\\n        codePoint >> 0x6 | 0xC0,\\r\\n        codePoint & 0x3F | 0x80\\r\\n      )\\r\\n    } else if (codePoint < 0x10000) {\\r\\n      if ((units -= 3) < 0) break\\r\\n      bytes.push(\\r\\n        codePoint >> 0xC | 0xE0,\\r\\n        codePoint >> 0x6 & 0x3F | 0x80,\\r\\n        codePoint & 0x3F | 0x80\\r\\n      )\\r\\n    } else if (codePoint < 0x110000) {\\r\\n      if ((units -= 4) < 0) break\\r\\n      bytes.push(\\r\\n        codePoint >> 0x12 | 0xF0,\\r\\n        codePoint >> 0xC & 0x3F | 0x80,\\r\\n        codePoint >> 0x6 & 0x3F | 0x80,\\r\\n        codePoint & 0x3F | 0x80\\r\\n      )\\r\\n    } else {\\r\\n      throw new Error('Invalid code point')\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return bytes\\r\\n}\\r\\n\\r\\nfunction asciiToBytes (str) {\\r\\n  var byteArray = []\\r\\n  for (var i = 0; i < str.length; ++i) {\\r\\n    // Node's code seems to be doing this and not & 0x7F..\\r\\n    byteArray.push(str.charCodeAt(i) & 0xFF)\\r\\n  }\\r\\n  return byteArray\\r\\n}\\r\\n\\r\\nfunction utf16leToBytes (str, units) {\\r\\n  var c, hi, lo\\r\\n  var byteArray = []\\r\\n  for (var i = 0; i < str.length; ++i) {\\r\\n    if ((units -= 2) < 0) break\\r\\n\\r\\n    c = str.charCodeAt(i)\\r\\n    hi = c >> 8\\r\\n    lo = c % 256\\r\\n    byteArray.push(lo)\\r\\n    byteArray.push(hi)\\r\\n  }\\r\\n\\r\\n  return byteArray\\r\\n}\\r\\n\\r\\nfunction base64ToBytes (str) {\\r\\n  return base64.toByteArray(base64clean(str))\\r\\n}\\r\\n\\r\\nfunction blitBuffer (src, dst, offset, length) {\\r\\n  for (var i = 0; i < length; ++i) {\\r\\n    if ((i + offset >= dst.length) || (i >= src.length)) break\\r\\n    dst[i + offset] = src[i]\\r\\n  }\\r\\n  return i\\r\\n}\\r\\n\\r\\n// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check\\r\\n// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166\\r\\nfunction isArrayBuffer (obj) {\\r\\n  return obj instanceof ArrayBuffer ||\\r\\n    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&\\r\\n      typeof obj.byteLength === 'number')\\r\\n}\\r\\n\\r\\n// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`\\r\\nfunction isArrayBufferView (obj) {\\r\\n  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)\\r\\n}\\r\\n\\r\\nfunction numberIsNaN (obj) {\\r\\n  return obj !== obj // eslint-disable-line no-self-compare\\r\\n}\\r\\n\\r\\n},{\\\"base64-js\\\":34,\\\"ieee754\\\":36}],36:[function(require,module,exports){\\r\\narguments[4][3][0].apply(exports,arguments)\\r\\n},{\\\"dup\\\":3}]},{},[1])(1)\\r\\n});\""
		},
		{
			"name": "shader.js",
			"source": "\"//  shader.js\\r\\n\\r\\nvertexShader = [\\r\\n\\r\\n\\t\\\"attribute vec4 tangent;\\\",\\r\\n\\r\\n\\t\\\"uniform float time;\\\",\\r\\n\\t\\\"uniform vec2 repeat;\\\",\\r\\n\\t\\\"uniform float useNormal;\\\",\\r\\n\\t\\\"uniform float useRim;\\\",\\r\\n\\r\\n\\t\\\"varying vec2 vUv;\\\",\\r\\n\\t\\\"varying vec3 vTangent;\\\",\\r\\n\\t\\\"varying vec3 vBinormal;\\\",\\r\\n\\t\\\"varying vec3 vNormal;\\\",\\r\\n\\t\\\"varying vec3 vEye;\\\",\\r\\n\\t\\\"varying vec3 vU;\\\",\\r\\n\\t\\\"varying vec2 vN;\\\",\\r\\n\\r\\n\\t\\\"void main() {\\\",\\r\\n\\r\\n\\t\\t\\\"vU = normalize( vec3( modelViewMatrix * vec4( position, 1.0 ) ) );\\\",\\r\\n\\r\\n\\t\\t\\\"if( useNormal == 0. ) {\\\",\\r\\n\\t\\t\\t\\\"vec3 n = normalize( normalMatrix * normal );\\\",\\r\\n\\t\\t\\t\\\"vec3 r = reflect( vU, n );\\\",\\r\\n\\t\\t\\t\\\"float m = 2.0 * sqrt( r.x * r.x + r.y * r.y + ( r.z + 1.0 ) * ( r.z+1.0 ) );\\\",\\r\\n\\t\\t\\t\\\"vN = vec2( r.x / m + 0.5,  r.y / m + 0.5 );\\\",\\r\\n\\t\\t\\\"} else {\\\",\\r\\n\\t\\t\\t\\\"vN = vec2( 0. );\\\",\\r\\n\\t\\t\\\"}\\\",\\r\\n\\r\\n\\t\\t\\\"vUv = repeat * uv;\\\",\\r\\n\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\r\\n\\r\\n\\t\\t\\\"vNormal = normalize( normalMatrix * normal );\\\",\\r\\n\\t\\t\\\"if( useNormal == 1. ) {\\\",\\r\\n\\t\\t\\t\\\"vTangent = normalize( normalMatrix * tangent.xyz );\\\",\\r\\n\\t\\t\\t\\\"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\\\",\\r\\n\\t\\t\\\"} else {\\\",\\r\\n\\t\\t\\t\\\"vTangent = vec3( 0. );\\\",\\r\\n\\t\\t\\t\\\"vBinormal = vec3( 0. );\\\",\\r\\n\\t\\t\\\"}\\\",\\r\\n\\r\\n\\t\\t\\\"if( useRim > 0. ) {\\\",\\r\\n\\t\\t\\t\\\"vEye = ( modelViewMatrix * vec4( position, 1.0 ) ).xyz;\\\",\\r\\n\\t\\t\\\"} else {\\\",\\r\\n\\t\\t\\t\\\"vEye = vec3( 0. );\\\",\\r\\n\\t\\t\\\"}\\\",\\r\\n\\r\\n\\t\\\"}\\\"\\r\\n\\r\\n].join(\\\" \\\");\\r\\n\\r\\nfragmentShader = [\\r\\n\\r\\n\\t\\\"uniform float time;\\\",\\r\\n\\t\\\"uniform float bump;\\\",\\r\\n\\t\\\"uniform sampler2D tNormal;\\\",\\r\\n\\t\\\"uniform sampler2D tMatCap;\\\",\\r\\n\\t\\\"uniform float noise;\\\",\\r\\n\\t\\\"uniform float useNormal;\\\",\\r\\n\\t\\\"uniform float useRim;\\\",\\r\\n\\t\\\"uniform float rimPower;\\\",\\r\\n\\t\\\"uniform float useScreen;\\\",\\r\\n\\t\\\"uniform float normalScale;\\\",\\r\\n\\t\\\"uniform float normalRepeat;\\\",\\r\\n\\r\\n\\t\\\"varying vec2 vUv;\\\",\\r\\n\\t\\\"varying vec3 vTangent;\\\",\\r\\n\\t\\\"varying vec3 vBinormal;\\\",\\r\\n\\t\\\"varying vec3 vNormal;\\\",\\r\\n\\t\\\"varying vec3 vEye;\\\",\\r\\n\\t\\\"varying vec3 vU;\\\",\\r\\n\\t\\\"varying vec2 vN;\\\",\\r\\n\\r\\n\\t\\\"float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}\\\",\\r\\n\\r\\n\\t\\\"void main() {\\\",\\r\\n\\r\\n\\t\\t\\\"vec3 finalNormal = vNormal;\\\",\\r\\n\\t\\t\\\"vec2 calculatedNormal = vN;\\\",\\r\\n\\r\\n\\t\\t\\\"if( useNormal == 1. ) {\\\",\\r\\n\\t\\t\\t\\\"vec3 normalTex = texture2D( tNormal, vUv * normalRepeat ).xyz * 2.0 - 1.0;\\\",\\r\\n\\t\\t\\t\\\"normalTex.xy *= normalScale;\\\",\\r\\n\\t\\t\\t\\\"normalTex.y *= -1.;\\\",\\r\\n\\t\\t\\t\\\"normalTex = normalize( normalTex );\\\",\\r\\n\\t\\t\\t\\\"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\\\",\\r\\n\\t\\t\\t\\\"finalNormal = tsb * normalTex;\\\",\\r\\n\\r\\n\\t\\t\\t\\\"vec3 r = reflect( vU, normalize( finalNormal ) );\\\",\\r\\n\\t\\t\\t\\\"float m = 2.0 * sqrt( r.x * r.x + r.y * r.y + ( r.z + 1.0 ) * ( r.z+1.0 ) );\\\",\\r\\n\\t\\t\\t\\\"calculatedNormal = vec2( r.x / m + 0.5,  r.y / m + 0.5 );\\\",\\r\\n\\t\\t\\\"}\\\",\\r\\n\\r\\n\\t\\t\\\"vec3 base = texture2D( tMatCap, calculatedNormal ).rgb;\\\",\\r\\n\\r\\n\\t\\t// rim lighting\\r\\n\\r\\n\\t\\t\\\"if( useRim > 0. ) {\\\",\\r\\n\\t\\t\\t\\\"float f = rimPower * abs( dot( vNormal, normalize( vEye ) ) );\\\",\\r\\n\\t\\t\\t\\\"f = useRim * ( 1. - smoothstep( 0.0, 1., f ) );\\\",\\r\\n\\t\\t\\t\\\"base += vec3( f );\\\",\\r\\n\\t\\t\\\"}\\\",\\r\\n\\r\\n\\t\\t// screen blending\\r\\n\\r\\n\\t\\t\\\"if( useScreen == 1. ) {\\\",\\r\\n\\t\\t\\t\\\"base = vec3( 1. ) - ( vec3( 1. ) - base ) * ( vec3( 1. ) - base );\\\",\\r\\n\\t\\t\\\"}\\\",\\r\\n\\r\\n\\t\\t// noise \\r\\n\\r\\n\\t\\t\\\"base += noise * ( .5 - random( vec3( 1. ), length( gl_FragCoord ) ) );\\\",\\r\\n\\r\\n\\t\\t\\\"gl_FragColor = vec4( base, 1. );\\\",\\r\\n\\r\\n\\t\\\"}\\\"\\r\\n\\r\\n].join(\\\"\\\");\\r\\n\\r\\nfunction ShaderMaterial(normalMap, matcapMap, callback){\\r\\n\\treturn new Promise( function(resolve, reject){\\r\\n\\t\\tvar material = new THREE.ShaderMaterial( {\\r\\n\\t\\t\\tuniforms: { \\r\\n\\t\\t\\t\\ttNormal: { type: \\\"t\\\", value: normalMap },\\r\\n\\t\\t\\t\\ttMatCap: { type: \\\"t\\\", value: matcapMap },\\r\\n\\t\\t\\t\\ttime: { type: \\\"f\\\", value: 0 },\\r\\n\\t\\t\\t\\tbump: { type: \\\"f\\\", value: 0 },\\r\\n\\t\\t\\t\\tnoise: { type: \\\"f\\\", value: 0.04 },\\r\\n\\t\\t\\t\\trepeat: { type: \\\"v2\\\", value: new THREE.Vector2( 1, 1 ) },\\r\\n\\t\\t\\t\\tuseNormal: { type: \\\"f\\\", value: 0 },\\r\\n\\t\\t\\t\\tuseRim: { type: \\\"f\\\", value: 0 },\\r\\n\\t\\t\\t\\trimPower: { type: \\\"f\\\", value: 0 },\\r\\n\\t\\t\\t\\tuseScreen: { type: \\\"f\\\", value: 0 },\\r\\n\\t\\t\\t\\tnormalScale: { type: \\\"f\\\", value: 1 },\\r\\n\\t\\t\\t\\tnormalRepeat: { type: \\\"f\\\", value: 1 }\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tvertexShader: vertexShader,       //  document.getElementById( \\\"vertexShader\\\" ).textContent,\\r\\n\\t\\t\\tfragmentShader: fragmentShader,   //  document.getElementById( \\\"fragmentShader\\\" ).textContent,\\r\\n\\t\\t\\tshading: THREE.SmoothShading,\\r\\n\\t\\t\\tside: THREE.DoubleSide\\r\\n\\t\\t});\\r\\n\\r\\n\\t\\tmaterial.uniforms.tMatCap.value.wrapS = material.uniforms.tMatCap.value.wrapT = THREE.ClampToEdgeWrapping;\\r\\n\\t\\tmaterial.uniforms.tNormal.value.wrapS = material.uniforms.tNormal.value.wrapT = THREE.RepeatWrapping;\\r\\n\\r\\n\\t\\tmaterial.uniforms.tMatCap.value.needsUpdate = true;\\r\\n\\t\\tmaterial.uniforms.tNormal.value.needsUpdate = true;\\r\\n\\r\\n\\t\\tif ( !!callback ) callback( material );\\r\\n\\r\\n\\t\\tresolve( material );\\r\\n\\t});\\r\\n}\\r\\n\\r\\n\""
		},
		{
			"name": "EditorControls.js",
			"source": "\"/**\\r\\n * @author qiao / https://github.com/qiao\\r\\n * @author mrdoob / http://mrdoob.com\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n */\\r\\n\\r\\nTHREE.EditorControls = function ( object, domElement ) {\\r\\n\\r\\n\\tdomElement = ( domElement !== undefined ) ? domElement : document;\\r\\n\\r\\n\\t// API\\r\\n\\r\\n\\tthis.enabled = true;\\r\\n\\tthis.center = new THREE.Vector3();\\r\\n\\r\\n\\t// internals\\r\\n\\r\\n\\tvar scope = this;\\r\\n\\tvar vector = new THREE.Vector3();\\r\\n\\r\\n\\tvar STATE = { NONE: - 1, ROTATE: 0, ZOOM: 1, PAN: 2 };\\r\\n\\tvar state = STATE.NONE;\\r\\n\\r\\n\\tvar center = this.center;\\r\\n\\tvar normalMatrix = new THREE.Matrix3();\\r\\n\\tvar pointer = new THREE.Vector2();\\r\\n\\tvar pointerOld = new THREE.Vector2();\\r\\n\\tvar spherical = new THREE.Spherical();\\r\\n\\r\\n\\t// events\\r\\n\\r\\n\\tvar changeEvent = { type: 'change' };\\r\\n\\r\\n\\tthis.focus = function ( target, frame ) {\\r\\n\\r\\n\\t\\tvar scale = new THREE.Vector3();\\r\\n\\t\\ttarget.matrixWorld.decompose( center, new THREE.Quaternion(), scale );\\r\\n\\r\\n\\t\\tif ( frame && target.geometry ) {\\r\\n\\r\\n\\t\\t\\tscale = ( scale.x + scale.y + scale.z ) / 3;\\r\\n\\t\\t\\tcenter.add( target.geometry.boundingSphere.center.clone().multiplyScalar( scale ) );\\r\\n\\t\\t\\tvar radius = target.geometry.boundingSphere.radius * ( scale );\\r\\n\\t\\t\\tvar pos = object.position.clone().sub( center ).normalize().multiplyScalar( radius * 2 );\\r\\n\\t\\t\\tobject.position.copy( center ).add( pos );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tobject.lookAt( center );\\r\\n\\r\\n\\t\\tscope.dispatchEvent( changeEvent );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.pan = function ( delta ) {\\r\\n\\r\\n\\t\\tvar distance = object.position.distanceTo( center );\\r\\n\\r\\n\\t\\tdelta.multiplyScalar( distance * 0.001 );\\r\\n\\t\\tdelta.applyMatrix3( normalMatrix.getNormalMatrix( object.matrix ) );\\r\\n\\r\\n\\t\\tobject.position.add( delta );\\r\\n\\t\\tcenter.add( delta );\\r\\n\\r\\n\\t\\tscope.dispatchEvent( changeEvent );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.zoom = function ( delta ) {\\r\\n\\r\\n\\t\\tvar distance = object.position.distanceTo( center );\\r\\n\\r\\n\\t\\tdelta.multiplyScalar( distance * 0.001 );\\r\\n\\r\\n\\t\\tif ( delta.length() > distance ) return;\\r\\n\\r\\n\\t\\tdelta.applyMatrix3( normalMatrix.getNormalMatrix( object.matrix ) );\\r\\n\\r\\n\\t\\tobject.position.add( delta );\\r\\n\\r\\n\\t\\tscope.dispatchEvent( changeEvent );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.rotate = function ( delta ) {\\r\\n\\r\\n\\t\\tvector.copy( object.position ).sub( center );\\r\\n\\r\\n\\t\\tspherical.setFromVector3( vector );\\r\\n\\r\\n\\t\\tspherical.theta += delta.x;\\r\\n\\t\\tspherical.phi += delta.y;\\r\\n\\r\\n\\t\\tspherical.makeSafe();\\r\\n\\r\\n\\t\\tvector.setFromSpherical( spherical );\\r\\n\\r\\n\\t\\tobject.position.copy( center ).add( vector );\\r\\n\\r\\n\\t\\tobject.lookAt( center );\\r\\n\\r\\n\\t\\tscope.dispatchEvent( changeEvent );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t// mouse\\r\\n\\r\\n\\tfunction onMouseDown( event ) {\\r\\n\\r\\n\\t\\tif ( scope.enabled === false ) return;\\r\\n\\r\\n\\t\\tif ( event.button === 0 ) {\\r\\n\\r\\n\\t\\t\\tstate = STATE.ROTATE;\\r\\n\\r\\n\\t\\t} else if ( event.button === 1 ) {\\r\\n\\r\\n\\t\\t\\tstate = STATE.ZOOM;\\r\\n\\r\\n\\t\\t} else if ( event.button === 2 ) {\\r\\n\\r\\n\\t\\t\\tstate = STATE.PAN;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpointerOld.set( event.clientX, event.clientY );\\r\\n\\r\\n\\t\\tdomElement.addEventListener( 'mousemove', onMouseMove, false );\\r\\n\\t\\tdomElement.addEventListener( 'mouseup', onMouseUp, false );\\r\\n\\t\\tdomElement.addEventListener( 'mouseout', onMouseUp, false );\\r\\n\\t\\tdomElement.addEventListener( 'dblclick', onMouseUp, false );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction onMouseMove( event ) {\\r\\n\\r\\n\\t\\tif ( scope.enabled === false ) return;\\r\\n\\r\\n\\t\\tpointer.set( event.clientX, event.clientY );\\r\\n\\r\\n\\t\\tvar movementX = pointer.x - pointerOld.x;\\r\\n\\t\\tvar movementY = pointer.y - pointerOld.y;\\r\\n\\r\\n\\t\\tif ( state === STATE.ROTATE ) {\\r\\n\\r\\n\\t\\t\\tscope.rotate( new THREE.Vector3( - movementX * 0.005, - movementY * 0.005, 0 ) );\\r\\n\\r\\n\\t\\t} else if ( state === STATE.ZOOM ) {\\r\\n\\r\\n\\t\\t\\tscope.zoom( new THREE.Vector3( 0, 0, movementY ) );\\r\\n\\r\\n\\t\\t} else if ( state === STATE.PAN ) {\\r\\n\\r\\n\\t\\t\\tscope.pan( new THREE.Vector3( - movementX, movementY, 0 ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpointerOld.set( event.clientX, event.clientY );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction onMouseUp( event ) {\\r\\n\\r\\n\\t\\tdomElement.removeEventListener( 'mousemove', onMouseMove, false );\\r\\n\\t\\tdomElement.removeEventListener( 'mouseup', onMouseUp, false );\\r\\n\\t\\tdomElement.removeEventListener( 'mouseout', onMouseUp, false );\\r\\n\\t\\tdomElement.removeEventListener( 'dblclick', onMouseUp, false );\\r\\n\\r\\n\\t\\tstate = STATE.NONE;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction onMouseWheel( event ) {\\r\\n\\r\\n\\t\\tevent.preventDefault();\\r\\n\\r\\n\\t\\t// if ( scope.enabled === false ) return;\\r\\n\\r\\n\\t\\tvar delta = 0;\\r\\n\\r\\n\\t\\tif ( event.wheelDelta ) {\\r\\n\\r\\n\\t\\t\\t// WebKit / Opera / Explorer 9\\r\\n\\r\\n\\t\\t\\tdelta = - event.wheelDelta;\\r\\n\\r\\n\\t\\t} else if ( event.detail ) {\\r\\n\\r\\n\\t\\t\\t// Firefox\\r\\n\\r\\n\\t\\t\\tdelta = event.detail * 10;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tscope.zoom( new THREE.Vector3( 0, 0, delta ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction contextmenu( event ) {\\r\\n\\r\\n\\t\\tevent.preventDefault();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis.dispose = function() {\\r\\n\\r\\n\\t\\tdomElement.removeEventListener( 'contextmenu', contextmenu, false );\\r\\n\\t\\tdomElement.removeEventListener( 'mousedown', onMouseDown, false );\\r\\n\\t\\tdomElement.removeEventListener( 'mousewheel', onMouseWheel, false );\\r\\n\\t\\tdomElement.removeEventListener( 'MozMousePixelScroll', onMouseWheel, false ); // firefox\\r\\n\\r\\n\\t\\tdomElement.removeEventListener( 'mousemove', onMouseMove, false );\\r\\n\\t\\tdomElement.removeEventListener( 'mouseup', onMouseUp, false );\\r\\n\\t\\tdomElement.removeEventListener( 'mouseout', onMouseUp, false );\\r\\n\\t\\tdomElement.removeEventListener( 'dblclick', onMouseUp, false );\\r\\n\\r\\n\\t\\tdomElement.removeEventListener( 'touchstart', touchStart, false );\\r\\n\\t\\tdomElement.removeEventListener( 'touchmove', touchMove, false );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tdomElement.addEventListener( 'contextmenu', contextmenu, false );\\r\\n\\tdomElement.addEventListener( 'mousedown', onMouseDown, false );\\r\\n\\tdomElement.addEventListener( 'mousewheel', onMouseWheel, false );\\r\\n\\tdomElement.addEventListener( 'MozMousePixelScroll', onMouseWheel, false ); // firefox\\r\\n\\r\\n\\t// touch\\r\\n\\r\\n\\tvar touch = new THREE.Vector3();\\r\\n\\r\\n\\tvar touches = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\\r\\n\\tvar prevTouches = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\\r\\n\\r\\n\\tvar prevDistance = null;\\r\\n\\r\\n\\tfunction touchStart( event ) {\\r\\n\\r\\n\\t\\tif ( scope.enabled === false ) return;\\r\\n\\r\\n\\t\\tswitch ( event.touches.length ) {\\r\\n\\r\\n\\t\\t\\tcase 1:\\r\\n\\t\\t\\t\\ttouches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );\\r\\n\\t\\t\\t\\ttouches[ 1 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 2:\\r\\n\\t\\t\\t\\ttouches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );\\r\\n\\t\\t\\t\\ttouches[ 1 ].set( event.touches[ 1 ].pageX, event.touches[ 1 ].pageY, 0 );\\r\\n\\t\\t\\t\\tprevDistance = touches[ 0 ].distanceTo( touches[ 1 ] );\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tprevTouches[ 0 ].copy( touches[ 0 ] );\\r\\n\\t\\tprevTouches[ 1 ].copy( touches[ 1 ] );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tfunction touchMove( event ) {\\r\\n\\r\\n\\t\\tif ( scope.enabled === false ) return;\\r\\n\\r\\n\\t\\tevent.preventDefault();\\r\\n\\t\\tevent.stopPropagation();\\r\\n\\r\\n\\t\\tfunction getClosest( touch, touches ) {\\r\\n\\r\\n\\t\\t\\tvar closest = touches[ 0 ];\\r\\n\\r\\n\\t\\t\\tfor ( var i in touches ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( closest.distanceTo( touch ) > touches[ i ].distanceTo( touch ) ) closest = touches[ i ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn closest;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tswitch ( event.touches.length ) {\\r\\n\\r\\n\\t\\t\\tcase 1:\\r\\n\\t\\t\\t\\ttouches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );\\r\\n\\t\\t\\t\\ttouches[ 1 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );\\r\\n\\t\\t\\t\\tscope.rotate( touches[ 0 ].sub( getClosest( touches[ 0 ], prevTouches ) ).multiplyScalar( - 0.005 ) );\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 2:\\r\\n\\t\\t\\t\\ttouches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );\\r\\n\\t\\t\\t\\ttouches[ 1 ].set( event.touches[ 1 ].pageX, event.touches[ 1 ].pageY, 0 );\\r\\n\\t\\t\\t\\tdistance = touches[ 0 ].distanceTo( touches[ 1 ] );\\r\\n\\t\\t\\t\\tscope.zoom( new THREE.Vector3( 0, 0, prevDistance - distance ) );\\r\\n\\t\\t\\t\\tprevDistance = distance;\\r\\n\\r\\n\\r\\n\\t\\t\\t\\tvar offset0 = touches[ 0 ].clone().sub( getClosest( touches[ 0 ], prevTouches ) );\\r\\n\\t\\t\\t\\tvar offset1 = touches[ 1 ].clone().sub( getClosest( touches[ 1 ], prevTouches ) );\\r\\n\\t\\t\\t\\toffset0.x = - offset0.x;\\r\\n\\t\\t\\t\\toffset1.x = - offset1.x;\\r\\n\\r\\n\\t\\t\\t\\tscope.pan( offset0.add( offset1 ).multiplyScalar( 0.5 ) );\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tprevTouches[ 0 ].copy( touches[ 0 ] );\\r\\n\\t\\tprevTouches[ 1 ].copy( touches[ 1 ] );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tdomElement.addEventListener( 'touchstart', touchStart, false );\\r\\n\\tdomElement.addEventListener( 'touchmove', touchMove, false );\\r\\n\\r\\n};\\r\\n\\r\\nTHREE.EditorControls.prototype = Object.create( THREE.EventDispatcher.prototype );\\r\\nTHREE.EditorControls.prototype.constructor = THREE.EditorControls;\\r\\n\""
		},
		{
			"name": "Animation.js",
			"source": "\"/**\\r\\n * @author mikael emtinger / http://gomo.se/\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n */\\r\\n\\r\\nTHREE.Animation = function ( root, data ) {\\r\\n\\r\\n\\tthis.root = root;\\r\\n\\tthis.data = THREE.AnimationHandler.init( data );\\r\\n\\tthis.hierarchy = THREE.AnimationHandler.parse( root );\\r\\n\\r\\n\\tthis.currentTime = 0;\\r\\n\\tthis.timeScale = 1;\\r\\n\\r\\n\\tthis.isPlaying = false;\\r\\n\\tthis.loop = true;\\r\\n\\tthis.weight = 0;\\r\\n\\r\\n\\tthis.interpolationType = THREE.AnimationHandler.LINEAR;\\r\\n\\r\\n};\\r\\n\\r\\nTHREE.Animation.prototype = {\\r\\n\\r\\n\\tconstructor: THREE.Animation,\\r\\n\\r\\n\\tkeyTypes:  [ \\\"pos\\\", \\\"rot\\\", \\\"scl\\\" ],\\r\\n\\r\\n\\tplay: function ( startTime, weight ) {\\r\\n\\r\\n\\t\\tthis.currentTime = startTime !== undefined ? startTime : 0;\\r\\n\\t\\tthis.weight = weight !== undefined ? weight : 1;\\r\\n\\r\\n\\t\\tthis.isPlaying = true;\\r\\n\\r\\n\\t\\tthis.reset();\\r\\n\\r\\n\\t\\tTHREE.AnimationHandler.play( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tstop: function() {\\r\\n\\r\\n\\t\\tthis.isPlaying = false;\\r\\n\\r\\n\\t\\tTHREE.AnimationHandler.stop( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\treset: function () {\\r\\n\\r\\n\\t\\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\\r\\n\\r\\n\\t\\t\\tvar object = this.hierarchy[ h ];\\r\\n\\r\\n\\t\\t\\tif ( object.animationCache === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tobject.animationCache = {\\r\\n\\t\\t\\t\\t\\tanimations: {},\\r\\n\\t\\t\\t\\t\\tblending: {\\r\\n\\t\\t\\t\\t\\t\\tpositionWeight: 0.0,\\r\\n\\t\\t\\t\\t\\t\\tquaternionWeight: 0.0,\\r\\n\\t\\t\\t\\t\\t\\tscaleWeight: 0.0\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar name = this.data.name;\\r\\n\\t\\t\\tvar animations = object.animationCache.animations;\\r\\n\\t\\t\\tvar animationCache = animations[ name ];\\r\\n\\r\\n\\t\\t\\tif ( animationCache === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tanimationCache = {\\r\\n\\t\\t\\t\\t\\tprevKey: { pos: 0, rot: 0, scl: 0 },\\r\\n\\t\\t\\t\\t\\tnextKey: { pos: 0, rot: 0, scl: 0 },\\r\\n\\t\\t\\t\\t\\toriginalMatrix: object.matrix\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t\\tanimations[ name ] = animationCache;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Get keys to match our current time\\r\\n\\r\\n\\t\\t\\tfor ( var t = 0; t < 3; t ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar type = this.keyTypes[ t ];\\r\\n\\r\\n\\t\\t\\t\\tvar prevKey = this.data.hierarchy[ h ].keys[ 0 ];\\r\\n\\t\\t\\t\\tvar nextKey = this.getNextKeyWith( type, h, 1 );\\r\\n\\r\\n\\t\\t\\t\\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tprevKey = nextKey;\\r\\n\\t\\t\\t\\t\\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tanimationCache.prevKey[ type ] = prevKey;\\r\\n\\t\\t\\t\\tanimationCache.nextKey[ type ] = nextKey;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tresetBlendWeights: function () {\\r\\n\\r\\n\\t\\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\\r\\n\\r\\n\\t\\t\\tvar object = this.hierarchy[ h ];\\r\\n\\t\\t\\tvar animationCache = object.animationCache;\\r\\n\\r\\n\\t\\t\\tif ( animationCache !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar blending = animationCache.blending;\\r\\n\\r\\n\\t\\t\\t\\tblending.positionWeight = 0.0;\\r\\n\\t\\t\\t\\tblending.quaternionWeight = 0.0;\\r\\n\\t\\t\\t\\tblending.scaleWeight = 0.0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdate: ( function() {\\r\\n\\r\\n\\t\\tvar points = [];\\r\\n\\t\\tvar target = new THREE.Vector3();\\r\\n\\t\\tvar newVector = new THREE.Vector3();\\r\\n\\t\\tvar newQuat = new THREE.Quaternion();\\r\\n\\r\\n\\t\\t// Catmull-Rom spline\\r\\n\\r\\n\\t\\tvar interpolateCatmullRom = function ( points, scale ) {\\r\\n\\r\\n\\t\\t\\tvar c = [], v3 = [],\\r\\n\\t\\t\\tpoint, intPoint, weight, w2, w3,\\r\\n\\t\\t\\tpa, pb, pc, pd;\\r\\n\\r\\n\\t\\t\\tpoint = ( points.length - 1 ) * scale;\\r\\n\\t\\t\\tintPoint = Math.floor( point );\\r\\n\\t\\t\\tweight = point - intPoint;\\r\\n\\r\\n\\t\\t\\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\\r\\n\\t\\t\\tc[ 1 ] = intPoint;\\r\\n\\t\\t\\tc[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;\\r\\n\\t\\t\\tc[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;\\r\\n\\r\\n\\t\\t\\tpa = points[ c[ 0 ] ];\\r\\n\\t\\t\\tpb = points[ c[ 1 ] ];\\r\\n\\t\\t\\tpc = points[ c[ 2 ] ];\\r\\n\\t\\t\\tpd = points[ c[ 3 ] ];\\r\\n\\r\\n\\t\\t\\tw2 = weight * weight;\\r\\n\\t\\t\\tw3 = weight * w2;\\r\\n\\r\\n\\t\\t\\tv3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );\\r\\n\\t\\t\\tv3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );\\r\\n\\t\\t\\tv3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );\\r\\n\\r\\n\\t\\t\\treturn v3;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tvar interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {\\r\\n\\r\\n\\t\\t\\tvar v0 = ( p2 - p0 ) * 0.5,\\r\\n\\t\\t\\t\\tv1 = ( p3 - p1 ) * 0.5;\\r\\n\\r\\n\\t\\t\\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\treturn function ( delta ) {\\r\\n\\r\\n\\t\\t\\tif ( this.isPlaying === false ) return;\\r\\n\\r\\n\\t\\t\\tthis.currentTime += delta * this.timeScale;\\r\\n\\r\\n\\t\\t\\tif ( this.weight === 0 )\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tvar duration = this.data.length;\\r\\n\\r\\n\\t\\t\\tif ( this.currentTime > duration || this.currentTime < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( this.loop ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.currentTime %= duration;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( this.currentTime < 0 )\\r\\n\\t\\t\\t\\t\\t\\tthis.currentTime += duration;\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.reset();\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.stop();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar object = this.hierarchy[ h ];\\r\\n\\t\\t\\t\\tvar animationCache = object.animationCache.animations[ this.data.name ];\\r\\n\\t\\t\\t\\tvar blending = object.animationCache.blending;\\r\\n\\r\\n\\t\\t\\t\\t// loop through pos/rot/scl\\r\\n\\r\\n\\t\\t\\t\\tfor ( var t = 0; t < 3; t ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// get keys\\r\\n\\r\\n\\t\\t\\t\\t\\tvar type    = this.keyTypes[ t ];\\r\\n\\t\\t\\t\\t\\tvar prevKey = animationCache.prevKey[ type ];\\r\\n\\t\\t\\t\\t\\tvar nextKey = animationCache.nextKey[ type ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||\\r\\n\\t\\t\\t\\t\\t\\t( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tprevKey = this.data.hierarchy[ h ].keys[ 0 ];\\r\\n\\t\\t\\t\\t\\t\\tnextKey = this.getNextKeyWith( type, h, 1 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tprevKey = nextKey;\\r\\n\\t\\t\\t\\t\\t\\t\\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tanimationCache.prevKey[ type ] = prevKey;\\r\\n\\t\\t\\t\\t\\t\\tanimationCache.nextKey[ type ] = nextKey;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tvar scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );\\r\\n\\r\\n\\t\\t\\t\\t\\tvar prevXYZ = prevKey[ type ];\\r\\n\\t\\t\\t\\t\\tvar nextXYZ = nextKey[ type ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( scale < 0 ) scale = 0;\\r\\n\\t\\t\\t\\t\\tif ( scale > 1 ) scale = 1;\\r\\n\\r\\n\\t\\t\\t\\t\\t// interpolate\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( type === \\\"pos\\\" ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tnewVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\\r\\n\\t\\t\\t\\t\\t\\t\\tnewVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\\r\\n\\t\\t\\t\\t\\t\\t\\tnewVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// blend\\r\\n\\t\\t\\t\\t\\t\\t\\tvar proportionalWeight = this.weight / ( this.weight + blending.positionWeight );\\r\\n\\t\\t\\t\\t\\t\\t\\tobject.position.lerp( newVector, proportionalWeight );\\r\\n\\t\\t\\t\\t\\t\\t\\tblending.positionWeight += this.weight;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tpoints[ 0 ] = this.getPrevKeyWith( \\\"pos\\\", h, prevKey.index - 1 )[ \\\"pos\\\" ];\\r\\n\\t\\t\\t\\t\\t\\t\\tpoints[ 1 ] = prevXYZ;\\r\\n\\t\\t\\t\\t\\t\\t\\tpoints[ 2 ] = nextXYZ;\\r\\n\\t\\t\\t\\t\\t\\t\\tpoints[ 3 ] = this.getNextKeyWith( \\\"pos\\\", h, nextKey.index + 1 )[ \\\"pos\\\" ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tscale = scale * 0.33 + 0.33;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar currentPoint = interpolateCatmullRom( points, scale );\\r\\n\\t\\t\\t\\t\\t\\t\\tvar proportionalWeight = this.weight / ( this.weight + blending.positionWeight );\\r\\n\\t\\t\\t\\t\\t\\t\\tblending.positionWeight += this.weight;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t// blend\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar vector = object.position;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;\\r\\n\\t\\t\\t\\t\\t\\t\\tvector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;\\r\\n\\t\\t\\t\\t\\t\\t\\tvector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tvar forwardPoint = interpolateCatmullRom( points, scale * 1.01 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\ttarget.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\ttarget.sub( vector );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\ttarget.y = 0;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\ttarget.normalize();\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tvar angle = Math.atan2( target.x, target.z );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tobject.rotation.set( 0, angle, 0 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else if ( type === \\\"rot\\\" ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tTHREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// Avoid paying the cost of an additional slerp if we don't have to\\r\\n\\t\\t\\t\\t\\t\\tif ( blending.quaternionWeight === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tobject.quaternion.copy( newQuat );\\r\\n\\t\\t\\t\\t\\t\\t\\tblending.quaternionWeight = this.weight;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );\\r\\n\\t\\t\\t\\t\\t\\t\\tTHREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );\\r\\n\\t\\t\\t\\t\\t\\t\\tblending.quaternionWeight += this.weight;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else if ( type === \\\"scl\\\" ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tnewVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\\r\\n\\t\\t\\t\\t\\t\\tnewVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\\r\\n\\t\\t\\t\\t\\t\\tnewVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );\\r\\n\\t\\t\\t\\t\\t\\tobject.scale.lerp( newVector, proportionalWeight );\\r\\n\\t\\t\\t\\t\\t\\tblending.scaleWeight += this.weight;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn true;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t} )(),\\r\\n\\r\\n\\tgetNextKeyWith: function ( type, h, key ) {\\r\\n\\r\\n\\t\\tvar keys = this.data.hierarchy[ h ].keys;\\r\\n\\r\\n\\t\\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\\r\\n\\t\\t\\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\\r\\n\\r\\n\\t\\t\\tkey = key < keys.length - 1 ? key : keys.length - 1;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tkey = key % keys.length;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( ; key < keys.length; key ++ ) {\\r\\n\\r\\n\\t\\t\\tif ( keys[ key ][ type ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\treturn keys[ key ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.data.hierarchy[ h ].keys[ 0 ];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetPrevKeyWith: function ( type, h, key ) {\\r\\n\\r\\n\\t\\tvar keys = this.data.hierarchy[ h ].keys;\\r\\n\\r\\n\\t\\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\\r\\n\\t\\t\\tthis.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\\r\\n\\r\\n\\t\\t\\tkey = key > 0 ? key : 0;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tkey = key >= 0 ? key : key + keys.length;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\tfor ( ; key >= 0; key -- ) {\\r\\n\\r\\n\\t\\t\\tif ( keys[ key ][ type ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\treturn keys[ key ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.data.hierarchy[ h ].keys[ keys.length - 1 ];\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\""
		},
		{
			"name": "AnimationHandler.js",
			"source": "\"/**\\r\\n * @author mikael emtinger / http://gomo.se/\\r\\n */\\r\\n\\r\\nTHREE.AnimationHandler = {\\r\\n\\r\\n\\tLINEAR: 0,\\r\\n\\tCATMULLROM: 1,\\r\\n\\tCATMULLROM_FORWARD: 2,\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tadd: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.AnimationHandler.add() has been deprecated.' );\\r\\n\\r\\n\\t},\\r\\n\\tget: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.AnimationHandler.get() has been deprecated.' );\\r\\n\\r\\n\\t},\\r\\n\\tremove: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.AnimationHandler.remove() has been deprecated.' );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tanimations: [],\\r\\n\\r\\n\\tinit: function ( data ) {\\r\\n\\r\\n\\t\\tif ( data.initialized === true ) return data;\\r\\n\\r\\n\\t\\t// loop through all keys\\r\\n\\r\\n\\t\\tfor ( var h = 0; h < data.hierarchy.length; h ++ ) {\\r\\n\\r\\n\\t\\t\\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t// remove minus times\\r\\n\\r\\n\\t\\t\\t\\tif ( data.hierarchy[ h ].keys[ k ].time < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t data.hierarchy[ h ].keys[ k ].time = 0;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// create quaternions\\r\\n\\r\\n\\t\\t\\t\\tif ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&\\r\\n\\t\\t\\t\\t  ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar quat = data.hierarchy[ h ].keys[ k ].rot;\\r\\n\\t\\t\\t\\t\\tdata.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// prepare morph target keys\\r\\n\\r\\n\\t\\t\\tif ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t// get all used\\r\\n\\r\\n\\t\\t\\t\\tvar usedMorphTargets = {};\\r\\n\\r\\n\\t\\t\\t\\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];\\r\\n\\t\\t\\t\\t\\t\\tusedMorphTargets[ morphTargetName ] = - 1;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tdata.hierarchy[ h ].usedMorphTargets = usedMorphTargets;\\r\\n\\r\\n\\r\\n\\t\\t\\t\\t// set all used on all frames\\r\\n\\r\\n\\t\\t\\t\\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar influences = {};\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var morphTargetName in usedMorphTargets ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tinfluences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tinfluences[ morphTargetName ] = 0;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tdata.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\t// remove all keys that are on the same time\\r\\n\\r\\n\\t\\t\\tfor ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tdata.hierarchy[ h ].keys.splice( k, 1 );\\r\\n\\t\\t\\t\\t\\tk --;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\t// set index\\r\\n\\r\\n\\t\\t\\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tdata.hierarchy[ h ].keys[ k ].index = k;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tdata.initialized = true;\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tparse: function ( root ) {\\r\\n\\r\\n\\t\\tvar parseRecurseHierarchy = function ( root, hierarchy ) {\\r\\n\\r\\n\\t\\t\\thierarchy.push( root );\\r\\n\\r\\n\\t\\t\\tfor ( var c = 0; c < root.children.length; c ++ )\\r\\n\\t\\t\\t\\tparseRecurseHierarchy( root.children[ c ], hierarchy );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t// setup hierarchy\\r\\n\\r\\n\\t\\tvar hierarchy = [];\\r\\n\\r\\n\\t\\tif ( root instanceof THREE.SkinnedMesh ) {\\r\\n\\r\\n\\t\\t\\tfor ( var b = 0; b < root.skeleton.bones.length; b ++ ) {\\r\\n\\r\\n\\t\\t\\t\\thierarchy.push( root.skeleton.bones[ b ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tparseRecurseHierarchy( root, hierarchy );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn hierarchy;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tplay: function ( animation ) {\\r\\n\\r\\n\\t\\tif ( this.animations.indexOf( animation ) === - 1 ) {\\r\\n\\r\\n\\t\\t\\tthis.animations.push( animation );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tstop: function ( animation ) {\\r\\n\\r\\n\\t\\tvar index = this.animations.indexOf( animation );\\r\\n\\r\\n\\t\\tif ( index !== - 1 ) {\\r\\n\\r\\n\\t\\t\\tthis.animations.splice( index, 1 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdate: function ( deltaTimeMS ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < this.animations.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.animations[ i ].resetBlendWeights();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < this.animations.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.animations[ i ].update( deltaTimeMS );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\""
		},
		{
			"name": "KeyFrameAnimation.js",
			"source": "\"/**\\r\\n * @author mikael emtinger / http://gomo.se/\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author khang duong\\r\\n * @author erik kitson\\r\\n */\\r\\n\\r\\nTHREE.KeyFrameAnimation = function ( data ) {\\r\\n\\r\\n\\tthis.root = data.node;\\r\\n\\tthis.data = THREE.AnimationHandler.init( data );\\r\\n\\tthis.hierarchy = THREE.AnimationHandler.parse( this.root );\\r\\n\\tthis.currentTime = 0;\\r\\n\\tthis.timeScale = 0.001;\\r\\n\\tthis.isPlaying = false;\\r\\n\\tthis.isPaused = true;\\r\\n\\tthis.loop = true;\\r\\n\\r\\n\\t// initialize to first keyframes\\r\\n\\r\\n\\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\\r\\n\\r\\n\\t\\tvar keys = this.data.hierarchy[ h ].keys,\\r\\n\\t\\t\\tsids = this.data.hierarchy[ h ].sids,\\r\\n\\t\\t\\tobj = this.hierarchy[ h ];\\r\\n\\r\\n\\t\\tif ( keys.length && sids ) {\\r\\n\\r\\n\\t\\t\\tfor ( var s = 0; s < sids.length; s ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar sid = sids[ s ],\\r\\n\\t\\t\\t\\t\\tnext = this.getNextKeyWith( sid, h, 0 );\\r\\n\\r\\n\\t\\t\\t\\tif ( next ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tnext.apply( sid );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tobj.matrixAutoUpdate = false;\\r\\n\\t\\t\\tthis.data.hierarchy[ h ].node.updateMatrix();\\r\\n\\t\\t\\tobj.matrixWorldNeedsUpdate = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\nTHREE.KeyFrameAnimation.prototype = {\\r\\n\\r\\n\\tconstructor: THREE.KeyFrameAnimation,\\r\\n\\r\\n\\tplay: function ( startTime ) {\\r\\n\\r\\n\\t\\tthis.currentTime = startTime !== undefined ? startTime : 0;\\r\\n\\r\\n\\t\\tif ( this.isPlaying === false ) {\\r\\n\\r\\n\\t\\t\\tthis.isPlaying = true;\\r\\n\\r\\n\\t\\t\\t// reset key cache\\r\\n\\r\\n\\t\\t\\tvar h, hl = this.hierarchy.length,\\r\\n\\t\\t\\t\\tobject,\\r\\n\\t\\t\\t\\tnode;\\r\\n\\r\\n\\t\\t\\tfor ( h = 0; h < hl; h ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tobject = this.hierarchy[ h ];\\r\\n\\t\\t\\t\\tnode = this.data.hierarchy[ h ];\\r\\n\\r\\n\\t\\t\\t\\tif ( node.animationCache === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tnode.animationCache = {};\\r\\n\\t\\t\\t\\t\\tnode.animationCache.prevKey = null;\\r\\n\\t\\t\\t\\t\\tnode.animationCache.nextKey = null;\\r\\n\\t\\t\\t\\t\\tnode.animationCache.originalMatrix = object.matrix;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar keys = this.data.hierarchy[ h ].keys;\\r\\n\\r\\n\\t\\t\\t\\tif ( keys.length > 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tnode.animationCache.prevKey = keys[ 0 ];\\r\\n\\t\\t\\t\\t\\tnode.animationCache.nextKey = keys[ 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.startTime = Math.min( keys[ 0 ].time, this.startTime );\\r\\n\\t\\t\\t\\t\\tthis.endTime = Math.max( keys[ keys.length - 1 ].time, this.endTime );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.update( 0 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.isPaused = false;\\r\\n\\t},\\r\\n\\r\\n\\tstop: function () {\\r\\n\\r\\n\\t\\tthis.isPlaying = false;\\r\\n\\t\\tthis.isPaused  = false;\\r\\n\\r\\n\\t\\t// reset JIT matrix and remove cache\\r\\n\\r\\n\\t\\tfor ( var h = 0; h < this.data.hierarchy.length; h ++ ) {\\r\\n\\r\\n\\t\\t\\tvar obj = this.hierarchy[ h ];\\r\\n\\t\\t\\tvar node = this.data.hierarchy[ h ];\\r\\n\\r\\n\\t\\t\\tif ( node.animationCache !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar original = node.animationCache.originalMatrix;\\r\\n\\r\\n\\t\\t\\t\\toriginal.copy( obj.matrix );\\r\\n\\t\\t\\t\\tobj.matrix = original;\\r\\n\\r\\n\\t\\t\\t\\tdelete node.animationCache;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdate: function ( delta ) {\\r\\n\\r\\n\\t\\tif ( this.isPlaying === false ) return;\\r\\n\\r\\n\\t\\tthis.currentTime += delta * this.timeScale;\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar duration = this.data.length;\\r\\n\\r\\n\\t\\tif ( this.loop === true && this.currentTime > duration ) {\\r\\n\\r\\n\\t\\t\\tthis.currentTime %= duration;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.currentTime = Math.min( this.currentTime, duration );\\r\\n\\r\\n\\t\\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\\r\\n\\r\\n\\t\\t\\tvar object = this.hierarchy[ h ];\\r\\n\\t\\t\\tvar node = this.data.hierarchy[ h ];\\r\\n\\r\\n\\t\\t\\tvar keys = node.keys,\\r\\n\\t\\t\\t\\tanimationCache = node.animationCache;\\r\\n\\r\\n\\r\\n\\t\\t\\tif ( keys.length ) {\\r\\n\\r\\n\\t\\t\\t\\tvar prevKey = animationCache.prevKey;\\r\\n\\t\\t\\t\\tvar nextKey = animationCache.nextKey;\\r\\n\\r\\n\\t\\t\\t\\tif ( nextKey.time <= this.currentTime ) {\\r\\n\\r\\n\\t\\t\\t\\t\\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tprevKey = nextKey;\\r\\n\\t\\t\\t\\t\\t\\tnextKey = keys[ prevKey.index + 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tanimationCache.prevKey = prevKey;\\r\\n\\t\\t\\t\\t\\tanimationCache.nextKey = nextKey;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( nextKey.time >= this.currentTime ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tprevKey.interpolate( nextKey, this.currentTime );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tprevKey.interpolate( nextKey, nextKey.time );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.data.hierarchy[ h ].node.updateMatrix();\\r\\n\\t\\t\\t\\tobject.matrixWorldNeedsUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetNextKeyWith: function ( sid, h, key ) {\\r\\n\\r\\n\\t\\tvar keys = this.data.hierarchy[ h ].keys;\\r\\n\\t\\tkey = key % keys.length;\\r\\n\\r\\n\\t\\tfor ( ; key < keys.length; key ++ ) {\\r\\n\\r\\n\\t\\t\\tif ( keys[ key ].hasTarget( sid ) ) {\\r\\n\\r\\n\\t\\t\\t\\treturn keys[ key ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn keys[ 0 ];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetPrevKeyWith: function ( sid, h, key ) {\\r\\n\\r\\n\\t\\tvar keys = this.data.hierarchy[ h ].keys;\\r\\n\\t\\tkey = key >= 0 ? key : key + keys.length;\\r\\n\\r\\n\\t\\tfor ( ; key >= 0; key -- ) {\\r\\n\\r\\n\\t\\t\\tif ( keys[ key ].hasTarget( sid ) ) {\\r\\n\\r\\n\\t\\t\\t\\treturn keys[ key ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn keys[ keys.length - 1 ];\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\""
		},
		{
			"name": "UVsDebug.js",
			"source": "\"/* \\r\\n * @author zz85 / http://github.com/zz85\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n *\\r\\n * tool for \\\"unwrapping\\\" and debugging three.js \\r\\n * geometries UV mapping\\r\\n *\\r\\n * Sample usage:\\r\\n *\\tdocument.body.appendChild( THREE.UVsDebug( new THREE.SphereGeometry( 10, 10, 10, 10 ) );\\r\\n *\\r\\n */\\r\\n \\r\\nTHREE.UVsDebug = function( geometry, size ) {\\r\\n\\r\\n\\t// handles wrapping of uv.x > 1 only\\r\\n    \\r\\n\\tvar abc = 'abc';\\r\\n\\r\\n\\tvar uv, u, ax, ay;\\r\\n\\tvar i, il, j, jl;\\r\\n\\tvar vnum;\\r\\n\\r\\n\\tvar a = new THREE.Vector2();\\r\\n\\tvar b = new THREE.Vector2();\\r\\n\\r\\n\\tvar geo = ( geometry instanceof THREE.BufferGeometry ) ? new THREE.Geometry().fromBufferGeometry( geometry ) : geometry;\\r\\n\\r\\n\\tvar faces = geo.faces;\\r\\n\\tvar uvs = geo.faceVertexUvs[ 0 ];\\r\\n\\r\\n\\tvar canvas = document.createElement( 'canvas' );\\r\\n\\tvar width = size || 1024;   // power of 2 required for wrapping\\r\\n\\tvar height = size || 1024;\\r\\n\\tcanvas.width = width;\\r\\n\\tcanvas.height = height;\\r\\n\\r\\n\\tvar ctx = canvas.getContext( '2d' );\\r\\n\\tctx.lineWidth = 1;\\r\\n\\tctx.strokeStyle = 'rgba( 0, 0, 0, 1.0 )';\\r\\n\\tctx.textAlign = 'center';\\r\\n\\r\\n\\t// paint background white\\r\\n\\r\\n\\tctx.fillStyle = 'rgba( 255, 255, 255, 1.0 )';\\r\\n\\tctx.fillRect( 0, 0, width, height );\\r\\n\\r\\n\\tfor ( i = 0, il = uvs.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\tuv = uvs[ i ];\\r\\n\\r\\n\\t\\t// draw lines\\r\\n\\r\\n\\t\\tctx.beginPath();\\r\\n\\r\\n\\t\\ta.set( 0, 0 );\\r\\n\\r\\n\\t\\tfor ( j = 0, jl = uv.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\tu = uv[ j ];\\r\\n\\r\\n\\t\\t\\ta.x += u.x;\\r\\n\\t\\t\\ta.y += u.y;\\r\\n\\r\\n\\t\\t\\tif ( j == 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tctx.moveTo( u.x * width, ( 1 - u.y ) * height );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tctx.lineTo( u.x * width, ( 1 - u.y ) * height );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tctx.closePath();\\r\\n\\t\\tctx.stroke();\\r\\n\\r\\n\\t\\ta.divideScalar( jl );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn canvas;\\r\\n\\r\\n};\\r\\n\\r\\n//  disable labels.\\r\\n\\r\\n/*\\r\\n\\t\\t// label the face number\\r\\n\\r\\n\\t\\tctx.font = \\\"12pt Arial bold\\\";\\r\\n\\t\\tctx.fillStyle = 'rgba( 0, 0, 0, 1.0 )';\\r\\n\\t\\tctx.fillText( i, a.x * width, ( 1 - a.y ) * height );\\r\\n\\r\\n\\t\\tif ( a.x > 0.95 ) {\\r\\n\\r\\n\\t\\t\\t// wrap x // 0.95 is arbitrary\\r\\n\\r\\n\\t\\t\\tctx.fillText( i, ( a.x % 1 ) * width, ( 1 - a.y ) * height );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tctx.font = \\\"8pt Arial bold\\\";\\r\\n\\t\\tctx.fillStyle = 'rgba( 0, 0, 0, 1.0 )';\\r\\n\\r\\n\\t\\t// label uv edge orders\\r\\n\\r\\n\\t\\tfor ( j = 0, jl = uv.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\tu = uv[ j ];\\r\\n\\t\\t\\tb.addVectors( a, u ).divideScalar( 2 );\\r\\n\\r\\n\\t\\t\\tvnum = faces[ i ][ abc[ j ] ];\\r\\n\\t\\t\\tctx.fillText( abc[ j ] + vnum, b.x * width, ( 1 - b.y ) * height );\\r\\n\\r\\n\\t\\t\\tif ( b.x > 0.95 ) {\\r\\n\\r\\n\\t\\t\\t\\t// wrap x\\r\\n\\r\\n\\t\\t\\t\\tctx.fillText( abc[ j ] + vnum, ( b.x % 1 ) * width, ( 1 - b.y ) * height );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn canvas;\\r\\n\\r\\n};\\r\\n*/\\r\\n\\r\\n\""
		},
		{
			"name": "SubdivisionModifier.js",
			"source": "\"/*\\r\\n *\\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\\r\\n *\\t@author centerionware / http://www.centerionware.com\\r\\n *\\r\\n *\\tSubdivision Geometry Modifier\\r\\n *\\t\\tusing Loop Subdivision Scheme\\r\\n *\\r\\n *\\tReferences:\\r\\n *\\t\\thttp://graphics.stanford.edu/~mdfisher/subdivision.html\\r\\n *\\t\\thttp://www.holmes3d.net/graphics/subdivision/\\r\\n *\\t\\thttp://www.cs.rutgers.edu/~decarlo/readings/subdiv-sg00c.pdf\\r\\n *\\r\\n *\\tKnown Issues:\\r\\n *\\t\\t- currently doesn't handle \\\"Sharp Edges\\\"\\r\\n */\\r\\n\\r\\nTHREE.SubdivisionModifier = function ( subdivisions ) {\\r\\n\\r\\n\\tthis.subdivisions = ( subdivisions === undefined ) ? 1 : subdivisions;\\r\\n\\r\\n};\\r\\n\\r\\n// Applies the \\\"modify\\\" pattern\\r\\nTHREE.SubdivisionModifier.prototype.modify = function ( geometry ) {\\r\\n\\r\\n\\tvar repeats = this.subdivisions;\\r\\n\\r\\n\\twhile ( repeats -- > 0 ) {\\r\\n\\r\\n\\t\\tthis.smooth( geometry );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tgeometry.computeFaceNormals();\\r\\n\\tgeometry.computeVertexNormals();\\r\\n\\r\\n};\\r\\n\\r\\n( function() {\\r\\n\\r\\n\\t// Some constants\\r\\n\\tvar WARNINGS = ! true; // Set to true for development\\r\\n\\tvar ABC = [ 'a', 'b', 'c' ];\\r\\n\\r\\n\\r\\n\\tfunction getEdge( a, b, map ) {\\r\\n\\r\\n\\t\\tvar vertexIndexA = Math.min( a, b );\\r\\n\\t\\tvar vertexIndexB = Math.max( a, b );\\r\\n\\r\\n\\t\\tvar key = vertexIndexA + \\\"_\\\" + vertexIndexB;\\r\\n\\r\\n\\t\\treturn map[ key ];\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tfunction processEdge( a, b, vertices, map, face, metaVertices ) {\\r\\n\\r\\n\\t\\tvar vertexIndexA = Math.min( a, b );\\r\\n\\t\\tvar vertexIndexB = Math.max( a, b );\\r\\n\\r\\n\\t\\tvar key = vertexIndexA + \\\"_\\\" + vertexIndexB;\\r\\n\\r\\n\\t\\tvar edge;\\r\\n\\r\\n\\t\\tif ( key in map ) {\\r\\n\\r\\n\\t\\t\\tedge = map[ key ];\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tvar vertexA = vertices[ vertexIndexA ];\\r\\n\\t\\t\\tvar vertexB = vertices[ vertexIndexB ];\\r\\n\\r\\n\\t\\t\\tedge = {\\r\\n\\r\\n\\t\\t\\t\\ta: vertexA, // pointer reference\\r\\n\\t\\t\\t\\tb: vertexB,\\r\\n\\t\\t\\t\\tnewEdge: null,\\r\\n\\t\\t\\t\\t// aIndex: a, // numbered reference\\r\\n\\t\\t\\t\\t// bIndex: b,\\r\\n\\t\\t\\t\\tfaces: [] // pointers to face\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\tmap[ key ] = edge;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tedge.faces.push( face );\\r\\n\\r\\n\\t\\tmetaVertices[ a ].edges.push( edge );\\r\\n\\t\\tmetaVertices[ b ].edges.push( edge );\\r\\n\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction generateLookups( vertices, faces, metaVertices, edges ) {\\r\\n\\r\\n\\t\\tvar i, il, face, edge;\\r\\n\\r\\n\\t\\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tmetaVertices[ i ] = { edges: [] };\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tface = faces[ i ];\\r\\n\\r\\n\\t\\t\\tprocessEdge( face.a, face.b, vertices, edges, face, metaVertices );\\r\\n\\t\\t\\tprocessEdge( face.b, face.c, vertices, edges, face, metaVertices );\\r\\n\\t\\t\\tprocessEdge( face.c, face.a, vertices, edges, face, metaVertices );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction newFace( newFaces, a, b, c ) {\\r\\n\\r\\n\\t\\tnewFaces.push( new THREE.Face3( a, b, c ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction midpoint( a, b ) {\\r\\n\\r\\n\\t\\treturn ( Math.abs( b - a ) / 2 ) + Math.min( a, b );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction newUv( newUvs, a, b, c ) {\\r\\n\\r\\n\\t\\tnewUvs.push( [ a.clone(), b.clone(), c.clone() ] );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/////////////////////////////\\r\\n\\r\\n\\t// Performs one iteration of Subdivision\\r\\n\\tTHREE.SubdivisionModifier.prototype.smooth = function ( geometry ) {\\r\\n\\r\\n\\t\\tvar tmp = new THREE.Vector3();\\r\\n\\r\\n\\t\\tvar oldVertices, oldFaces, oldUvs;\\r\\n\\t\\tvar newVertices, newFaces, newUVs = [];\\r\\n\\r\\n\\t\\tvar n, l, i, il, j, k;\\r\\n\\t\\tvar metaVertices, sourceEdges;\\r\\n\\r\\n\\t\\t// new stuff.\\r\\n\\t\\tvar sourceEdges, newEdgeVertices, newSourceVertices;\\r\\n\\r\\n\\t\\toldVertices = geometry.vertices; // { x, y, z}\\r\\n\\t\\toldFaces = geometry.faces; // { a: oldVertex1, b: oldVertex2, c: oldVertex3 }\\r\\n\\t\\toldUvs = geometry.faceVertexUvs[ 0 ];\\r\\n\\r\\n\\t\\tvar hasUvs = oldUvs !== undefined && oldUvs.length > 0;\\r\\n\\r\\n\\t\\t/******************************************************\\r\\n\\t\\t *\\r\\n\\t\\t * Step 0: Preprocess Geometry to Generate edges Lookup\\r\\n\\t\\t *\\r\\n\\t\\t *******************************************************/\\r\\n\\r\\n\\t\\tmetaVertices = new Array( oldVertices.length );\\r\\n\\t\\tsourceEdges = {}; // Edge => { oldVertex1, oldVertex2, faces[]  }\\r\\n\\r\\n\\t\\tgenerateLookups( oldVertices, oldFaces, metaVertices, sourceEdges );\\r\\n\\r\\n\\r\\n\\t\\t/******************************************************\\r\\n\\t\\t *\\r\\n\\t\\t *\\tStep 1.\\r\\n\\t\\t *\\tFor each edge, create a new Edge Vertex,\\r\\n\\t\\t *\\tthen position it.\\r\\n\\t\\t *\\r\\n\\t\\t *******************************************************/\\r\\n\\r\\n\\t\\tnewEdgeVertices = [];\\r\\n\\t\\tvar other, currentEdge, newEdge, face;\\r\\n\\t\\tvar edgeVertexWeight, adjacentVertexWeight, connectedFaces;\\r\\n\\r\\n\\t\\tfor ( i in sourceEdges ) {\\r\\n\\r\\n\\t\\t\\tcurrentEdge = sourceEdges[ i ];\\r\\n\\t\\t\\tnewEdge = new THREE.Vector3();\\r\\n\\r\\n\\t\\t\\tedgeVertexWeight = 3 / 8;\\r\\n\\t\\t\\tadjacentVertexWeight = 1 / 8;\\r\\n\\r\\n\\t\\t\\tconnectedFaces = currentEdge.faces.length;\\r\\n\\r\\n\\t\\t\\t// check how many linked faces. 2 should be correct.\\r\\n\\t\\t\\tif ( connectedFaces != 2 ) {\\r\\n\\r\\n\\t\\t\\t\\t// if length is not 2, handle condition\\r\\n\\t\\t\\t\\tedgeVertexWeight = 0.5;\\r\\n\\t\\t\\t\\tadjacentVertexWeight = 0;\\r\\n\\r\\n\\t\\t\\t\\tif ( connectedFaces != 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( WARNINGS ) console.warn( 'Subdivision Modifier: Number of connected faces != 2, is: ', connectedFaces, currentEdge );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tnewEdge.addVectors( currentEdge.a, currentEdge.b ).multiplyScalar( edgeVertexWeight );\\r\\n\\r\\n\\t\\t\\ttmp.set( 0, 0, 0 );\\r\\n\\r\\n\\t\\t\\tfor ( j = 0; j < connectedFaces; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tface = currentEdge.faces[ j ];\\r\\n\\r\\n\\t\\t\\t\\tfor ( k = 0; k < 3; k ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tother = oldVertices[ face[ ABC[ k ] ] ];\\r\\n\\t\\t\\t\\t\\tif ( other !== currentEdge.a && other !== currentEdge.b ) break;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ttmp.add( other );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\ttmp.multiplyScalar( adjacentVertexWeight );\\r\\n\\t\\t\\tnewEdge.add( tmp );\\r\\n\\r\\n\\t\\t\\tcurrentEdge.newEdge = newEdgeVertices.length;\\r\\n\\t\\t\\tnewEdgeVertices.push( newEdge );\\r\\n\\r\\n\\t\\t\\t// console.log(currentEdge, newEdge);\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/******************************************************\\r\\n\\t\\t *\\r\\n\\t\\t *\\tStep 2.\\r\\n\\t\\t *\\tReposition each source vertices.\\r\\n\\t\\t *\\r\\n\\t\\t *******************************************************/\\r\\n\\r\\n\\t\\tvar beta, sourceVertexWeight, connectingVertexWeight;\\r\\n\\t\\tvar connectingEdge, connectingEdges, oldVertex, newSourceVertex;\\r\\n\\t\\tnewSourceVertices = [];\\r\\n\\r\\n\\t\\tfor ( i = 0, il = oldVertices.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\toldVertex = oldVertices[ i ];\\r\\n\\r\\n\\t\\t\\t// find all connecting edges (using lookupTable)\\r\\n\\t\\t\\tconnectingEdges = metaVertices[ i ].edges;\\r\\n\\t\\t\\tn = connectingEdges.length;\\r\\n\\r\\n\\t\\t\\tif ( n == 3 ) {\\r\\n\\r\\n\\t\\t\\t\\tbeta = 3 / 16;\\r\\n\\r\\n\\t\\t\\t} else if ( n > 3 ) {\\r\\n\\r\\n\\t\\t\\t\\tbeta = 3 / ( 8 * n ); // Warren's modified formula\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Loop's original beta formula\\r\\n\\t\\t\\t// beta = 1 / n * ( 5/8 - Math.pow( 3/8 + 1/4 * Math.cos( 2 * Math. PI / n ), 2) );\\r\\n\\r\\n\\t\\t\\tsourceVertexWeight = 1 - n * beta;\\r\\n\\t\\t\\tconnectingVertexWeight = beta;\\r\\n\\r\\n\\t\\t\\tif ( n <= 2 ) {\\r\\n\\r\\n\\t\\t\\t\\t// crease and boundary rules\\r\\n\\t\\t\\t\\t// console.warn('crease and boundary rules');\\r\\n\\r\\n\\t\\t\\t\\tif ( n == 2 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( WARNINGS ) console.warn( '2 connecting edges', connectingEdges );\\r\\n\\t\\t\\t\\t\\tsourceVertexWeight = 3 / 4;\\r\\n\\t\\t\\t\\t\\tconnectingVertexWeight = 1 / 8;\\r\\n\\r\\n\\t\\t\\t\\t\\t// sourceVertexWeight = 1;\\r\\n\\t\\t\\t\\t\\t// connectingVertexWeight = 0;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( n == 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( WARNINGS ) console.warn( 'only 1 connecting edge' );\\r\\n\\r\\n\\t\\t\\t\\t} else if ( n == 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( WARNINGS ) console.warn( '0 connecting edges' );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tnewSourceVertex = oldVertex.clone().multiplyScalar( sourceVertexWeight );\\r\\n\\r\\n\\t\\t\\ttmp.set( 0, 0, 0 );\\r\\n\\r\\n\\t\\t\\tfor ( j = 0; j < n; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tconnectingEdge = connectingEdges[ j ];\\r\\n\\t\\t\\t\\tother = connectingEdge.a !== oldVertex ? connectingEdge.a : connectingEdge.b;\\r\\n\\t\\t\\t\\ttmp.add( other );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\ttmp.multiplyScalar( connectingVertexWeight );\\r\\n\\t\\t\\tnewSourceVertex.add( tmp );\\r\\n\\r\\n\\t\\t\\tnewSourceVertices.push( newSourceVertex );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t/******************************************************\\r\\n\\t\\t *\\r\\n\\t\\t *\\tStep 3.\\r\\n\\t\\t *\\tGenerate Faces between source vertices\\r\\n\\t\\t *\\tand edge vertices.\\r\\n\\t\\t *\\r\\n\\t\\t *******************************************************/\\r\\n\\r\\n\\t\\tnewVertices = newSourceVertices.concat( newEdgeVertices );\\r\\n\\t\\tvar sl = newSourceVertices.length, edge1, edge2, edge3;\\r\\n\\t\\tnewFaces = [];\\r\\n\\r\\n\\t\\tvar uv, x0, x1, x2;\\r\\n\\t\\tvar x3 = new THREE.Vector2();\\r\\n\\t\\tvar x4 = new THREE.Vector2();\\r\\n\\t\\tvar x5 = new THREE.Vector2();\\r\\n\\r\\n\\t\\tfor ( i = 0, il = oldFaces.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tface = oldFaces[ i ];\\r\\n\\r\\n\\t\\t\\t// find the 3 new edges vertex of each old face\\r\\n\\r\\n\\t\\t\\tedge1 = getEdge( face.a, face.b, sourceEdges ).newEdge + sl;\\r\\n\\t\\t\\tedge2 = getEdge( face.b, face.c, sourceEdges ).newEdge + sl;\\r\\n\\t\\t\\tedge3 = getEdge( face.c, face.a, sourceEdges ).newEdge + sl;\\r\\n\\r\\n\\t\\t\\t// create 4 faces.\\r\\n\\r\\n\\t\\t\\tnewFace( newFaces, edge1, edge2, edge3 );\\r\\n\\t\\t\\tnewFace( newFaces, face.a, edge1, edge3 );\\r\\n\\t\\t\\tnewFace( newFaces, face.b, edge2, edge1 );\\r\\n\\t\\t\\tnewFace( newFaces, face.c, edge3, edge2 );\\r\\n\\r\\n\\t\\t\\t// create 4 new uv's\\r\\n\\r\\n\\t\\t\\tif ( hasUvs ) {\\r\\n\\r\\n\\t\\t\\t\\tuv = oldUvs[ i ];\\r\\n\\r\\n\\t\\t\\t\\tx0 = uv[ 0 ];\\r\\n\\t\\t\\t\\tx1 = uv[ 1 ];\\r\\n\\t\\t\\t\\tx2 = uv[ 2 ];\\r\\n\\r\\n\\t\\t\\t\\tx3.set( midpoint( x0.x, x1.x ), midpoint( x0.y, x1.y ) );\\r\\n\\t\\t\\t\\tx4.set( midpoint( x1.x, x2.x ), midpoint( x1.y, x2.y ) );\\r\\n\\t\\t\\t\\tx5.set( midpoint( x0.x, x2.x ), midpoint( x0.y, x2.y ) );\\r\\n\\r\\n\\t\\t\\t\\tnewUv( newUVs, x3, x4, x5 );\\r\\n\\t\\t\\t\\tnewUv( newUVs, x0, x3, x5 );\\r\\n\\r\\n\\t\\t\\t\\tnewUv( newUVs, x1, x4, x3 );\\r\\n\\t\\t\\t\\tnewUv( newUVs, x2, x5, x4 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Overwrite old arrays\\r\\n\\t\\tgeometry.vertices = newVertices;\\r\\n\\t\\tgeometry.faces = newFaces;\\r\\n\\t\\tif ( hasUvs ) geometry.faceVertexUvs[ 0 ] = newUVs;\\r\\n\\r\\n\\t\\t// console.log('done');\\r\\n\\r\\n\\t};\\r\\n\\r\\n} )();\\r\\n\""
		},
		{
			"name": "MW.js",
			"source": "\"// MW.js\\r\\n\\r\\n/*!\\r\\n* @author yomotsu http://yomotsu.net/\\r\\n* MIT License\\r\\n*/\\r\\n\\r\\nMW = {};\\r\\n\\r\\n\\r\\nMW.triangle = {};\\r\\n\\r\\n\\r\\nMW.triangle.makeBoundingBox = function ( triangle ) {\\r\\n\\r\\n  var bb = new THREE.Box3();\\r\\n\\r\\n  bb.min = bb.min.min( triangle.a );\\r\\n  bb.min = bb.min.min( triangle.b );\\r\\n  bb.min = bb.min.min( triangle.c );\\r\\n\\r\\n  bb.max = bb.max.max( triangle.a );\\r\\n  bb.max = bb.max.max( triangle.b );\\r\\n  bb.max = bb.max.max( triangle.c );\\r\\n\\r\\n  return bb;\\r\\n\\r\\n};\\r\\n\\r\\nMW.triangle.makeBoundingSphere = function ( triangle, normal ) {\\r\\n \\r\\n  var bs = new THREE.Sphere(),\\r\\n      v = new THREE.Vector3(),\\r\\n      v0 = new THREE.Vector3(),\\r\\n      v1 = new THREE.Vector3(),\\r\\n      e0 = new THREE.Vector3(),\\r\\n      e1 = new THREE.Vector3(),\\r\\n      a, b, c, d, e,\\r\\n      div, t, s;\\r\\n \\r\\n  // obtuse triangle\\r\\n \\r\\n  v0.subVectors( triangle.b, triangle.a );\\r\\n  v1.subVectors( triangle.c, triangle.a );\\r\\n \\r\\n  if ( v0.dot( v1 ) <= 0 ) {\\r\\n \\r\\n    bs.center.addVectors( triangle.b, triangle.c ).divideScalar( 2 );\\r\\n    bs.radius = v.subVectors( triangle.b, triangle.c ).length() / 2;\\r\\n    return bs;\\r\\n \\r\\n  }\\r\\n \\r\\n  v0.subVectors( triangle.a, triangle.b );\\r\\n  v1.subVectors( triangle.c, triangle.b );\\r\\n \\r\\n  if ( v0.dot( v1 ) <= 0 ) {\\r\\n \\r\\n    bs.center.addVectors( triangle.a, triangle.c ).divideScalar( 2 );\\r\\n    bs.radius = v.subVectors( triangle.a, triangle.c ).length() / 2;\\r\\n    return bs;\\r\\n \\r\\n  }\\r\\n \\r\\n  v0.subVectors( triangle.a, triangle.c );\\r\\n  v1.subVectors( triangle.b, triangle.c );\\r\\n \\r\\n  if ( v0.dot( v1 ) <= 0 ) {\\r\\n \\r\\n    bs.center.addVectors( triangle.a, triangle.b ).divideScalar( 2 );\\r\\n    bs.radius = v.subVectors( triangle.a, triangle.b ).length() / 2;\\r\\n    return bs;\\r\\n \\r\\n  }\\r\\n \\r\\n  // acute‐angled triangle\\r\\n \\r\\n  if ( !normal ) {\\r\\n \\r\\n    normal = triangle.normal();\\r\\n \\r\\n  }\\r\\n \\r\\n  v0.crossVectors( v.subVectors( triangle.c, triangle.b ), normal );\\r\\n  v1.crossVectors( v.subVectors( triangle.c, triangle.a ), normal );\\r\\n \\r\\n  e0.addVectors( triangle.c, triangle.b ).multiplyScalar( .5 );\\r\\n  e1.addVectors( triangle.c, triangle.a ).multiplyScalar( .5 );\\r\\n \\r\\n  a = v0.dot( v1 );\\r\\n  b = v0.dot( v0 );\\r\\n  d = v1.dot( v1 );\\r\\n  c = -v.subVectors( e1, e0 ).dot( v0 );\\r\\n  e = -v.subVectors( e1, e0 ).dot( v1 );\\r\\n \\r\\n  div = - a * a + b * d;\\r\\n  // t = ( - a * c + b * e ) / div;\\r\\n  s = ( - c * d + a * e ) / div;\\r\\n \\r\\n  bs.center = e0.clone().add( v0.clone().multiplyScalar( s ) );\\r\\n  bs.radius = v.subVectors( bs.center, triangle.a ).length();\\r\\n  return bs;\\r\\n \\r\\n}\\r\\n\\r\\n// @author yomotsu\\r\\n// MIT License\\r\\n\\r\\n;( function ( THREE, ns ) {\\r\\n\\r\\n  'use strict';\\r\\n\\r\\n  ns.collision = {};\\r\\n\\r\\n  // aabb: <THREE.Box3>\\r\\n  // Plane: <THREE.Plane>\\r\\n  ns.collision.isIntersectionAABBPlane = function ( aabb, Plane ) {\\r\\n\\r\\n    var center = new THREE.Vector3().addVectors( aabb.max, aabb.min ).multiplyScalar( 0.5 ),\\r\\n        extents = new THREE.Vector3().subVectors( aabb.max, center );\\r\\n\\r\\n    var r = extents.x * Math.abs( Plane.normal.x ) + extents.y * Math.abs( Plane.normal.y ) + extents.z * Math.abs( Plane.normal.z );\\r\\n    var s = Plane.normal.dot( center ) - Plane.constant;\\r\\n\\r\\n    return Math.abs( s ) <= r;\\r\\n\\r\\n  };\\r\\n\\r\\n  // based on http://www.gamedev.net/topic/534655-aabb-triangleplane-intersection--distance-to-plane-is-incorrect-i-have-solved-it/\\r\\n  //\\r\\n  // a: <THREE.Vector3>, // vertex of a triangle\\r\\n  // b: <THREE.Vector3>, // vertex of a triangle\\r\\n  // c: <THREE.Vector3>, // vertex of a triangle\\r\\n  // aabb: <THREE.Box3>\\r\\n  ns.collision.isIntersectionTriangleAABB = function ( a, b, c, aabb ) {\\r\\n\\r\\n    var p0, p1, p2, r;\\r\\n    \\r\\n    // Compute box center and extents of AABoundingBox (if not already given in that format)\\r\\n    var center = new THREE.Vector3().addVectors( aabb.max, aabb.min ).multiplyScalar( 0.5 ),\\r\\n        extents = new THREE.Vector3().subVectors( aabb.max, center );\\r\\n\\r\\n    // Translate triangle as conceptually moving AABB to origin\\r\\n    var v0 = new THREE.Vector3().subVectors( a, center ),\\r\\n        v1 = new THREE.Vector3().subVectors( b, center ),\\r\\n        v2 = new THREE.Vector3().subVectors( c, center );\\r\\n\\r\\n    // Compute edge vectors for triangle\\r\\n    var f0 = new THREE.Vector3().subVectors( v1, v0 ),\\r\\n        f1 = new THREE.Vector3().subVectors( v2, v1 ),\\r\\n        f2 = new THREE.Vector3().subVectors( v0, v2 );\\r\\n\\r\\n    // Test axes a00..a22 (category 3)\\r\\n    var a00 = new THREE.Vector3( 0, -f0.z, f0.y ),\\r\\n        a01 = new THREE.Vector3( 0, -f1.z, f1.y ),\\r\\n        a02 = new THREE.Vector3( 0, -f2.z, f2.y ),\\r\\n        a10 = new THREE.Vector3( f0.z, 0, -f0.x ),\\r\\n        a11 = new THREE.Vector3( f1.z, 0, -f1.x ),\\r\\n        a12 = new THREE.Vector3( f2.z, 0, -f2.x ),\\r\\n        a20 = new THREE.Vector3( -f0.y, f0.x, 0 ),\\r\\n        a21 = new THREE.Vector3( -f1.y, f1.x, 0 ),\\r\\n        a22 = new THREE.Vector3( -f2.y, f2.x, 0 );\\r\\n\\r\\n    // Test axis a00\\r\\n    p0 = v0.dot( a00 );\\r\\n    p1 = v1.dot( a00 );\\r\\n    p2 = v2.dot( a00 );\\r\\n    r = extents.y * Math.abs( f0.z ) + extents.z * Math.abs( f0.y );\\r\\n\\r\\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\\r\\n\\r\\n      return false; // Axis is a separating axis\\r\\n\\r\\n    }\\r\\n\\r\\n    // Test axis a01\\r\\n    p0 = v0.dot( a01 );\\r\\n    p1 = v1.dot( a01 );\\r\\n    p2 = v2.dot( a01 );\\r\\n    r = extents.y * Math.abs( f1.z ) + extents.z * Math.abs( f1.y );\\r\\n\\r\\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\\r\\n\\r\\n      return false; // Axis is a separating axis\\r\\n\\r\\n    }\\r\\n\\r\\n    // Test axis a02\\r\\n    p0 = v0.dot( a02 );\\r\\n    p1 = v1.dot( a02 );\\r\\n    p2 = v2.dot( a02 );\\r\\n    r = extents.y * Math.abs( f2.z ) + extents.z * Math.abs( f2.y );\\r\\n\\r\\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\\r\\n\\r\\n      return false; // Axis is a separating axis\\r\\n\\r\\n    }\\r\\n\\r\\n    // Test axis a10\\r\\n    p0 = v0.dot( a10 );\\r\\n    p1 = v1.dot( a10 );\\r\\n    p2 = v2.dot( a10 );\\r\\n    r = extents.x * Math.abs( f0.z ) + extents.z * Math.abs( f0.x );\\r\\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\\r\\n\\r\\n      return false; // Axis is a separating axis\\r\\n\\r\\n    }\\r\\n\\r\\n    // Test axis a11\\r\\n    p0 = v0.dot( a11 );\\r\\n    p1 = v1.dot( a11 );\\r\\n    p2 = v2.dot( a11 );\\r\\n    r = extents.x * Math.abs( f1.z ) + extents.z * Math.abs( f1.x );\\r\\n\\r\\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\\r\\n\\r\\n      return false; // Axis is a separating axis\\r\\n\\r\\n    }\\r\\n\\r\\n    // Test axis a12\\r\\n    p0 = v0.dot( a12 );\\r\\n    p1 = v1.dot( a12 );\\r\\n    p2 = v2.dot( a12 );\\r\\n    r = extents.x * Math.abs( f2.z ) + extents.z * Math.abs( f2.x );\\r\\n\\r\\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\\r\\n\\r\\n      return false; // Axis is a separating axis\\r\\n\\r\\n    }\\r\\n\\r\\n    // Test axis a20\\r\\n    p0 = v0.dot( a20 );\\r\\n    p1 = v1.dot( a20 );\\r\\n    p2 = v2.dot( a20 );\\r\\n    r = extents.x * Math.abs( f0.y ) + extents.y * Math.abs( f0.x );\\r\\n\\r\\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\\r\\n\\r\\n      return false; // Axis is a separating axis\\r\\n\\r\\n    }\\r\\n\\r\\n    // Test axis a21\\r\\n    p0 = v0.dot( a21 );\\r\\n    p1 = v1.dot( a21 );\\r\\n    p2 = v2.dot( a21 );\\r\\n    r = extents.x * Math.abs( f1.y ) + extents.y * Math.abs( f1.x );\\r\\n\\r\\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\\r\\n\\r\\n      return false; // Axis is a separating axis\\r\\n\\r\\n    }\\r\\n\\r\\n    // Test axis a22\\r\\n    p0 = v0.dot( a22 );\\r\\n    p1 = v1.dot( a22 );\\r\\n    p2 = v2.dot( a22 );\\r\\n    r = extents.x * Math.abs( f2.y ) + extents.y * Math.abs( f2.x );\\r\\n\\r\\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\\r\\n\\r\\n      return false; // Axis is a separating axis\\r\\n\\r\\n    }\\r\\n\\r\\n    // Test the three axes corresponding to the face normals of AABB b (category 1).\\r\\n    // Exit if...\\r\\n    // ... [-extents.x, extents.x] and [min(v0.x,v1.x,v2.x), max(v0.x,v1.x,v2.x)] do not overlap\\r\\n    if ( Math.max( v0.x, v1.x, v2.x ) < -extents.x || Math.min( v0.x, v1.x, v2.x ) > extents.x ) {\\r\\n\\r\\n      return false;\\r\\n\\r\\n    }\\r\\n    // ... [-extents.y, extents.y] and [min(v0.y,v1.y,v2.y), max(v0.y,v1.y,v2.y)] do not overlap\\r\\n    if ( Math.max( v0.y, v1.y, v2.y ) < -extents.y || Math.min( v0.y, v1.y, v2.y ) > extents.y ) {\\r\\n\\r\\n      return false;\\r\\n\\r\\n    }\\r\\n    // ... [-extents.z, extents.z] and [min(v0.z,v1.z,v2.z), max(v0.z,v1.z,v2.z)] do not overlap\\r\\n    if ( Math.max( v0.z, v1.z, v2.z ) < -extents.z || Math.min( v0.z, v1.z, v2.z ) > extents.z ) {\\r\\n\\r\\n      return false;\\r\\n\\r\\n    }\\r\\n\\r\\n    // Test separating axis corresponding to triangle face normal (category 2)\\r\\n    // Face Normal is -ve as Triangle is clockwise winding (and XNA uses -z for into screen)\\r\\n    var plane = new THREE.Plane();\\r\\n    plane.normal = new THREE.Vector3().copy( f1 ).cross( f0 ).normalize();\\r\\n    plane.constant = plane.normal.dot( a );\\r\\n    \\r\\n    return ns.collision.isIntersectionAABBPlane( aabb, plane );\\r\\n\\r\\n  };\\r\\n\\r\\n\\r\\n  // sphere1: <THREE.Sphere>\\r\\n  // sphere2: <THREE.Sphere>\\r\\n  ns.collision.isIntersectionSphereSphere = function ( sphere1, sphere2 ) {\\r\\n\\r\\n    var radiusSum = sphere1.radius + sphere2.radius;\\r\\n\\r\\n    return sphere1.center.distanceToSquared( sphere2.center ) <= ( radiusSum * radiusSum );\\r\\n\\r\\n  };\\r\\n\\r\\n  // Section 5.1.3\\r\\n  // sphere: <THREE.Sphere>\\r\\n  // aabb: <THREE.Box3>\\r\\n\\r\\n  ns.collision.isIntersectionSphereAABB = function ( sphere, aabb ) {\\r\\n\\r\\n    var sqDist = 0;\\r\\n\\r\\n    if ( sphere.center.x < aabb.min.x ) { sqDist += ( aabb.min.x - sphere.center.x ) * ( aabb.min.x - sphere.center.x ); }\\r\\n    if ( sphere.center.x > aabb.max.x ) { sqDist += ( sphere.center.x - aabb.max.x ) * ( sphere.center.x - aabb.max.x ); }\\r\\n\\r\\n    if ( sphere.center.y < aabb.min.y ) { sqDist += ( aabb.min.y - sphere.center.y ) * ( aabb.min.y - sphere.center.y ); }\\r\\n    if ( sphere.center.y > aabb.max.y ) { sqDist += ( sphere.center.y - aabb.max.y ) * ( sphere.center.y - aabb.max.y ); }\\r\\n\\r\\n    if ( sphere.center.z < aabb.min.z ) { sqDist += ( aabb.min.z - sphere.center.z ) * ( aabb.min.z - sphere.center.z ); }\\r\\n    if ( sphere.center.z > aabb.max.z ) { sqDist += ( sphere.center.z - aabb.max.z ) * ( sphere.center.z - aabb.max.z ); }\\r\\n\\r\\n    return sqDist <= sphere.radius * sphere.radius;\\r\\n\\r\\n  };\\r\\n\\r\\n\\r\\n  //http://clb.demon.fi/MathGeoLib/docs/Triangle.cpp_code.html#459\\r\\n\\r\\n  // sphere: <THREE.Sphere>\\r\\n  // a: <THREE.Vector3>, // vertex of a triangle\\r\\n  // b: <THREE.Vector3>, // vertex of a triangle\\r\\n  // c: <THREE.Vector3>, // vertex of a triangle\\r\\n  // normal: <THREE.Vector3>, // normal of a triangle\\r\\n  ns.collision.isIntersectionSphereTriangle = function ( sphere, a, b, c, normal ) {\\r\\n    // http://realtimecollisiondetection.net/blog/?p=103\\r\\n\\r\\n    // vs plain of traiangle face\\r\\n    var A = new THREE.Vector3(),\\r\\n        B = new THREE.Vector3(),\\r\\n        C = new THREE.Vector3(),\\r\\n        rr,\\r\\n        V = new THREE.Vector3(),\\r\\n        d,\\r\\n        e;\\r\\n\\r\\n    A.subVectors( a, sphere.center );\\r\\n    B.subVectors( b, sphere.center );\\r\\n    C.subVectors( c, sphere.center );\\r\\n    rr = sphere.radius * sphere.radius;\\r\\n    V.crossVectors( B.clone().sub( A ), C.clone().sub( A ) );\\r\\n    d = A.dot( V );\\r\\n    e = V.dot( V );\\r\\n\\r\\n    if ( d * d > rr * e ) {\\r\\n\\r\\n      return false;\\r\\n\\r\\n    }\\r\\n\\r\\n    // vs triangle vertex\\r\\n    var aa,\\r\\n        ab,\\r\\n        ac,\\r\\n        bb,\\r\\n        bc,\\r\\n        cc;\\r\\n\\r\\n    aa = A.dot( A );\\r\\n    ab = A.dot( B );\\r\\n    ac = A.dot( C );\\r\\n    bb = B.dot( B );\\r\\n    bc = B.dot( C );\\r\\n    cc = C.dot( C );\\r\\n\\r\\n    if (\\r\\n      ( aa > rr ) & ( ab > aa ) & ( ac > aa ) ||\\r\\n      ( bb > rr ) & ( ab > bb ) & ( bc > bb ) ||\\r\\n      ( cc > rr ) & ( ac > cc ) & ( bc > cc )\\r\\n    ) {\\r\\n\\r\\n      return false;\\r\\n\\r\\n    }\\r\\n\\r\\n    // vs edge\\r\\n    var AB = new THREE.Vector3(),\\r\\n        BC = new THREE.Vector3(),\\r\\n        CA = new THREE.Vector3(),\\r\\n        d1,\\r\\n        d2,\\r\\n        d3,\\r\\n        e1,\\r\\n        e2,\\r\\n        e3,\\r\\n        Q1 = new THREE.Vector3(),\\r\\n        Q2 = new THREE.Vector3(),\\r\\n        Q3 = new THREE.Vector3(),\\r\\n        QC = new THREE.Vector3(),\\r\\n        QA = new THREE.Vector3(),\\r\\n        QB = new THREE.Vector3();\\r\\n\\r\\n    AB.subVectors( B, A );\\r\\n    BC.subVectors( C, B );\\r\\n    CA.subVectors( A, C );\\r\\n    d1 = ab - aa;\\r\\n    d2 = bc - bb;\\r\\n    d3 = ac - cc;\\r\\n    e1 = AB.dot( AB );\\r\\n    e2 = BC.dot( BC );\\r\\n    e3 = CA.dot( CA );\\r\\n    Q1.subVectors( A.multiplyScalar( e1 ), AB.multiplyScalar( d1 ) );\\r\\n    Q2.subVectors( B.multiplyScalar( e2 ), BC.multiplyScalar( d2 ) );\\r\\n    Q3.subVectors( C.multiplyScalar( e3 ), CA.multiplyScalar( d3 ) );\\r\\n    QC.subVectors( C.multiplyScalar( e1 ), Q1 );\\r\\n    QA.subVectors( A.multiplyScalar( e2 ), Q2 );\\r\\n    QB.subVectors( B.multiplyScalar( e3 ), Q3 );\\r\\n\\r\\n    if (\\r\\n      ( Q1.dot( Q1 ) > rr * e1 * e1 ) && ( Q1.dot( QC ) >= 0 ) ||\\r\\n      ( Q2.dot( Q2 ) > rr * e2 * e2 ) && ( Q2.dot( QA ) >= 0 ) ||\\r\\n      ( Q3.dot( Q3 ) > rr * e3 * e3 ) && ( Q3.dot( QB ) >= 0 )\\r\\n    ) {\\r\\n\\r\\n      return false;\\r\\n\\r\\n    }\\r\\n\\r\\n    var distance = Math.sqrt( d * d / e ) - sphere.radius - 1,\\r\\n        contactPoint = new THREE.Vector3(),\\r\\n        negatedNormal = new THREE.Vector3( -normal.x, -normal.y, -normal.z );\\r\\n\\r\\n    contactPoint.copy( sphere.center ).add( negatedNormal.multiplyScalar( distance ) );\\r\\n\\r\\n    return {\\r\\n      distance    : distance,\\r\\n      contactPoint: contactPoint\\r\\n    };\\r\\n\\r\\n  };\\r\\n\\r\\n  // based on Real-Time Collision Detection Section 5.3.4\\r\\n  // p: <THREE.Vector3>, // line3.start\\r\\n  // q: <THREE.Vector3>, // line3.end\\r\\n  // a: <THREE.Vector3>, // triangle.a\\r\\n  // b: <THREE.Vector3>, // triangle.b\\r\\n  // c: <THREE.Vector3>, // triangle.c\\r\\n  // normal: <THREE.Vector3>, // triangle.normal, optional\\r\\n\\r\\n  // var scalarTriple = function ( a, b, c ) {\\r\\n\\r\\n  //   var m = b.clone().cross( c );\\r\\n  //   return a.dot( m );\\r\\n\\r\\n  // }\\r\\n\\r\\n  // var vectorTriple = function ( a, b, c ) {\\r\\n\\r\\n  //   var m = b.clone().cross( c );\\r\\n  //   return a.clone().cross( m );\\r\\n\\r\\n  // }\\r\\n\\r\\n  // ns.collision.isIntersectionLineTriangle = function ( p, q, a, b, c, precision ) {\\r\\n\\r\\n  //   var pq = q.clone().sub( p ),\\r\\n  //       pa = a.clone().sub( p ),\\r\\n  //       pb = b.clone().sub( p ),\\r\\n  //       pc = c.clone().sub( p ),\\r\\n  //       u, v, w;\\r\\n\\r\\n  //   u = scalarTriple( pq, pc, pb );\\r\\n\\r\\n  //   if ( u < 0 ) { return false; }\\r\\n\\r\\n  //   v = scalarTriple( pq, pa, pc );\\r\\n\\r\\n  //   if ( v < 0 ) { return false; }\\r\\n\\r\\n  //   w = scalarTriple( pq, pb, pa );\\r\\n\\r\\n  //   if ( w < 0 ) { return false; }\\r\\n\\r\\n  //   var denom = 1 / ( u + v + w );\\r\\n  //   u *= denom;\\r\\n  //   v *= denom;\\r\\n  //   w *= denom;\\r\\n\\r\\n  //   var au = a.clone().multiplyScalar( u ),\\r\\n  //       bv = b.clone().multiplyScalar( v ),\\r\\n  //       cw = c.clone().multiplyScalar( w ),\\r\\n  //       contactPoint = au.clone().add( bv ).add( cw );\\r\\n\\r\\n  //   return {\\r\\n  //     contactPoint: contactPoint\\r\\n  //   }\\r\\n\\r\\n  // }\\r\\n\\r\\n  ns.collision.testSegmentTriangle = function ( p, q, a, b, c ) {\\r\\n\\r\\n    var ab = b.clone().sub( a );\\r\\n    var ac = c.clone().sub( a );\\r\\n    var qp = p.clone().sub( q );\\r\\n\\r\\n    var n = ab.clone().cross( ac );\\r\\n\\r\\n    var d = qp.dot( n );\\r\\n    if ( d <= 0 ) { return false; }\\r\\n\\r\\n    var ap = p.clone().sub( a );\\r\\n    var t = ap.dot( n );\\r\\n\\r\\n    if ( t < 0 ) { return 0; }\\r\\n    if ( t > d ) { return 0; }\\r\\n\\r\\n    var e = qp.clone().cross( ap );\\r\\n    var v = ac.dot( e );\\r\\n\\r\\n    if ( v < 0 || v > d ) { return 0; }\\r\\n\\r\\n    var w = ab.clone().dot( e ) * -1;\\r\\n\\r\\n    if ( w < 0 || v + w > d ) { return 0; }\\r\\n\\r\\n    var ood = 1 / d;\\r\\n    t *= ood;\\r\\n    v *= ood;\\r\\n    w *= ood;\\r\\n    var u = 1 - v - w;\\r\\n\\r\\n    var au = a.clone().multiplyScalar( u ),\\r\\n        bv = b.clone().multiplyScalar( v ),\\r\\n        cw = c.clone().multiplyScalar( w ),\\r\\n        contactPoint = au.clone().add( bv ).add( cw );\\r\\n\\r\\n    return {\\r\\n      contactPoint: contactPoint\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n} )( THREE, MW );\\r\\n\\r\\n\\r\\n// @author yomotsu\\r\\n// MIT License\\r\\n\\r\\n;( function ( THREE, ns ) {\\r\\n\\r\\n  'use strict';\\r\\n\\r\\n  ns.World = function () {\\r\\n\\r\\n    // console.log( 'THREEFIELD.World' );\\r\\n\\r\\n    this.colliderPool  = [];\\r\\n    this.characterPool = [];\\r\\n\\r\\n  };\\r\\n\\r\\n  ns.World.prototype.add = function ( object ) {\\r\\n    \\r\\n    if ( object instanceof ns.Octree ) {\\r\\n\\r\\n      this.colliderPool.push( object );\\r\\n\\r\\n    } else if ( object instanceof ns.CharacterController ) {\\r\\n\\r\\n      this.characterPool.push( object );\\r\\n      object.world = this;\\r\\n\\r\\n    }\\r\\n\\r\\n  };\\r\\n\\r\\n  ns.World.prototype.step = function ( dt ) {\\r\\n\\r\\n    var character,\\r\\n        octree,\\r\\n        sphere,\\r\\n        intersectedNodes,\\r\\n        faces,\\r\\n        contactInfo,\\r\\n        i, ii, iii, l, ll, lll;\\r\\n\\r\\n    for ( i = 0, l = this.characterPool.length; i < l; i ++ ) {\\r\\n\\r\\n      character = this.characterPool[ i ];\\r\\n\\r\\n      // octree で絞られた node に含まれる face だけを\\r\\n      // charactore に渡して判定する\\r\\n      for ( ii = 0, ll = this.colliderPool.length; ii < ll; ii ++ ) {\\r\\n\\r\\n        octree = this.colliderPool[ ii ];\\r\\n        sphere = new THREE.Sphere( character.center, character.radius + character.groundPadding );\\r\\n        intersectedNodes = octree.getIntersectedNodes( sphere, octree.maxDepth );\\r\\n        faces = ns.Octree.uniqTriangkesfromNodes( intersectedNodes );\\r\\n\\r\\n      }\\r\\n      \\r\\n      character.collisionCandidate = faces;\\r\\n      character.update( dt );\\r\\n\\r\\n    }\\r\\n\\r\\n  };\\r\\n\\r\\n} )( THREE, MW );\\r\\n\\r\\n// @author yomotsu\\r\\n// MIT License\\r\\n\\r\\n// OcTree with Morton Order\\r\\n// based on http://marupeke296.com/COL_3D_No15_Octree.html\\r\\n//\\r\\n//       +------+------+\\r\\n//       |\\\\   2  \\\\   3  \\\\\\r\\n//       | +------+------+\\r\\n//       + |\\\\      \\\\      \\\\\\r\\n//       |\\\\| +------+------+\\r\\n//       | + |      |      |\\r\\n//       +0|\\\\|   6  |   7  |\\r\\n//        \\\\| +------+------+\\r\\n//         + |      |      |\\r\\n//    y     \\\\|   4  |   5  |\\r\\n//    |      +------+------+\\r\\n//    +--x\\r\\n//     \\\\\\r\\n//      z\\r\\n//\\r\\n//\\r\\n//       +------+------+\\r\\n//       |\\\\   6  \\\\   7  \\\\\\r\\n//       | +------+------+\\r\\n//       + |\\\\      \\\\      \\\\\\r\\n//       |\\\\| +------+------+\\r\\n//       | + |      |      |\\r\\n//       +4|\\\\|   2  |   3  |\\r\\n//        \\\\| +------+------+\\r\\n//         + |      |      |\\r\\n//  z y     \\\\|   0  |   1  |\\r\\n//   \\\\|      +------+------+\\r\\n//    +--x\\r\\n//\\r\\n\\r\\n;( function ( THREE, ns ) {\\r\\n\\r\\n  'use strict';\\r\\n\\r\\n  // min: <THREE.Vector3>\\r\\n  // max: <THREE.Vector3>\\r\\n  // maxDepth: <Number>\\r\\n  ns.Octree = function ( min, max, maxDepth ) {\\r\\n\\r\\n    this.min = min;\\r\\n    this.max = max;\\r\\n    this.maxDepth = maxDepth;\\r\\n    this.nodes = [];\\r\\n\\r\\n    var i, length, depth, mortonNumber,\\r\\n        pow2, pow4,\\r\\n        indexX, indexY, indexZ,\\r\\n        nodeBoxSize = new THREE.Vector3(),\\r\\n        nodeBoxMin = new THREE.Vector3(),\\r\\n        nodeBoxMax = new THREE.Vector3();\\r\\n\\r\\n    for ( depth = 0; depth < this.maxDepth; depth ++ ) {\\r\\n\\r\\n      this.nodes.push( [] );\\r\\n      pow2 = Math.pow( 2, depth );\\r\\n      pow4 = Math.pow( 4, depth );\\r\\n      nodeBoxSize.subVectors( this.max, this.min ).divideScalar( pow2 );\\r\\n\\r\\n      for ( i = 0, length = Math.pow( 8, depth ); i < length; i ++ ) {\\r\\n\\r\\n        indexX = i % pow2;\\r\\n        indexY = ( i / pow4 )|0;\\r\\n        indexZ = ( ( i / pow2 )|0 ) % pow2;\\r\\n\\r\\n        nodeBoxMin.set(\\r\\n          this.min.x + indexX * nodeBoxSize.x,\\r\\n          this.min.y + indexY * nodeBoxSize.y,\\r\\n          this.min.z + indexZ * nodeBoxSize.z\\r\\n        );\\r\\n        nodeBoxMax.copy( nodeBoxMin ).add( nodeBoxSize );\\r\\n\\r\\n        mortonNumber = ns.Octree.getMortonNumber( indexX, indexY, indexZ );\\r\\n        this.nodes[ depth ][ mortonNumber ] = new ns.OctreeNode( this, depth, mortonNumber, nodeBoxMin, nodeBoxMax );\\r\\n\\r\\n      }\\r\\n\\r\\n    }\\r\\n\\r\\n  };\\r\\n\\r\\n  ns.Octree.prototype = {\\r\\n\\r\\n    constructor: ns.Octree,\\r\\n\\r\\n    importThreeMesh: function ( threeMesh ) {\\r\\n\\r\\n\\r\\n      var i, ii, l, ll,\\r\\n          vec3 = new THREE.Vector3(),\\r\\n          geometry,\\r\\n          geometryId,\\r\\n          face,\\r\\n          normal,\\r\\n          index,\\r\\n          count,\\r\\n          start,\\r\\n          a, b, c,\\r\\n        \\tvA  = new THREE.Vector3(),\\r\\n        \\tvB  = new THREE.Vector3(),\\r\\n        \\tvC  = new THREE.Vector3(),\\r\\n        \\tvnA = new THREE.Vector3(),\\r\\n        \\tvnB = new THREE.Vector3(),\\r\\n        \\tvnC = new THREE.Vector3(),\\r\\n          ab  = new THREE.Vector3(),\\r\\n          cb  = new THREE.Vector3(),\\r\\n          faceNormal;\\r\\n\\r\\n      threeMesh.updateMatrix();\\r\\n\\r\\n      geometryId = threeMesh.geometry.uuid;\\r\\n      geometry   = threeMesh.geometry.clone();\\r\\n      geometry.applyMatrix( threeMesh.matrix );\\r\\n      geometry.computeVertexNormals();\\r\\n\\r\\n      if ( geometry instanceof THREE.BufferGeometry ) {\\r\\n\\r\\n        if ( geometry.index !== undefined ) {\\r\\n\\r\\n          var indices   = geometry.index.array;\\r\\n          var positions = geometry.attributes.position.array;\\r\\n          var normals   = geometry.attributes.normal.array;\\r\\n          var offsets   = geometry.groups;\\r\\n\\r\\n          if ( offsets.length === 0 ) {\\r\\n\\r\\n            offsets = [ { start: 0, count: indices.length, index: 0 } ];\\r\\n\\r\\n          }\\r\\n\\r\\n          for ( i = 0, l = offsets.length; i < l; ++ i ) {\\r\\n\\r\\n            start  = offsets[ i ].start;\\r\\n            count  = offsets[ i ].count;\\r\\n            index  = offsets[ i ].materialIndex;\\r\\n\\r\\n            for ( ii = start, ll = start + count; ii < ll; ii += 3 ) {\\r\\n\\r\\n              a = index + indices[ ii ];\\r\\n              b = index + indices[ ii + 1 ];\\r\\n              c = index + indices[ ii + 2 ];\\r\\n\\r\\n              vA = vec3.fromArray( positions, a * 3 ).clone();\\r\\n              vB = vec3.fromArray( positions, b * 3 ).clone();\\r\\n              vC = vec3.fromArray( positions, c * 3 ).clone();\\r\\n\\r\\n              // https://github.com/mrdoob/three.js/issues/4691\\r\\n              // make face normal\\r\\n              cb.subVectors( vC, vB );\\r\\n              ab.subVectors( vA, vB );\\r\\n              faceNormal = cb.cross( ab ).normalize().clone();\\r\\n\\r\\n              face = new ns.Face(\\r\\n                vA,\\r\\n                vB,\\r\\n                vC,\\r\\n                faceNormal,\\r\\n                geometryId\\r\\n              );\\r\\n\\r\\n              this.addFace( face );\\r\\n\\r\\n            }\\r\\n\\r\\n          }\\r\\n\\r\\n        }\\r\\n\\r\\n        return;\\r\\n\\r\\n      }\\r\\n\\r\\n      geometry.computeFaceNormals();\\r\\n\\r\\n      for ( i = 0, l = geometry.faces.length; i < l; i ++ ) {\\r\\n\\r\\n        face = new ns.Face(\\r\\n          geometry.vertices[ geometry.faces[ i ].a ],\\r\\n          geometry.vertices[ geometry.faces[ i ].b ],\\r\\n          geometry.vertices[ geometry.faces[ i ].c ],\\r\\n          geometry.faces[ i ].normal,\\r\\n          geometryId\\r\\n        );\\r\\n        this.addFace( face );\\r\\n\\r\\n      }\\r\\n\\r\\n    },\\r\\n\\r\\n    addFace: function ( face ) {\\r\\n\\r\\n      var i, ii, l, ll, node, targetNodes = [], tmp = [], isIntersected;\\r\\n\\r\\n      targetNodes = this.nodes[ 0 ].slice( 0 );\\r\\n\\r\\n      for ( i = 0, l = this.maxDepth; i < l; i ++ ) {\\r\\n\\r\\n        for ( ii = 0, ll = targetNodes.length; ii < ll; ii ++ ) {\\r\\n\\r\\n          node = targetNodes[ ii ];\\r\\n          isIntersected = ns.collision.isIntersectionTriangleAABB( face.a, face.b, face.c, node );\\r\\n\\r\\n          if ( isIntersected ) {\\r\\n\\r\\n            node.trianglePool.push( face );\\r\\n\\r\\n            if ( i + 1 !== this.maxDepth ) {\\r\\n\\r\\n              tmp = tmp.concat( node.getChildNodes() );\\r\\n\\r\\n            }\\r\\n\\r\\n          }\\r\\n\\r\\n        }\\r\\n\\r\\n        if ( tmp.length === 0 ) {\\r\\n\\r\\n          break;\\r\\n\\r\\n        }\\r\\n\\r\\n        targetNodes = tmp.slice( 0 );\\r\\n        tmp.length = 0;\\r\\n\\r\\n      }\\r\\n\\r\\n    },\\r\\n\\r\\n    removeThreeMesh: function ( meshID ) {\\r\\n\\r\\n      var that = this;\\r\\n\\r\\n      this.nodes.forEach( function ( nodeDepth ) {\\r\\n\\r\\n        nodeDepth.forEach( function ( node ) {\\r\\n\\r\\n          var newTrianglePool = [];\\r\\n\\r\\n          node.trianglePool.forEach( function ( face ) {\\r\\n\\r\\n            if ( face.meshID !== meshID ) {\\r\\n\\r\\n              newTrianglePool.push( face );\\r\\n\\r\\n            }\\r\\n\\r\\n          } );\\r\\n\\r\\n          node.trianglePool = newTrianglePool;\\r\\n\\r\\n        } );\\r\\n\\r\\n      } );\\r\\n\\r\\n    },\\r\\n\\r\\n    getIntersectedNodes: function ( sphere, depth ) {\\r\\n\\r\\n      var i, ii, l, ll, node, targetNodes = [], tmp = [],\\r\\n          isIntersected, intersectedNodes = [], isAtMaxDepth;\\r\\n\\r\\n      isIntersected = ns.collision.isIntersectionSphereAABB( sphere, this );\\r\\n\\r\\n      if ( !isIntersected ) {\\r\\n\\r\\n        return [];\\r\\n\\r\\n      }\\r\\n\\r\\n      targetNodes = this.nodes[ 0 ].slice( 0 );\\r\\n\\r\\n      for ( i = 0, l = depth; i < l; i ++ ) {\\r\\n\\r\\n        for ( ii = 0, ll = targetNodes.length; ii < ll; ii ++ ) {\\r\\n\\r\\n          node = targetNodes[ ii ];\\r\\n          isIntersected = ns.collision.isIntersectionSphereAABB( sphere, node );\\r\\n\\r\\n          if ( isIntersected ) {\\r\\n\\r\\n            isAtMaxDepth = ( i + 1 === depth );\\r\\n\\r\\n            if ( isAtMaxDepth ) {\\r\\n\\r\\n              if ( node.trianglePool.length !== 0 ) {\\r\\n\\r\\n                intersectedNodes.push( node );\\r\\n\\r\\n              }\\r\\n\\r\\n            } else {\\r\\n\\r\\n              tmp = tmp.concat( node.getChildNodes() );\\r\\n\\r\\n            }\\r\\n\\r\\n          }\\r\\n\\r\\n        }\\r\\n\\r\\n        targetNodes = tmp.slice( 0 );\\r\\n        tmp.length = 0;\\r\\n\\r\\n      }\\r\\n\\r\\n      return intersectedNodes;\\r\\n\\r\\n    }\\r\\n\\r\\n  };\\r\\n\\r\\n  ns.Octree.separate3Bit = function ( n ) {\\r\\n\\r\\n    n = ( n | n << 8 ) & 0x0000f00f;\\r\\n    n = ( n | n << 4 ) & 0x000c30c3;\\r\\n    n = ( n | n << 2 ) & 0x00249249;\\r\\n    return n;\\r\\n\\r\\n  };\\r\\n\\r\\n  ns.Octree.getMortonNumber = function ( x, y, z ) {\\r\\n\\r\\n    return ns.Octree.separate3Bit( x ) |\\r\\n           ns.Octree.separate3Bit( y ) << 1 |\\r\\n           ns.Octree.separate3Bit( z ) << 2;\\r\\n\\r\\n  };\\r\\n\\r\\n  ns.Octree.uniqTriangkesfromNodes = function ( nodes ) {\\r\\n\\r\\n    var i, ii, iii, l, ll, lll, uniq = [], isContained = false;\\r\\n\\r\\n    if ( nodes.length === 0 ) {\\r\\n\\r\\n      return [];\\r\\n\\r\\n    } else if ( nodes.length === 1 ) {\\r\\n\\r\\n      return nodes[ 0 ].trianglePool.slice( 0 );\\r\\n\\r\\n    }\\r\\n\\r\\n    for ( i = 0, l = nodes.length; i < l; i ++ ) {\\r\\n\\r\\n      for ( ii = 0, ll = nodes[ i ].trianglePool.length; ii < ll; ii ++ ) {\\r\\n\\r\\n        for ( iii = 0, lll = uniq.length; iii < lll; iii ++ ) {\\r\\n\\r\\n          if ( nodes[ i ].trianglePool[ ii ] === uniq[ iii ] ) {\\r\\n\\r\\n            isContained = true;\\r\\n\\r\\n          }\\r\\n\\r\\n        }\\r\\n\\r\\n        if ( !isContained ) {\\r\\n\\r\\n          uniq.push( nodes[ i ].trianglePool[ ii ] );\\r\\n\\r\\n        }\\r\\n\\r\\n        isContained = false;\\r\\n\\r\\n      }\\r\\n\\r\\n    }\\r\\n\\r\\n    return uniq;\\r\\n\\r\\n  };\\r\\n\\r\\n  //\\r\\n\\r\\n  ns.OctreeNode = function ( tree, depth, mortonNumber, min, max ) {\\r\\n\\r\\n    this.tree = tree;\\r\\n    this.depth = depth;\\r\\n    this.mortonNumber = mortonNumber;\\r\\n    this.min = new THREE.Vector3( min.x, min.y, min.z );\\r\\n    this.max = new THREE.Vector3( max.x, max.y, max.z );\\r\\n    this.trianglePool = [];\\r\\n\\r\\n  };\\r\\n\\r\\n  ns.OctreeNode.prototype = {\\r\\n\\r\\n    constructor: ns.OctreeNode,\\r\\n\\r\\n    getParentNode: function () {\\r\\n\\r\\n      if ( this.depth === 0 ) {\\r\\n\\r\\n        return null;\\r\\n\\r\\n      }\\r\\n\\r\\n      this.tree.nodes[ this.depth ][ this.mortonNumber >> 3 ];\\r\\n\\r\\n    },\\r\\n\\r\\n    getChildNodes: function () {\\r\\n\\r\\n      if ( this.tree.maxDepth === this.depth ) {\\r\\n\\r\\n        return null;\\r\\n\\r\\n      }\\r\\n\\r\\n      var firstChild = this.mortonNumber << 3;\\r\\n\\r\\n      return [\\r\\n        this.tree.nodes[ this.depth + 1 ][ firstChild ],\\r\\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 1 ],\\r\\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 2 ],\\r\\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 3 ],\\r\\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 4 ],\\r\\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 5 ],\\r\\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 6 ],\\r\\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 7 ]\\r\\n      ];\\r\\n\\r\\n    }\\r\\n\\r\\n  };\\r\\n\\r\\n  //\\r\\n\\r\\n  // a: <THREE.Vector3>\\r\\n  // b: <THREE.Vector3>\\r\\n  // c: <THREE.Vector3>\\r\\n  // normal: <THREE.Vector3>\\r\\n  // meshID: <String>\\r\\n  ns.Face = function ( a, b, c, normal, meshID ) {\\r\\n\\r\\n    this.a = a.clone();\\r\\n    this.b = b.clone();\\r\\n    this.c = c.clone();\\r\\n    this.normal = normal.clone();\\r\\n    this.meshID = meshID;\\r\\n\\r\\n  };\\r\\n\\r\\n  ns.Face.prototype = {\\r\\n\\r\\n    constructor: ns.Face\\r\\n\\r\\n  };\\r\\n\\r\\n  // origin   : <THREE.Vector3>\\r\\n  // direction: <THREE.Vector3>\\r\\n  // distance : <Float>\\r\\n  ns.Ray = function ( origin, direction, distance ) {\\r\\n    this.origin = origin;\\r\\n    this.direction = direction;\\r\\n    this.distance = distance;\\r\\n  };\\r\\n\\r\\n} )( THREE, MW );\\r\\n\\r\\n\\r\\n\""
		},
		{
			"name": "MWtps.js",
			"source": "\"// MWtps.js\\r\\n\\r\\n/*!\\r\\n* @author yomotsu http://yomotsu.net/\\r\\n* MIT License\\r\\n*/\\r\\n\\r\\n;( function ( THREE, ns ) {\\r\\n\\r\\n  'use strict';\\r\\n\\r\\n  ns.CharacterController = function ( object3d, radius ) {\\r\\n\\r\\n    Object.assign( this, THREE.EventDispatcher.prototype );  //  THREE.EventDispatcher.prototype.apply( this );\\r\\n    this.object = object3d;\\r\\n    this.center = this.object.position.clone();\\r\\n    this.radius = radius;\\r\\n    this.groundPadding = 0.5;\\r\\n    this.maxSlopeGradient = Math.cos( THREE.Math.degToRad( 50 ) );\\r\\n    this.isGrounded = false;\\r\\n    this.isOnSlope  = false;\\r\\n    this.isIdling   = false;\\r\\n    this.isRunning  = false;\\r\\n    this.isJumping  = false;\\r\\n    this.direction  = 0; // 0 to 2PI(=360deg) in rad\\r\\n    this.movementSpeed = 28; // default: 50; // Meters Per Second\\r\\n    this.velocity = new THREE.Vector3( 0, -10, 0 );\\r\\n    this.currentJumpPower = 0;\\r\\n    this.jumpStartTime = 0;\\r\\n    this.groundHeight = 0;\\r\\n    this.groundNormal = new THREE.Vector3();\\r\\n    this.collisionCandidate;\\r\\n    this.contactInfo = [];\\r\\n\\r\\n  };\\r\\n\\r\\n  ns.CharacterController.prototype = {\\r\\n\\r\\n    constructor: ns.CharacterController,\\r\\n\\r\\n    update: function ( dt ) {\\r\\n\\r\\n      this.isGrounded = false;\\r\\n      this.isOnSlope  = false;\\r\\n      this.groundHeight = -Infinity;\\r\\n      this.groundNormal.set( 0, 1, 0 );\\r\\n\\r\\n      this.updateGrounding();\\r\\n      this.updateJumping();\\r\\n      this.updatePosition( dt );\\r\\n      this.collisionDetection();\\r\\n      this.solvePosition();\\r\\n      this.updateVelocity();\\r\\n      this.events();\\r\\n\\r\\n    },\\r\\n\\r\\n    updateVelocity: function () {\\r\\n\\r\\n      var FALL_VELOCITY = -50,\\r\\n          frontDierction = -Math.cos( this.direction ),\\r\\n          rightDierction = -Math.sin( this.direction ),\\r\\n          normal,\\r\\n          isHittingCeiling = false,\\r\\n          wallNomal2D,\\r\\n          direction2D,\\r\\n          wallAngle,\\r\\n          frontAngle,\\r\\n          negativeFrontAngle,\\r\\n          i, l;\\r\\n      \\r\\n      this.velocity.set(\\r\\n        rightDierction * this.movementSpeed * this.isRunning, \\r\\n        FALL_VELOCITY,\\r\\n        frontDierction * this.movementSpeed * this.isRunning\\r\\n      );\\r\\n\\r\\n      if ( this.contactInfo.length === 0 && !this.isJumping ) {\\r\\n\\r\\n        return;\\r\\n\\r\\n      } else if ( this.isGrounded && !this.isOnSlope && !this.isJumping ) {\\r\\n\\r\\n        this.velocity.y = 0;\\r\\n\\r\\n      } else if ( this.isOnSlope ) {\\r\\n\\r\\n        var slidingDownVelocity = FALL_VELOCITY;\\r\\n        var holizontalSpead = - slidingDownVelocity / ( 1 - this.groundNormal.y ) * 0.2;\\r\\n\\r\\n        this.velocity.x = this.groundNormal.x * holizontalSpead;\\r\\n        this.velocity.y = FALL_VELOCITY;\\r\\n        this.velocity.z = this.groundNormal.z * holizontalSpead;\\r\\n\\r\\n      } else if ( !this.isGrounded && !this.isOnSlope && this.isJumping ) {\\r\\n\\r\\n        this.velocity.y = this.currentJumpPower * -FALL_VELOCITY;\\r\\n\\r\\n      }\\r\\n\\r\\n\\r\\n      // vs walls and sliding on the wall\\r\\n      direction2D = new THREE.Vector2( rightDierction, frontDierction );\\r\\n      frontAngle = Math.atan2( direction2D.y, direction2D.x );\\r\\n      negativeFrontAngle = Math.atan2( -direction2D.y, -direction2D.x );\\r\\n      \\r\\n      for ( i = 0, l = this.contactInfo.length; i < l; i ++ ) {\\r\\n\\r\\n        normal = this.contactInfo[ i ].face.normal;\\r\\n        // var distance = this.contactInfo[ i ].distance;\\r\\n\\r\\n        if ( this.maxSlopeGradient < normal.y || this.isOnSlope ) {\\r\\n\\r\\n          continue;\\r\\n\\r\\n        }\\r\\n\\r\\n        if ( !isHittingCeiling && normal.y < 0 ) {\\r\\n\\r\\n          isHittingCeiling = true;\\r\\n\\r\\n        }\\r\\n\\r\\n        wallNomal2D = new THREE.Vector2( normal.x, normal.z ).normalize();\\r\\n        wallAngle = Math.atan2( wallNomal2D.y, wallNomal2D.x );\\r\\n\\r\\n        if (\\r\\n          Math.abs( negativeFrontAngle - wallAngle ) >= Math.PI * 0.5 && //  90deg\\r\\n          Math.abs( negativeFrontAngle - wallAngle ) <= Math.PI * 1.5    // 270deg\\r\\n        ) {\\r\\n\\r\\n          continue;\\r\\n\\r\\n        }\\r\\n\\r\\n        wallNomal2D.set(\\r\\n          direction2D.dot( wallNomal2D ) * wallNomal2D.x,\\r\\n          direction2D.dot( wallNomal2D ) * wallNomal2D.y\\r\\n        );\\r\\n        direction2D.subVectors( direction2D, wallNomal2D );\\r\\n\\r\\n        this.velocity.x = direction2D.x * this.movementSpeed * this.isRunning;\\r\\n        this.velocity.z = direction2D.y * this.movementSpeed * this.isRunning;\\r\\n\\r\\n      }\\r\\n\\r\\n      if ( isHittingCeiling ) {\\r\\n\\r\\n        this.velocity.y = Math.min( 0, this.velocity.y );\\r\\n        this.isJumping = false;\\r\\n\\r\\n      }\\r\\n\\r\\n    },\\r\\n\\r\\n    updateGrounding: function () {\\r\\n\\r\\n      // \\\"頭上からほぼ無限に下方向までの線 (segment)\\\" vs \\\"フェイス (triangle)\\\" の\\r\\n      // 交差判定を行う\\r\\n      // もし、フェイスとの交差点が「頭上」から「下groundPadding」までの間だったら\\r\\n      // 地面上 (isGrounded) にいることとみなす\\r\\n      //\\r\\n      //   ___\\r\\n      //  / | \\\\\\r\\n      // |  |  | player sphere\\r\\n      //  \\\\_|_/\\r\\n      //    |\\r\\n      //---[+]---- ground\\r\\n      //    |\\r\\n      //    |\\r\\n      //    | segment (player's head to almost -infinity)\\r\\n\\r\\n\\r\\n      var i, l,\\r\\n          groundContactInfo,\\r\\n          groundContactInfoTmp,\\r\\n          faces = this.collisionCandidate,\\r\\n          distanceToGround;\\r\\n\\r\\n      var head = new THREE.Vector3(\\r\\n        this.center.x,\\r\\n        this.center.y + this.radius,\\r\\n        this.center.z\\r\\n      );\\r\\n\\r\\n      var to = new THREE.Vector3(\\r\\n        this.center.x,\\r\\n        this.center.y - 1e10,\\r\\n        this.center.z\\r\\n      );\\r\\n\\r\\n      for ( i = 0, l = faces.length; i < l; i ++ ) {\\r\\n\\r\\n        groundContactInfoTmp = ns.collision.testSegmentTriangle( head, to, faces[ i ].a, faces[ i ].b, faces[ i ].c );\\r\\n\\r\\n        if ( groundContactInfoTmp && !groundContactInfo ) {\\r\\n\\r\\n          groundContactInfo = groundContactInfoTmp;\\r\\n          groundContactInfo.face = faces[ i ];\\r\\n\\r\\n        } else if (\\r\\n          groundContactInfoTmp &&\\r\\n          groundContactInfoTmp.contactPoint.y > groundContactInfo.contactPoint.y\\r\\n        ) {\\r\\n          \\r\\n          groundContactInfo = groundContactInfoTmp;\\r\\n          groundContactInfo.face = faces[ i ];\\r\\n\\r\\n        }\\r\\n\\r\\n      }\\r\\n\\r\\n      if ( !groundContactInfo ) {\\r\\n\\r\\n        return;\\r\\n\\r\\n      }\\r\\n\\r\\n      this.groundHeight = groundContactInfo.contactPoint.y;\\r\\n      this.groundNormal.copy( groundContactInfo.face.normal );\\r\\n\\r\\n      var top    = head.y;\\r\\n      var bottom = this.center.y - this.radius - this.groundPadding;\\r\\n\\r\\n      if ( this.isJumping && 0 < this.currentJumpPower ) {\\r\\n\\r\\n        this.isOnSlope  = false;\\r\\n        this.isGrounded = false;\\r\\n        return;\\r\\n\\r\\n      }\\r\\n\\r\\n      this.isGrounded = ( bottom <= this.groundHeight && this.groundHeight <= top );\\r\\n      this.isOnSlope  = ( this.groundNormal.y <= this.maxSlopeGradient );\\r\\n\\r\\n      if ( this.isGrounded ) {\\r\\n\\r\\n        this.isJumping = false;\\r\\n\\r\\n      }\\r\\n\\r\\n    },\\r\\n\\r\\n    updatePosition: function ( dt ) {\\r\\n\\r\\n      var x = this.center.x + this.velocity.x * dt,\\r\\n          y = this.center.y + this.velocity.y * dt,\\r\\n          z = this.center.z + this.velocity.z * dt;\\r\\n\\r\\n      if ( this.isGrounded ) {\\r\\n\\r\\n        y = this.groundHeight + this.radius;\\r\\n\\r\\n      }\\r\\n\\r\\n      this.center.set( x, y, z );\\r\\n\\r\\n    },\\r\\n\\r\\n    collisionDetection: function () {\\r\\n\\r\\n      var i, l,\\r\\n          faces = this.collisionCandidate,\\r\\n          contactInfo;\\r\\n\\r\\n      this.contactInfo.length = 0;\\r\\n\\r\\n      for ( i = 0, l = faces.length; i < l; i ++ ) {\\r\\n\\r\\n        contactInfo = ns.collision.isIntersectionSphereTriangle( this, faces[ i ].a, faces[ i ].b, faces[ i ].c, faces[ i ].normal );\\r\\n\\r\\n        if ( !contactInfo ) {\\r\\n\\r\\n          continue;\\r\\n\\r\\n        }\\r\\n\\r\\n        contactInfo.face = faces[ i ];\\r\\n        this.contactInfo.push( contactInfo );\\r\\n\\r\\n      }\\r\\n\\r\\n    },\\r\\n\\r\\n    solvePosition: function () {\\r\\n\\r\\n      var face,\\r\\n          normal,\\r\\n          distance,\\r\\n          point1 = new THREE.Vector3(),\\r\\n          point2 = new THREE.Vector3(),\\r\\n          direction = new THREE.Vector3(),\\r\\n          plainD,\\r\\n          t,\\r\\n          translateScoped = new THREE.Vector3(),\\r\\n          translate = new THREE.Vector3(),\\r\\n          i, l;\\r\\n\\r\\n      if ( this.contactInfo.length === 0 ) {\\r\\n\\r\\n        this.object.position.copy( this.center );\\r\\n        return;\\r\\n\\r\\n      }\\r\\n\\r\\n      // \\r\\n      // vs walls and sliding on the wall\\r\\n\\r\\n      for ( i = 0, l = this.contactInfo.length; i < l; i ++ ) {\\r\\n\\r\\n        face = this.contactInfo[ i ].face;\\r\\n        normal = this.contactInfo[ i ].face.normal;\\r\\n        distance = this.contactInfo[ i ].distance;\\r\\n\\r\\n        // if ( 0 <= distance ) {\\r\\n\\r\\n        //   continue;\\r\\n\\r\\n        // }\\r\\n\\r\\n        if ( this.maxSlopeGradient < normal.y ) {\\r\\n\\r\\n          // this triangle is a ground or slope, not a wall or ceil.\\r\\n          continue;\\r\\n\\r\\n        }\\r\\n\\r\\n        var isSlopeFace = ( this.maxSlopeGradient <= face.normal.y && face.normal.y < 1 );\\r\\n\\r\\n        if ( this.isJumping && 0 >= this.currentJumpPower && isSlopeFace ) {\\r\\n\\r\\n          this.isJumping = false;\\r\\n          this.isGrounded = true;\\r\\n          // console.log( 'jump end' );\\r\\n\\r\\n        }\\r\\n\\r\\n        if ( this.isGrounded || this.isOnSlope ) {\\r\\n\\r\\n          // http://gamedev.stackexchange.com/questions/80293/how-do-i-resolve-a-sphere-triangle-collision-in-a-given-direction\\r\\n          point1.copy( normal ).multiplyScalar( -this.radius ).add( this.center );\\r\\n          direction.set( normal.x, 0, normal.z ).normalize();\\r\\n          plainD = face.a.dot( normal );\\r\\n          t = ( plainD - ( normal.x * point1.x + normal.y * point1.y + normal.z * point1.z ) ) / ( normal.x * direction.x + normal.y * direction.y + normal.z * direction.z );\\r\\n          point2.copy( direction ).multiplyScalar( t ).add( point1 );\\r\\n          translateScoped.subVectors( point2, point1 );\\r\\n\\r\\n          if ( Math.abs( translate.x ) > Math.abs( translateScoped.x ) ) {\\r\\n\\r\\n            translate.x += translateScoped.x;\\r\\n\\r\\n          }\\r\\n\\r\\n          if ( Math.abs( translate.z ) > Math.abs( translateScoped.z ) ) {\\r\\n\\r\\n            translate.z += translateScoped.z;\\r\\n\\r\\n          }\\r\\n\\r\\n          // break;\\r\\n          continue;\\r\\n\\r\\n        }\\r\\n\\r\\n      }\\r\\n\\r\\n      this.center.add( translate );\\r\\n      this.object.position.copy( this.center );\\r\\n\\r\\n    },\\r\\n\\r\\n    events: function () {\\r\\n\\r\\n      var isFirstUpdate = true,\\r\\n          wasGrounded,\\r\\n          wasOnSlope,\\r\\n          wasIdling,\\r\\n          wasRunning,\\r\\n          wasJumping;\\r\\n\\r\\n      return function () {\\r\\n\\r\\n        if ( isFirstUpdate ) {\\r\\n\\r\\n            isFirstUpdate = false;\\r\\n            wasGrounded = this.isGrounded;\\r\\n            wasOnSlope  = this.isOnSlope;\\r\\n            wasIdling   = this.isIdling;\\r\\n            wasRunning  = this.isRunning;\\r\\n            wasJumping  = this.isJumping;\\r\\n            return;\\r\\n\\r\\n        }\\r\\n\\r\\n        if ( !wasRunning && !this.isRunning && this.isGrounded && !this.isIdling ) {\\r\\n\\r\\n            this.isIdling = true;\\r\\n            this.dispatchEvent( { type: 'startIdling' } );\\r\\n\\r\\n        } else if (\\r\\n          ( !wasRunning && this.isRunning && !this.isJumping && this.isGrounded ) ||\\r\\n          ( !wasGrounded && this.isGrounded && this.isRunning ) ||\\r\\n          ( wasOnSlope && !this.isOnSlope && this.isRunning && this.isGrounded )\\r\\n        ) {\\r\\n\\r\\n            this.isIdling = false;\\r\\n            this.dispatchEvent( { type: 'startRunning' } );\\r\\n          \\r\\n        } else if ( !wasJumping && this.isJumping ) {\\r\\n\\r\\n            this.isIdling = false;\\r\\n            this.dispatchEvent( { type: 'startJumping' } );\\r\\n          \\r\\n        } else if ( !wasOnSlope && this.isOnSlope ) {\\r\\n\\r\\n            this.dispatchEvent( { type: 'startSliding' } );\\r\\n          \\r\\n        } else if ( wasGrounded && !this.isGrounded && !this.isJumping ) {\\r\\n\\r\\n            this.dispatchEvent( { type: 'startFalling' } );\\r\\n          \\r\\n        }\\r\\n\\r\\n        if ( !wasGrounded && this.isGrounded ) {\\r\\n\\r\\n            this.dispatchEvent( { type: 'endJumping' } );\\r\\n          \\r\\n        }\\r\\n\\r\\n        wasGrounded = this.isGrounded;\\r\\n        wasOnSlope  = this.isOnSlope;\\r\\n        wasIdling   = this.isIdling;\\r\\n        wasRunning  = this.isRunning;\\r\\n        wasJumping  = this.isJumping;\\r\\n\\r\\n      };\\r\\n\\r\\n    }(),\\r\\n\\r\\n    setDirection : function () {\\r\\n\\r\\n\\r\\n\\r\\n    },\\r\\n\\r\\n    jump: function () {\\r\\n      \\r\\n      if ( this.isJumping || !this.isGrounded || this.isOnSlope ) {\\r\\n\\r\\n        return;\\r\\n\\r\\n      }\\r\\n\\r\\n      // since ios dose not support porformance.now()\\r\\n      // this.jumpStartTime = performance.now();\\r\\n      this.jumpStartTime = Date.now();\\r\\n      this.currentJumpPower = 0.01;\\r\\n      this.isJumping = true;\\r\\n\\r\\n    },\\r\\n\\r\\n    updateJumping: function () {\\r\\n\\r\\n      var JUMP_DURATION = 1500;\\r\\n\\r\\n      if ( !this.isJumping ) {\\r\\n\\r\\n        return;\\r\\n\\r\\n      }\\r\\n\\r\\n      // since ios dose not support porformance.now()\\r\\n      // var elapsed = performance.now() - this.jumpStartTime;\\r\\n      var elapsed = Date.now() - this.jumpStartTime;\\r\\n      var progress = elapsed / JUMP_DURATION;\\r\\n      this.currentJumpPower = Math.cos( Math.min( progress, 1 ) * Math.PI );\\r\\n\\r\\n    }\\r\\n\\r\\n  }\\r\\n\\r\\n} )( THREE, MW );\\r\\n\\r\\n// @author yomotsu\\r\\n// MIT License\\r\\n\\r\\nMW.AnimationController = function ( mesh ) {\\r\\n\\r\\n  this.mesh   = mesh;\\r\\n  this.motion = {};\\r\\n  this.mixer  = new THREE.AnimationMixer( mesh );\\r\\n  this.currentMotionName = \\\"\\\";\\r\\n\\r\\n  var i, l, anim;\\r\\n\\r\\n  for ( i = 0, l = this.mesh.geometry.animations.length; i < l; i ++ ) {\\r\\n\\r\\n    anim = this.mesh.geometry.animations[ i ];\\r\\n    this.motion[ anim.name ] = this.mixer.clipAction( anim );\\r\\n    this.motion[ anim.name ].setEffectiveWeight( 1 );\\r\\n\\r\\n  }\\r\\n  \\r\\n};\\r\\n\\r\\nMW.AnimationController.prototype = {\\r\\n\\r\\n  play: function ( name ) {\\r\\n\\r\\n    if ( this.currentMotionName === name ) { return; }\\r\\n\\r\\n    if ( this.motion[ this.currentMotionName ] ) {\\r\\n\\r\\n      var from = this.motion[ this.currentMotionName ].play();\\r\\n      var to   = this.motion[ name ].play();\\r\\n\\r\\n      from.enabled = true;\\r\\n      to.enabled = true;\\r\\n\\r\\n      from.crossFadeTo( to, .3 );\\r\\n\\r\\n    } else {\\r\\n\\r\\n      this.motion[ name ].enabled = true;\\r\\n      this.motion[ name ].play();\\r\\n\\r\\n    }\\r\\n\\r\\n    this.currentMotionName = name;\\r\\n\\r\\n  },\\r\\n\\r\\n  turn: function () {\\r\\n\\r\\n    var DURATION  = 200;\\r\\n    var TAU = 2 * Math.PI;\\r\\n\\r\\n    var mod = function ( a, n ) { return ( a % n + n ) % n; };\\r\\n\\r\\n    var getDeltaAngle = function ( current, target ) {\\r\\n\\r\\n      var a = mod( ( current - target ), TAU );\\r\\n      var b = mod( ( target - current ), TAU );\\r\\n\\r\\n      return a < b ? -a : b;\\r\\n\\r\\n    };\\r\\n\\r\\n    return function ( rad, immediate ) {\\r\\n\\r\\n\\r\\n      var that       = this;\\r\\n      var progress   = 0;\\r\\n      var prevRotY   = this.mesh.rotation.y;\\r\\n      var targetRotY = rad;\\r\\n      var deltaY     = getDeltaAngle( prevRotY, targetRotY );\\r\\n      // var duration   = Math.abs( deltaY ) * 100;\\r\\n      var start      = Date.now();\\r\\n      var end        = start + DURATION;\\r\\n\\r\\n      if ( immediate ) {\\r\\n\\r\\n        this.mesh.rotation.y = targetRotY;\\r\\n        return;\\r\\n\\r\\n      }\\r\\n\\r\\n      if ( this._targetRotY === targetRotY ) { return; }\\r\\n\\r\\n      this._targetRotY = targetRotY;\\r\\n\\r\\n      ( function () {\\r\\n\\r\\n        var _targetRotY = targetRotY;\\r\\n\\r\\n        ( function interval () {\\r\\n\\r\\n          var now = Date.now();\\r\\n          var isAborted = _targetRotY !== that._targetRotY;\\r\\n\\r\\n          if ( isAborted ) { return; }\\r\\n\\r\\n          if ( now >= end ) {\\r\\n\\r\\n            that.mesh.rotation.y = _targetRotY;\\r\\n            delete that._targetRotY;\\r\\n            return;\\r\\n\\r\\n          }\\r\\n\\r\\n          requestAnimationFrame( interval );\\r\\n          progress = ( now - start ) / DURATION;\\r\\n          that.mesh.rotation.y = prevRotY + deltaY * progress;\\r\\n\\r\\n        } )();\\r\\n\\r\\n      } )();\\r\\n\\r\\n    }\\r\\n\\r\\n  }(),\\r\\n\\r\\n  update: function ( delta ) {\\r\\n\\r\\n    this.mixer.update( delta );\\r\\n\\r\\n  }\\r\\n\\r\\n};\\r\\n\\r\\n// @author yomotsu\\r\\n// MIT License\\r\\n\\r\\n;( function ( THREE, ns ) {\\r\\n\\r\\n  'use strict';\\r\\n\\r\\n  var KEY_W     = 87,\\r\\n      KEY_UP    = 38,\\r\\n      KEY_S     = 83,\\r\\n      KEY_DOWN  = 40,\\r\\n      KEY_A     = 65,\\r\\n      KEY_LEFT  = 37,\\r\\n      KEY_D     = 68,\\r\\n      KEY_RIGHT = 39,\\r\\n      KEY_SPACE = 32,\\r\\n      KEY_R     = 82; // hack //\\r\\n\\r\\n  var DEG_0   = THREE.Math.degToRad(   0 ),\\r\\n      DEG_45  = THREE.Math.degToRad(  45 ),\\r\\n      DEG_90  = THREE.Math.degToRad(  90 ),\\r\\n      DEG_135 = THREE.Math.degToRad( 135 ),\\r\\n      DEG_180 = THREE.Math.degToRad( 180 ),\\r\\n      DEG_225 = THREE.Math.degToRad( 225 ),\\r\\n      DEG_270 = THREE.Math.degToRad( 270 ),\\r\\n      DEG_315 = THREE.Math.degToRad( 315 ),\\r\\n      DEG_360 = THREE.Math.degToRad( 360 );\\r\\n\\r\\n  ns.KeyInputControl = function () {\\r\\n    \\r\\n    Object.assign( this, THREE.EventDispatcher.prototype );  //  THREE.EventDispatcher.prototype.apply( this );\\r\\n\\r\\n    this.isDisabled = false;\\r\\n\\r\\n    this.isUp    = false;\\r\\n    this.isDown  = false;\\r\\n    this.isLeft  = false;\\r\\n    this.isRight = false;\\r\\n    this.inRun   = false; // hack.\\r\\n    this.isMoveKeyHolded = false;\\r\\n    this.frontAngle = 0;\\r\\n\\r\\n    this._keydownListener = onkeydown.bind( this );\\r\\n    this._keyupListener   = onkeyup.bind( this );\\r\\n    this._blurListener    = onblur.bind( this );\\r\\n\\r\\n    window.addEventListener( 'keydown', this._keydownListener, false );\\r\\n    window.addEventListener( 'keyup',   this._keyupListener,   false );\\r\\n    window.addEventListener( 'blur',    this._blurListener,    false );\\r\\n\\r\\n  };\\r\\n\\r\\n  ns.KeyInputControl.prototype.jump = function () {\\r\\n\\r\\n    this.dispatchEvent( { type: 'jumpkeypress' } );\\r\\n\\r\\n  };\\r\\n\\r\\n  ns.KeyInputControl.prototype.updateAngle = function () {\\r\\n\\r\\n    var up    = this.isUp;\\r\\n    var down  = this.isDown;\\r\\n    var left  = this.isLeft;\\r\\n    var right = this.isRight;\\r\\n\\r\\n    if (  up && !left && !down && !right )      { this.frontAngle = DEG_0  ; }\\r\\n    else if (  up &&  left && !down && !right ) { this.frontAngle = DEG_45 ; }\\r\\n    else if ( !up &&  left && !down && !right ) { this.frontAngle = DEG_90 ; }\\r\\n    else if ( !up &&  left &&  down && !right ) { this.frontAngle = DEG_135; }\\r\\n    else if ( !up && !left &&  down && !right ) { this.frontAngle = DEG_180; }\\r\\n    else if ( !up && !left &&  down &&  right ) { this.frontAngle = DEG_225; }\\r\\n    else if ( !up && !left && !down &&  right ) { this.frontAngle = DEG_270; }\\r\\n    else if (  up && !left && !down &&  right ) { this.frontAngle = DEG_315; }\\r\\n\\r\\n  };\\r\\n\\r\\n\\r\\n  function onkeydown ( e ) {\\r\\n\\r\\n    if ( this.isDisabled ) { return; }\\r\\n\\r\\n    switch ( e.keyCode ) {\\r\\n\\r\\n      case KEY_W :\\r\\n      case KEY_UP :\\r\\n        this.isUp = true;\\r\\n        break;\\r\\n\\r\\n      case KEY_S :\\r\\n      case KEY_DOWN :\\r\\n        this.isDown = true;\\r\\n        break;\\r\\n\\r\\n      case KEY_A :\\r\\n      case KEY_LEFT :\\r\\n        this.isLeft = true;\\r\\n        break;\\r\\n\\r\\n      case KEY_D :\\r\\n      case KEY_RIGHT :\\r\\n        this.isRight = true;\\r\\n        break;\\r\\n\\r\\n      case KEY_SPACE :\\r\\n        this.jump();\\r\\n        break;\\r\\n\\r\\n      default:\\r\\n        return;\\r\\n\\r\\n    }\\r\\n    \\r\\n    var prevAngle = this.frontAngle;\\r\\n\\r\\n    this.updateAngle();\\r\\n\\r\\n    if ( prevAngle !== this.frontAngle ) {\\r\\n\\r\\n      this.dispatchEvent( { type: 'movekeychange' } );\\r\\n\\r\\n    }\\r\\n\\r\\n    if (\\r\\n      ( this.isUp || this.isDown || this.isLeft || this.isRight ) &&\\r\\n      !this.isMoveKeyHolded\\r\\n    ) {\\r\\n\\r\\n      this.isMoveKeyHolded = true;\\r\\n      this.dispatchEvent( { type: 'movekeyon' } );\\r\\n\\r\\n    }\\r\\n\\r\\n  }\\r\\n\\r\\n  function onkeyup ( e ) {\\r\\n\\r\\n    if ( this.isDisabled ) { return; }\\r\\n\\r\\n    switch ( e.keyCode ) {\\r\\n\\r\\n      case KEY_W :\\r\\n      case KEY_UP :\\r\\n        this.isUp = false;\\r\\n        break;\\r\\n\\r\\n      case KEY_S :\\r\\n      case KEY_DOWN :\\r\\n        this.isDown = false;\\r\\n        break;\\r\\n        \\r\\n      case KEY_A :\\r\\n      case KEY_LEFT :\\r\\n        this.isLeft = false;\\r\\n        break;\\r\\n\\r\\n      case KEY_D :\\r\\n      case KEY_RIGHT :\\r\\n        this.isRight = false;\\r\\n        break;\\r\\n\\r\\n      case KEY_SPACE :\\r\\n        break;\\r\\n\\r\\n      case KEY_R:\\r\\n        this.inRun = !this.inRun; // hack //  console.log(\\\"case KEY_R:\\\", e.keyCode, this.inRun);\\r\\n        break;\\r\\n\\r\\n      default:\\r\\n        return;\\r\\n\\r\\n    }\\r\\n    \\r\\n    var prevAngle = this.frontAngle;\\r\\n\\r\\n    this.updateAngle();\\r\\n\\r\\n    if ( prevAngle !== this.frontAngle ) {\\r\\n\\r\\n      this.dispatchEvent( { type: 'movekeychange' } );\\r\\n\\r\\n    }\\r\\n\\r\\n    if ( !this.isUp && !this.isDown && !this.isLeft && !this.isRight &&\\r\\n      (\\r\\n           e.keyCode === KEY_W\\r\\n        || e.keyCode === KEY_UP\\r\\n        || e.keyCode === KEY_S\\r\\n        || e.keyCode === KEY_DOWN\\r\\n        || e.keyCode === KEY_A\\r\\n        || e.keyCode === KEY_LEFT\\r\\n        || e.keyCode === KEY_D\\r\\n        || e.keyCode === KEY_RIGHT\\r\\n      )\\r\\n    ) {\\r\\n\\r\\n      this.isMoveKeyHolded = false;\\r\\n      this.dispatchEvent( { type: 'movekeyoff' } );\\r\\n\\r\\n    }\\r\\n\\r\\n  }\\r\\n\\r\\n  function onblur ( e ) {\\r\\n\\r\\n    this.isUp    = false;\\r\\n    this.isDown  = false;\\r\\n    this.isLeft  = false;\\r\\n    this.isRight = false;\\r\\n//  this.inRun   = false; // hack // DO NOT SET TO FALSE ON BLUR. //\\r\\n    \\r\\n    if ( this.isMoveKeyHolded ) {\\r\\n\\r\\n      this.isMoveKeyHolded = false;\\r\\n      this.dispatchEvent( { type: 'movekeyoff' } );\\r\\n\\r\\n    }\\r\\n\\r\\n  }\\r\\n\\r\\n} )( THREE, MW );\\r\\n\\r\\n// @author yomotsu\\r\\n// MIT License\\r\\n\\r\\n;( function ( THREE, ns ) {\\r\\n\\r\\n  'use strict';\\r\\n\\r\\n  var PI2     = Math.PI * 2,\\r\\n      PI_HALF = Math.PI / 2;\\r\\n\\r\\n  var modulo = function ( n, d ) {\\r\\n\\r\\n    return ( ( n % d ) + d ) % d;\\r\\n\\r\\n  };\\r\\n\\r\\n  // camera              isntance of THREE.Camera\\r\\n  // trackObject         isntance of THREE.Object3D\\r\\n  // params.el           DOM element\\r\\n  // params.radius       number\\r\\n  // params.minRadius    number\\r\\n  // params.maxRadius    number\\r\\n  // params.rigidObjects array of inctances of THREE.Mesh\\r\\n  ns.TPSCameraControl = function ( camera, trackObject, params ) {\\r\\n\\r\\n    Object.assign( this, THREE.EventDispatcher.prototype );  //  THREE.EventDispatcher.prototype.apply( this );\\r\\n    this.camera = camera;\\r\\n    this.trackObject  = trackObject;\\r\\n    this.el           = params && params.el || document.body;\\r\\n    this.offset       = params && params.offset || new THREE.Vector3( 0, 0, 0 ),\\r\\n    this.radius       = params && params.radius    || 10;\\r\\n    this.minRadius    = params && params.minRadius || 1;\\r\\n    this.maxRadius    = params && params.maxRadius || 30;\\r\\n    this.rigidObjects = params && params.rigidObjects || [];\\r\\n    this.lat   = 0;\\r\\n    this.lon   = 0;\\r\\n    this.phi   = 0; // angle of zenith\\r\\n    this.theta = 0; // angle of azimuth\\r\\n    this.mouseAccelerationX = params && params.mouseAccelerationX !== undefined ? params.mouseAccelerationX : 100;\\r\\n    this.mouseAccelerationY = params && params.mouseAccelerationY !== undefined ? params.mouseAccelerationY : 30;\\r\\n    this._pointerStart = { x: 0, y: 0 };\\r\\n    this._pointerLast  = { x: 0, y: 0 };\\r\\n\\r\\n    this.setNearPlainCornersWithPadding();\\r\\n    this.update();\\r\\n\\r\\n    this._mousedownListener = onmousedown.bind( this );\\r\\n    this._mouseupListener   = onmouseup.bind( this );\\r\\n    this._mousedragListener = onmousedrag.bind( this );\\r\\n    this._scrollListener    = onscroll.bind( this );\\r\\n\\r\\n    this.el.addEventListener( 'mousedown', this._mousedownListener, false );\\r\\n    this.el.addEventListener( 'mouseup',   this._mouseupListener,   false );\\r\\n    this.el.addEventListener( 'mousewheel',     this._scrollListener, false );\\r\\n    this.el.addEventListener( 'DOMMouseScroll', this._scrollListener, false );\\r\\n\\r\\n  };\\r\\n\\r\\n  ns.TPSCameraControl.prototype = {\\r\\n\\r\\n    constructor: ns.TPSCameraControl,\\r\\n\\r\\n    update: function () {\\r\\n\\r\\n      var position,\\r\\n          distance;\\r\\n\\r\\n      this._center = new THREE.Vector3(\\r\\n        this.trackObject.matrixWorld.elements[ 12 ] + this.offset.x,\\r\\n        this.trackObject.matrixWorld.elements[ 13 ] + this.offset.y,\\r\\n        this.trackObject.matrixWorld.elements[ 14 ] + this.offset.z\\r\\n      );\\r\\n      position = new THREE.Vector3(\\r\\n        Math.cos( this.phi ) * Math.cos( this.theta + PI_HALF ),\\r\\n        Math.sin( this.phi ),\\r\\n        Math.cos( this.phi ) * Math.sin( this.theta + PI_HALF )\\r\\n      );\\r\\n      distance = this.collisionTest( position.clone().normalize() );\\r\\n      position.multiplyScalar( distance );\\r\\n      position.add( this._center );\\r\\n      this.camera.position.copy( position );\\r\\n\\r\\n      if ( this.lat === 90 ) {\\r\\n\\r\\n        this.camera.up.set(\\r\\n          Math.cos( this.theta + Math.PI ),\\r\\n          0,\\r\\n          Math.sin( this.theta + Math.PI )\\r\\n        );\\r\\n\\r\\n      } else if ( this.lat === -90 ) {\\r\\n\\r\\n        this.camera.up.set(\\r\\n          Math.cos( this.theta ),\\r\\n          0,\\r\\n          Math.sin( this.theta )\\r\\n        );\\r\\n\\r\\n      } else {\\r\\n\\r\\n        this.camera.up.set( 0, 1, 0 );\\r\\n\\r\\n      }\\r\\n\\r\\n      this.camera.lookAt( this._center );\\r\\n      this.dispatchEvent( { type: 'updated' } );\\r\\n\\r\\n    },\\r\\n\\r\\n    getFrontAngle: function () {\\r\\n\\r\\n      return PI2 + this.theta;\\r\\n\\r\\n    },\\r\\n\\r\\n    setNearPlainCornersWithPadding: function () {\\r\\n\\r\\n      var near = this.camera.near,\\r\\n          halfFov = this.camera.fov * 0.5,\\r\\n          h = ( Math.tan( THREE.Math.degToRad( halfFov ) ) * near ),\\r\\n          w = h * this.camera.aspect;\\r\\n\\r\\n      this.nearPlainCornersWithPadding = [\\r\\n        new THREE.Vector3( -w - near, -h - near, 0 ),\\r\\n        new THREE.Vector3(  w + near, -h - near, 0 ),\\r\\n        new THREE.Vector3(  w + near,  h + near, 0 ),\\r\\n        new THREE.Vector3( -w - near,  h + near, 0 )\\r\\n      ];\\r\\n\\r\\n    },\\r\\n\\r\\n    setLatLon: function ( lat, lon ) {\\r\\n\\r\\n      this.lat = lat >  90 ?  90 :\\r\\n                 lat < -90 ? -90 :\\r\\n                 lat;\\r\\n      this.lon = lon < 0 ? 360 + lon % 360 : lon % 360;\\r\\n\\r\\n      this.phi   =  THREE.Math.degToRad( this.lat );\\r\\n      this.theta = -THREE.Math.degToRad( this.lon );\\r\\n\\r\\n    },\\r\\n\\r\\n    collisionTest: function ( direction ) {\\r\\n\\r\\n      var i,\\r\\n          distance = this.radius,\\r\\n          nearPlainCorner,\\r\\n          rotationMatrix = new THREE.Matrix4(),\\r\\n          rotationX = new THREE.Matrix4().makeRotationX( this.phi ),\\r\\n          rotationY = new THREE.Matrix4().makeRotationY( this.theta ),\\r\\n          origin,\\r\\n          raycaster,\\r\\n          intersects;\\r\\n\\r\\n      rotationMatrix.multiplyMatrices( rotationX, rotationY );\\r\\n\\r\\n      for ( i = 0; i < 4; i ++ ) {\\r\\n\\r\\n        nearPlainCorner = this.nearPlainCornersWithPadding[ i ].clone();\\r\\n        nearPlainCorner.applyMatrix4( rotationMatrix );\\r\\n\\r\\n        origin = new THREE.Vector3(\\r\\n          this._center.x + nearPlainCorner.x,\\r\\n          this._center.y + nearPlainCorner.y,\\r\\n          this._center.z + nearPlainCorner.z\\r\\n        );\\r\\n        raycaster = new THREE.Raycaster(\\r\\n          origin,           // origin\\r\\n          direction,        // direction\\r\\n          this.camera.near, // near\\r\\n          this.radius       // far\\r\\n        );\\r\\n        intersects = raycaster.intersectObjects( this.rigidObjects );\\r\\n\\r\\n        if ( intersects.length !== 0 && intersects[ 0 ].distance < distance ) {\\r\\n\\r\\n          distance = intersects[ 0 ].distance;\\r\\n\\r\\n        }\\r\\n\\r\\n      }\\r\\n\\r\\n      return distance;\\r\\n\\r\\n    }\\r\\n\\r\\n  };\\r\\n\\r\\n  function onmousedown ( event ) {\\r\\n\\r\\n    this.dispatchEvent( { type: 'mousedown' } );\\r\\n    this._pointerStart.x = event.clientX;\\r\\n    this._pointerStart.y = event.clientY;\\r\\n    this._pointerLast.x = this.lon;\\r\\n    this._pointerLast.y = this.lat;\\r\\n    this.el.removeEventListener( 'mousemove', this._mousedragListener, false );\\r\\n    this.el.addEventListener( 'mousemove', this._mousedragListener, false );\\r\\n//  document.body.className += ' js-TPSCameraDragging';\\r\\n    document.body.classList.add(\\\"js-TPSCameraDragging\\\");\\r\\n\\r\\n  }\\r\\n\\r\\n  function onmouseup () {\\r\\n\\r\\n    this.dispatchEvent( { type: 'mouseup' } );\\r\\n    this.el.removeEventListener( 'mousemove', this._mousedragListener, false );\\r\\n//  document.body.className = document.body.className.replace( / js-TPSCameraDragging/g, '' );\\r\\n    document.body.classList.remove(\\\"js-TPSCameraDragging\\\");\\r\\n\\r\\n  }\\r\\n\\r\\n  function onmousedrag ( event ) {\\r\\n\\r\\n    var w = this.el.offsetWidth,\\r\\n        h = this.el.offsetHeight,\\r\\n        x = ( this._pointerStart.x - event.clientX ) / w * 2,\\r\\n        y = ( this._pointerStart.y - event.clientY ) / h * 2;\\r\\n\\r\\n    this.setLatLon(\\r\\n      this._pointerLast.y + y * this.mouseAccelerationY,\\r\\n      this._pointerLast.x + x * this.mouseAccelerationX\\r\\n    );\\r\\n\\r\\n  }\\r\\n\\r\\n  function onscroll ( event ) {\\r\\n\\r\\n    event.preventDefault();\\r\\n\\r\\n    if ( event.wheelDeltaY ) {\\r\\n\\r\\n      // WebKit\\r\\n      this.radius -= event.wheelDeltaY * 0.05;\\r\\n\\r\\n    } else if ( event.wheelDelta ) {\\r\\n\\r\\n      // IE\\r\\n      this.radius -= event.wheelDelta * 0.05 ;\\r\\n\\r\\n    } else if ( event.detail ) {\\r\\n\\r\\n      // Firefox\\r\\n      this.radius += event.detail;\\r\\n\\r\\n    }\\r\\n\\r\\n    this.radius = Math.max( this.radius, this.minRadius );\\r\\n    this.radius = Math.min( this.radius, this.maxRadius );\\r\\n\\r\\n  }\\r\\n\\r\\n} )( THREE, MW );\\r\\n\""
		},
		{
			"name": "VirtualInput.js",
			"source": "\"/*!\\r\\n * @author yomotsu http://yomotsu.net/\\r\\n * MIT License\\r\\n */\\r\\n\\r\\nvirtualInput = {};\\r\\n\\r\\n( function ( ns ) {\\r\\n\\r\\n    var _ua = function () {\\r\\n        return {\\r\\n            Touch: typeof document.ontouchstart != \\\"undefined\\\",\\r\\n            Pointer: window.navigator.pointerEnabled,\\r\\n            MSPoniter: window.navigator.msPointerEnabled\\r\\n        }\\r\\n    };\\r\\n\\r\\n    ns._start = \\\"pointerdown MSPointerDown touchstart mousedown\\\";\\r\\n    ns._move  = \\\"pointermove MSPointerMove touchmove  mousemove\\\";\\r\\n    ns._end   = \\\"pointerup   MSPointerUp   touchend   mouseup\\\";\\r\\n\\r\\n    ns.Joystick = function ( $container, size, params ) {\\r\\n\\r\\n        Object.assign( this, THREE.EventDispatcher.prototype );  //  THREE.EventDispatcher.prototype.apply( this );\\r\\n\\r\\n        this.angle = 0;\\r\\n        this.position = { x: 0, y: 0 };\\r\\n        this.pointerId = null;\\r\\n        this.isActive = false;\\r\\n\\r\\n        this.width = size * 2;\\r\\n        this.halfWidth = size;\\r\\n\\r\\n        var that = this;\\r\\n        var id = params && params.id ? params.id  : '';\\r\\n        var template = [\\r\\n          '<div class=\\\"gameinput-joystick\\\" id=\\\"' + id + '\\\">',\\r\\n            '<div class=\\\"gameinput-joystick__button\\\"></div>',\\r\\n            '<svg class=\\\"gameinput-frame\\\" width=\\\"' + this.width + '\\\" height=\\\"' + this.width + '\\\" viewbox=\\\"0 0 64 64\\\">',\\r\\n              '<polygon points=\\\"32 19 34 21 30 21\\\" fill=\\\"#fff\\\"></polygon>',\\r\\n              '<polygon points=\\\"45 32 43 34 43 30\\\" fill=\\\"#fff\\\"></polygon>',\\r\\n              '<polygon points=\\\"32 45 34 43 30 43\\\" fill=\\\"#fff\\\"></polygon>',\\r\\n              '<polygon points=\\\"19 32 21 34 21 30\\\" fill=\\\"#fff\\\"></polygon>',\\r\\n              '<circle cx=\\\"32\\\" cy=\\\"32\\\" r=\\\"16\\\" fill=\\\"none\\\" stroke=\\\"#fff\\\" stroke-width=\\\"' + ( this.halfWidth / 64 ) + '\\\"></circle>',\\r\\n            '</svg>',\\r\\n          '</div>'\\r\\n        ].join( '' );\\r\\n\\r\\n        var $win = $( window );\\r\\n        this.$all = $( template );\\r\\n        this.$button = this.$all.find( \\\".gameinput-joystick__button\\\" );\\r\\n        $container.append( this.$all );\\r\\n\\r\\n        this.$all.css({\\r\\n            width:  this.width,\\r\\n            height: this.width\\r\\n        });\\r\\n\\r\\n        this.$button.css({\\r\\n            width:  size * .6,\\r\\n            height: size * .6\\r\\n        });\\r\\n\\r\\n        this.offset = this.$all.offset();\\r\\n        this.buttonRadius = this.$button.width() / 2;\\r\\n        this.frameRadius = size / 2;\\r\\n    //  this.position = { x: 0, y: 0 };\\r\\n\\r\\n        var onbuttondown = function ( event ) {\\r\\n\\r\\n            event.preventDefault();\\r\\n            event.stopPropagation();\\r\\n            \\r\\n            that.dispatchEvent( { type: 'active' } );\\r\\n            that.isActive = true;\\r\\n            \\r\\n            if ( event.originalEvent.pointerId ) {\\r\\n            \\r\\n                that.pointerId = event.originalEvent.pointerId;\\r\\n            \\r\\n            } else if ( event.originalEvent.changedTouches ) {\\r\\n            \\r\\n                that.pointerId = event.originalEvent.changedTouches[ event.originalEvent.changedTouches.length - 1 ].identifier;\\r\\n            \\r\\n            }\\r\\n            \\r\\n            var coordinate = that.getEventCoordinate( event );\\r\\n            \\r\\n            if ( !coordinate ) { return; }\\r\\n            \\r\\n            that.setPosition( coordinate.x, coordinate.y );\\r\\n            \\r\\n            $win.on( ns._move, onbuttonmove );\\r\\n            $win.on( ns._end,  onbuttonup );\\r\\n\\r\\n        };\\r\\n\\r\\n        var onbuttonmove = function ( event ) {\\r\\n\\r\\n            event.preventDefault();\\r\\n            event.stopPropagation();\\r\\n            \\r\\n            var coordinate = that.getEventCoordinate( event );\\r\\n            \\r\\n            if ( !coordinate ) {\\r\\n                return;\\r\\n            }\\r\\n            \\r\\n            that.setPosition( coordinate.x, coordinate.y );\\r\\n\\r\\n        };\\r\\n\\r\\n        var onbuttonup = function ( event ) {\\r\\n\\r\\n            event.stopPropagation();\\r\\n\\r\\n            var wasEventHappend;\\r\\n\\r\\n            if ( event.originalEvent.pointerId ) {\\r\\n\\r\\n                if ( that.pointerId !== event.originalEvent.pointerId ) {\\r\\n                    return;\\r\\n                }\\r\\n\\r\\n            } else if ( event.originalEvent.changedTouches ) {\\r\\n            \\r\\n                for ( i = 0, l = event.originalEvent.changedTouches.length; i < l; i ++ ) {\\r\\n                \\r\\n                    if ( that.pointerId === event.originalEvent.changedTouches[ i ].identifier ) {\\r\\n                        wasEventHappend = true;\\r\\n                        break;\\r\\n                    }\\r\\n                \\r\\n                    if ( !wasEventHappend ) {\\r\\n                        return;\\r\\n                    }\\r\\n                \\r\\n                }\\r\\n            \\r\\n            }\\r\\n\\r\\n            that.dispatchEvent( { type: \\\"disactive\\\" } );\\r\\n            that.isActive = false;\\r\\n            that.setPosition( 0, 0 );\\r\\n            $win.off( ns._move, onbuttonmove );\\r\\n            $win.off( ns._end,  onbuttonup );\\r\\n\\r\\n        };\\r\\n\\r\\n        this.setCSSPosition( 0, 0 );\\r\\n        this.$all.on( ns._start, onbuttondown );\\r\\n\\r\\n        $win.on( \\\"resize\\\", function () {\\r\\n\\r\\n            that.offset = that.$all.offset();\\r\\n\\r\\n        });\\r\\n\\r\\n    };\\r\\n\\r\\n    ns.Joystick.prototype.getLength = function ( x, y ) {\\r\\n        return Math.sqrt( Math.pow( x, 2 ) + Math.pow( y, 2 ) );\\r\\n    };\\r\\n\\r\\n    ns.Joystick.prototype.getAngle = function ( lengthX, lengthY ) {\\r\\n\\r\\n        if ( lengthX === 0 && lengthY === 0 ) {\\r\\n          return this.angle;\\r\\n        }\\r\\n\\r\\n        var angle = Math.atan( lengthY / lengthX );\\r\\n\\r\\n        if ( 0 > lengthX && 0 <= lengthY ) {\\r\\n          //the second quadrant\\r\\n          angle += Math.PI;\\r\\n\\r\\n        } else if ( 0 > lengthX && 0 > lengthY ) {\\r\\n          //the third quadrant\\r\\n          angle += Math.PI;\\r\\n\\r\\n        } else if ( 0 <= lengthX && 0 > lengthY ) {\\r\\n          //the fourth quadrant\\r\\n          angle += Math.PI * 2;\\r\\n\\r\\n        }\\r\\n\\r\\n        this.angle = angle;\\r\\n        return angle;\\r\\n\\r\\n    };\\r\\n\\r\\n    ns.Joystick.prototype.getPointOnRadius = function ( angle ) {\\r\\n\\r\\n        return {\\r\\n          x: Math.cos( angle ),\\r\\n          y: Math.sin( angle )\\r\\n        };\\r\\n\\r\\n    };\\r\\n\\r\\n    ns.Joystick.prototype.getEventCoordinate = function ( event ) {\\r\\n\\r\\n        var x, y, _event = null, i, l;\\r\\n\\r\\n        if ( event.originalEvent.pointerId ) {\\r\\n\\r\\n            if ( this.pointerId === event.originalEvent.pointerId ) {\\r\\n                _event = event.originalEvent;\\r\\n            }\\r\\n\\r\\n        } else if ( event.originalEvent.changedTouches ) {\\r\\n\\r\\n            for ( i = 0, l = event.originalEvent.changedTouches.length; i < l; i ++ ) {\\r\\n                if ( this.pointerId === event.originalEvent.changedTouches[ i ].identifier ) {\\r\\n                  _event = event.originalEvent.changedTouches[ i ];\\r\\n                }\\r\\n            }\\r\\n\\r\\n        } else {\\r\\n\\r\\n            _event = event;\\r\\n\\r\\n        }\\r\\n\\r\\n        if ( _event === null ) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        x = (   ( _event.clientX - this.offset.left ) - this.halfWidth ) / this.halfWidth * 2;\\r\\n        y = ( - ( _event.clientY - this.offset.top  ) + this.halfWidth ) / this.halfWidth * 2;\\r\\n\\r\\n        return { x: x, y: y };\\r\\n\\r\\n    };\\r\\n\\r\\n    ns.Joystick.prototype.setPosition = function ( x, y ) {\\r\\n\\r\\n        this.position.x = x;\\r\\n        this.position.y = y;\\r\\n        var length = this.getLength( x, y );\\r\\n        var angle = this.getAngle( x, y );\\r\\n\\r\\n        if ( 1 >= length ) {\\r\\n            this.setCSSPosition( x, y );\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        var pointOnRadius = this.getPointOnRadius( angle );\\r\\n        this.setCSSPosition( pointOnRadius.x, pointOnRadius.y );\\r\\n\\r\\n    };\\r\\n\\r\\n    ns.Joystick.prototype.setCSSPosition = function ( x, y ) {\\r\\n\\r\\n        this.$button.css( {\\r\\n            left: ( this.halfWidth + x * this.frameRadius - this.buttonRadius ),\\r\\n            top:  ( this.halfWidth - y * this.frameRadius - this.buttonRadius )\\r\\n        });\\r\\n\\r\\n    };\\r\\n\\r\\n    ns.Button = function ( $container, size, params ) {\\r\\n\\r\\n        Object.assign( this, THREE.EventDispatcher.prototype );  // THREE.EventDispatcher.prototype.apply( this );\\r\\n\\r\\n        var that = this;\\r\\n        var id = params && params.id ? params.id  : \\\"\\\";\\r\\n        var label = params.label;\\r\\n        var template = [\\r\\n          '<div class=\\\"gameinput-button\\\" id=\\\"' + id + '\\\">',\\r\\n            '<div class=\\\"gameinput-button__inner\\\">',\\r\\n              label,\\r\\n            '</div>',\\r\\n          '</div>'\\r\\n        ].join( \\\"\\\" );\\r\\n        var $button = $( template );\\r\\n        $container.append( $button );\\r\\n        $button.css( {\\r\\n            width: size,\\r\\n            height: size\\r\\n        });\\r\\n\\r\\n        $button.on( ns._start, function () {\\r\\n            that.dispatchEvent( { type: \\\"press\\\" } );\\r\\n        });\\r\\n\\r\\n    };\\r\\n\\r\\n})( virtualInput );\\r\\n\""
		},
		{
			"name": "AW3D-v0.4.js",
			"source": "\"//  AW3D.js (v0.4.0)\\n\\n\\tAW3D = { VERSION: \\\"0.4.0\\\" };\\n\\n//  Player Holder.\\n    AW3D.PlayerHolder = function ( name ){\\n        var holder = new THREE.Object3D();\\n        holder.position.set( 0, 1, 0 );\\n        holder.name = name || \\\"PLAYER HOLDER\\\";\\n        return holder;\\n    };\\n\\n//  Player Holder Helper.\\n    AW3D.PlayerHolderHelper = function ( name ){\\n        var helper = new THREE.BoxHelper();\\n        helper.name = name || \\\"HOLDER HELPER\\\";\\n        helper.visible = true;\\n        return helper;\\n    };\\n\\n//  Player Controller Direction pointer.\\n    AW3D.DirectionPointer = function ( name ){\\n        var geometry = new THREE.CylinderGeometry( 0, 1, 20, 12 );\\n\\t//  BE CAREFULL: is not \\\"mesh.rotation.y = -Math.PI\\\".\\n        geometry.rotateX( Math.PI / 2 );  //  important!\\n        var material = new THREE.MeshStandardMaterial({color:0x00ff00});\\n        var pointer = new THREE.Mesh(geometry, material);\\n        pointer.position.set(0, 15, 0);\\n        pointer.name = name || \\\"PLAYER DIRECTION\\\";\\n        pointer.visible = true;\\n        return pointer;\\n    };\\n\\n//  Player Sphere.\\n    AW3D.PlayerSphere = function ( name ){\\n        var sphere = new THREE.Mesh(\\n            new THREE.SphereGeometry( 15, 8, 4 ),\\n            new THREE.MeshBasicMaterial({ \\n\\t\\t\\t\\tcolor: 0xff0000,  \\n\\t\\t\\t\\twireframe: true,\\n\\t\\t\\t})\\n        ); \\n        sphere.position.y = 12;\\n        sphere.name = name || \\\"PLAYER SPHERE\\\";\\n        sphere.visible = true;\\n        return sphere;\\n    };\\n\\n//  Player pointer.\\n    AW3D.PlayerPointer = function ( name ){\\n        var geometry = new THREE.CylinderGeometry( 0, 1, 20, 12 );\\n\\t//  BE CAREFULL: is not \\\"mesh.rotation.y = -Math.PI\\\".\\n        geometry.rotateX( Math.PI / 2 );  //  important!\\n        var material = new THREE.MeshNormalMaterial();\\n        var pointer = new THREE.Mesh(geometry, material);\\n        pointer.position.set(0, 40, 0);\\n        pointer.name = name || \\\"PLAYER POINTER\\\";\\n        pointer.visible = true; // debugMode || false;\\n        return pointer;\\n    };\\n\\n\\n//  OutfitManager.js\\n\\n    AW3D.OutfitManager = function(){\\n\\n        var self = this;\\n\\n\\t//  requires \\\"signals.min.js\\\"\\n        var Signal = signals.Signal;\\n        this.added = new Signal();\\n        this.removed = new Signal();\\n        this.changed = new Signal();\\n\\n        this.eventTimeout = undefined;\\n        this.direction = new THREE.Object3D();\\n\\n        this.gender = {\\n            male    : false,\\n            female  : false,\\n            shemale : false,\\n            trans   : false,\\n        };\\n\\n        this.genitals = { \\n            vagina   : false,\\n            penis    : false,\\n            attached : false,\\n        };\\n\\n        this.layers = [\\n            \\\"body\\\",\\n            \\\"head\\\",\\n            \\\"face\\\",\\n            \\\"hairs\\\",\\n            \\\"upper\\\", // chest.\\n            \\\"lower\\\", // hips.\\n            \\\"torso\\\", // (chest & hips).\\n            \\\"arms\\\",\\n            \\\"legs\\\",\\n            \\\"hands\\\",\\n            \\\"feet\\\",\\n            \\\"genitals\\\", \\n            \\\"skeleton\\\",\\n        ];\\n\\n        this.slots = [\\n            \\\"skeleton\\\",\\n            \\\"body\\\",\\n            \\\"hairs\\\",\\n            \\\"eyes\\\",\\n            \\\"glasses\\\",\\n            \\\"hat\\\",\\n            \\\"stockings\\\",\\n            \\\"underwears\\\",\\n            \\\"costume\\\",\\n            \\\"tshirt\\\",\\n            \\\"skirt\\\",\\n            \\\"trousers\\\",\\n            \\\"skirt\\\",\\n            \\\"dress\\\",\\n            \\\"shoes\\\",\\n            \\\"coat\\\",\\n            \\\"penis\\\", \\n            \\\"vagina\\\",\\n        ];\\n\\n        this.stickers = [\\n            \\\"skin\\\",\\n            \\\"makeup\\\",\\n            \\\"tattoo\\\",\\n            \\\"bodypaint\\\",\\n            \\\"neck\\\",\\n            \\\"chest\\\",\\n            \\\"belly\\\",\\n            \\\"upperlimb\\\",\\n            \\\"arm\\\",\\n            \\\"forearm\\\",\\n            \\\"wrist\\\",\\n            \\\"hand\\\",\\n            \\\"lowerlimb\\\",\\n            \\\"thigh\\\",\\n            \\\"leg\\\",\\n            \\\"foot\\\",\\n            \\\"butt\\\",\\n            \\\"back\\\",\\n            \\\"scapula\\\",\\n            \\\"lumbar\\\",\\n        ];\\n\\n        this.attachments = [\\n            \\\"helmet\\\",\\n            \\\"face\\\",\\n            \\\"mask\\\",\\n            \\\"teeth\\\",\\n            \\\"beard\\\",\\n            \\\"eyelash\\\",\\n            \\\"glasses\\\",\\n            \\\"ears\\\",\\n            \\\"belly\\\",\\n            \\\"gun\\\",\\n            \\\"wepon\\\",\\n            \\\"knife\\\",\\n            \\\"sword\\\",\\n            \\\"bistol\\\",\\n            \\\"watch\\\",\\n            \\\"jewelry\\\",\\n            \\\"earings\\\",\\n            \\\"necklace\\\",\\n            \\\"bracelet\\\",\\n            \\\"bag\\\",\\n            \\\"handbag\\\",\\n            \\\"cape\\\",\\n            \\\"coat\\\",\\n            \\\"horn\\\",\\n            \\\"tail\\\",\\n            \\\"penis\\\", \\n        ];\\n\\n        this.AnimationsHandler = [];\\n\\n    //  Outfit.AnimationsHandler is an simple array where local\\n    //  player.outfit keeps the AW3D.AnimationHandler instances.\\n\\n        this.AnimationsHandler.reset = function(){\\n            this.length = 0; // reset array.\\n        };\\n\\n        this.AnimationsHandler.stop = function(){\\n            this.forEach( function( anim ){\\n                if (!!anim ) anim.stop();\\n            });\\n        };\\n\\n        this.AnimationsHandler.jump = function(){\\n            this.forEach( function( anim ){\\n                if (!!anim ) anim.jump();\\n            });\\n        };\\n\\n        this.AnimationsHandler.play = function(){\\n            for (var i in arguments){\\n                var name = arguments[i];\\n                this.forEach( function( anim ){\\n                    if (!!anim ) anim.play(name);\\n                });\\n            }\\n        };\\n\\n        this.AnimationsHandler.weightOff = function(){\\n            for (var i in arguments){\\n                var name = arguments[i];\\n                this.forEach( function( anim ){\\n                    if (!!anim ) anim.weightOff(name);\\n                });\\n            }\\n        };\\n\\n        this.AnimationsHandler.weightOn = function(){\\n            for (var i in arguments){\\n                var name = arguments[i];\\n                this.forEach( function( anim ){\\n                    if (!!anim ) anim.weightOn(name);\\n                });\\n            }\\n        };\\n\\n        this.AnimationsHandler.fadeIn = function(){\\n            for (var i in arguments){\\n                var name = arguments[i];\\n                this.forEach( function( anim ){\\n                    if (!!anim ) anim.fadeIn(name);\\n                });\\n            }\\n        };\\n\\n        this.AnimationsHandler.fadeOut = function(){\\n            for (var i in arguments){\\n                var name = arguments[i];\\n                this.forEach( function( anim ){\\n                    if (!!anim ) anim.fadeOut(name);\\n                });\\n            }\\n        };\\n\\n        this.AnimationsHandler.refresh = function(){\\n\\n            this.stop();\\n            this.fill(null);\\n            this.reset();\\n\\n            var gender = self.getGender();\\n\\n            self.slots.forEach( function(name, i){\\n\\n                if ( !!self[ name ] ){\\n    \\n                    var handler = new AW3D.AnimationHandler( self[ name ], gender );\\n\\n                    self.AnimationsHandler.push( handler );\\n                }\\n            });\\n    \\n            this.play(\\\"idle\\\");\\n        };\\n\\n    //  Outfit EventDispatcher.\\n        Object.assign( this, THREE.EventDispatcher.prototype );  // important!\\n\\n    };\\n\\n\\n    AW3D.OutfitManager.prototype = {\\n\\n        constructor: AW3D.OutfitManager,\\n\\n        refresh: function(){\\n            this.AnimationsHandler.refresh();\\n        },\\n\\n\\n        get: function(){\\n\\n            var results = {};\\n\\n            var _get = ( arg ) => {\\n\\n                if ( typeof( arg ) == \\\"string\\\" ) {\\n                    if ( !!this[arg] ) results[arg] =  this[arg];\\n                }\\n\\n                if ( arg instanceof Array ) {\\n                    arg.forEach( ( key ) => {\\n                        _get( key );\\n                    });\\n                }\\n            };\\n\\n            if ( arguments.length > 0 ){\\n\\n                for (var i in arguments){\\n\\n                    if ( !arguments[i] ) continue;\\n\\n                    _get( arguments[i] );\\n\\n                }\\n\\n            } else {\\n\\n                this.slots.forEach( (name) => { _get( name ); });\\n\\n            }\\n\\n            return results;\\n\\n        },\\n\\n        set: function(){\\n        //  Set \\\"this.slot\\\" but not add to \\\"this.direction\\\".\\n\\n            for (var arg in arguments){\\n\\n                if (!arguments[arg]) continue;\\n\\n                var name = Object.keys(arguments[arg])[0];\\n                var asset = Object.values(arguments[arg])[0];\\n\\n                if ( !name || name == null || !asset ) continue;\\n                if ( !!this[ name ] ) this.remove( name );\\n\\n                this[ name ] = asset;\\n\\n            //  Create an animation handler for this outfit slot.\\n                var handler = new AW3D.AnimationHandler( this[ name ], this.getGender() );\\n\\n            //  Add animation handler.\\n                this.AnimationsHandler.push( handler );\\n\\n            }\\n\\n        //  Send \\\"change\\\" event only when last \\n        //  add has been completed (delay:100ms).\\n\\n            var msec = 100;\\n            clearTimeout( this.eventTimeout );\\n            this.eventTimeout = setTimeout( () => {\\n                this.dispatchEvent( {type:\\\"change\\\"} );\\n                this.changed && this.changed.dispatch();\\n            }, msec);\\n\\n            return this;\\n        },\\n\\n        add: function(){\\n\\n            for (var arg in arguments) {\\n\\n                if (!arguments[arg]) continue;\\n\\n                var name = Object.keys(arguments[arg])[0];\\n                var asset = Object.values(arguments[arg])[0];\\n\\n                if ( !name || name == null || !asset ) continue;\\n                if ( this[ name ] ) this.remove( name );  // important!\\n\\n                this[ name ] = asset;\\n\\n            //  Create an animation handler for this outfit slot.\\n                var handler = new AW3D.AnimationHandler( this[name], this.getGender() );\\n\\n                if ( this.AnimationsHandler.length ) {\\n\\n                //  Copy each action properties of first animation handler.\\n                    var masterHandler = this.AnimationsHandler[0];\\n\\n                    for ( var action in handler.actions ) {\\n\\n                        if ( !action ) break;\\n\\n                        handler.actions[action].loop = masterHandler.actions[action].loop;\\n                        handler.actions[action].weight = masterHandler.actions[action].weight;\\n                        handler.actions[action].timeScale = masterHandler.actions[action].timeScale;\\n                        handler.actions[action].currentTime = masterHandler.actions[action].currentTime;\\n                        handler.actions[action].interpolationType = masterHandler.actions[action].interpolationType;\\n\\n                        if ( masterHandler.actions[action].isPlaying ) {\\n                            handler.actions[action].play( masterHandler.actions[action].currentTime );\\n                        }\\n\\n                    }\\n\\n                //  Add animation handler.\\n                    this.AnimationsHandler.push( handler );\\n\\n                } else {\\n\\n                //  Add animation handler.\\n                    this.AnimationsHandler.push( handler );\\n                //  Play idle.\\n                    this.AnimationsHandler.play(\\\"idle\\\");\\n\\n                }\\n\\n            //  Add outfit item to scene.\\n                this.direction.add( this[ name ] );\\n\\n            }\\n\\n        //  this.AnimationsHandler.refresh(); \\n\\n            this.dispatchEvent( {type:\\\"add\\\"} );\\n            this.added && this.added.dispatch();\\n\\n        //  Send \\\"change\\\" event only when last \\n        //  add has been completed (delay:100ms).\\n\\n            var msec = 100;\\n            clearTimeout( this.eventTimeout );\\n            this.eventTimeout = setTimeout( () => {\\n                this.dispatchEvent( {type:\\\"change\\\"} );\\n                this.changed && this.changed.dispatch();\\n            }, msec);\\n\\n            return this;\\n        },\\n\\n        remove: function(){\\n\\n            if ( arguments.length == 0 ) return;\\n\\n            for (var arg in arguments){\\n\\n                if ( !arguments[arg] ) continue;\\n                if ( !this.slots.includes( arguments[arg] ) ) continue;\\n\\n                var name = arguments[arg];\\n\\n            //  Remove from scene (does not throw error).\\n                this.direction.remove( this[ name ] );\\n\\n            //  Dispose textures.\\n\\n                if ( this[ name ] ) {\\n                    \\n                    if (this[ name ].material && !this[ name ].material.materials) {\\n\\n                    //  Single material.\\n\\n                        Object.keys(this[ name ].material).filter( (key) => {\\n                            return this[ name ].material[ key ] instanceof THREE.Texture;\\n                        }).forEach( (key) => {\\n                            this[ name ].material[ key ].dispose();\\n                        //  DO NOT NULL/DELETE TEXTURE.  important!\\n                        });\\n\\n                        this[ name ].material.dispose();\\n\\n                    } else if (this[ name ].material.materials && this[ name ].material.materials.length) {\\n\\n                    //  Multimaterial.\\n\\n                        this[ name ].material.materials.forEach(function(material){\\n\\n                            Object.keys(material).filter(function(key){\\n                                return material[ key ] instanceof THREE.Texture;\\n                            }).forEach(function(key){\\n                                material[ key ].dispose();\\n                            //  DO NOT NULL/DELETE TEXTURE. important!\\n                            });\\n\\n                            material.dispose();\\n\\n                        });\\n\\n                    }\\n\\n                }\\n\\n            //  Dispose geometry.\\n                if ( this[ name ] ) this[ name ].geometry.dispose();\\n\\n            //  Dispose bones texture. !important\\n                if ( this[ name ] && this[ name ].skeleton  )\\n                    this[ name ].skeleton.boneTexture.dispose();\\n\\n            //  Remove the animation handler.\\n\\n                if ( this.AnimationsHandler.length ) {\\n\\n                //  Find handler index.\\n                    var index = this.AnimationsHandler.findIndex((handler) => {\\n                        return handler.mesh == this[ name ];\\n                    });\\n\\n                    //  Keep in mind \\\"splice()\\\" uses \\\"zero\\\" \\n                    //  and \\\"negative\\\" indexes also. // danger!\\n                    //  debugMode && console.log({\\\"index\\\": index});\\n\\n                    if ( index != undefined && index > -1 ) {\\n\\n                    //  Get and remove handler from AnimationsHandler.\\n                        var handler = this.AnimationsHandler.splice(index, 1)[0];\\n\\n                    //  Stop handler animations.\\n                        handler.stop();\\n\\n                    }\\n\\n                }\\n\\n            //  Delete slot.\\n                delete this[ name ];\\n\\n            }\\n\\n        //  this.AnimationsHandler.refresh(); \\n\\n            this.dispatchEvent( {type:\\\"remove\\\"} );\\n            this.removed && this.removed.dispatch();\\n\\n        //  Send \\\"change\\\" event only when last \\n        //  remove has been completed (delay:100ms).\\n\\n            var msec = 100;\\n            clearTimeout( this.eventTimeout );\\n            this.eventTimeout = setTimeout( () => {\\n                this.dispatchEvent( {type:\\\"change\\\"} );\\n                this.changed && this.changed.dispatch();\\n            }, msec);\\n\\n            return this;\\n        },\\n\\n        removeAll: function() { \\n\\n            this.slots.forEach( ( name ) => {\\n                if ( this[ name ] ) this.remove( name );\\n            });\\n\\n            return this;\\n\\n        },\\n\\n        removeFromScene: function(){\\n\\n            if ( arguments.length == 0 ) {\\n\\n                this.slots.forEach( ( name ) => {\\n                    this.remove( name );\\n                });\\n\\n            } else {\\n\\n                for (var arg in arguments){\\n                    this.remove( arguments[arg] );\\n                }\\n            }\\n\\n            return this;\\n        },\\n\\n        removeTexture: function( outfit, map, index ){\\n\\n            //  outfit: outfit slot name (e.g \\\"body\\\", \\\"hair\\\", \\\"dress\\\", etc.)\\n            //  map   : material map name (e.g. \\\"map\\\", \\\"bumpMap\\\", \\\"normalMap\\\", etc.)\\n            //  index : material index of multimaterial (\\\"null\\\" for simple material).\\n\\n            if ( !this[ outfit ] ) return;\\n            if ( !this[ outfit ].material ) return;\\n\\n            //  Material.\\n\\n            if ( index == null || isNaN(index) || typeof(index) != \\\"number\\\" ) {\\n\\n                if ( !this[ outfit ].material[ map ] ) return;\\n\\n                this[ outfit ].material[ map ].dispose();\\n                this[ outfit ].material[ map ] = null;\\n                this[ outfit ].material.needsUpdate = true;\\n\\n                return;\\n            }\\n\\n            //  MultiMaterial.\\n\\n            if ( typeof(index) == \\\"number\\\" && index > -1 ) {\\n\\n                if ( !this[ outfit ].material.materials ) return;\\n                if ( !this[ outfit ].material.materials[ index ] ) return;\\n                if ( !this.body.material.materials[ index ][ map ] ) return;\\n\\n                this[ outfit ].material.materials[ index ][ map ].dispose();\\n                this[ outfit ].material.materials[ index ][ map ] = null;\\n                this[ outfit ].material.materials[ index ].needsUpdate = true;\\n\\n                return;\\n            }\\n        },\\n\\n        setGender: function( gender ){\\n\\n            var self = this;\\n\\n            Object.keys(this.gender).forEach( function( name ){\\n                self.gender[ name ] = ( name == gender );\\n            });\\n\\n        //  Outfit direction scale. (object3D)\\n\\n            switch ( this.getGender() ){\\n\\n                case \\\"male\\\":\\n                    this.direction.scale.set(1, 1, 1);\\n                    break;\\n\\n                case \\\"female\\\":\\n                    this.direction.scale.set(0.95, 0.95, 0.95);\\n                    break;\\n\\n                default:\\n                    this.direction.scale.set(1, 1, 1);\\n            }\\n\\n            this.AnimationsHandler.refresh();\\n\\n            return this;\\n        },\\n\\n        getGender: function(){\\n\\n            var self = this;\\n\\n            if (arguments.length > 0){\\n\\n                return self.gender[ arguments[0] ];\\n\\n            } else {\\n\\n                return Object.keys(this.gender).find( function( name ){\\n                    return self.gender[ name ];\\n                });\\n\\n            }\\n        },\\n\\n        resetGender: function(){\\n\\n            var self = this;\\n\\n            Object.keys(this.gender).forEach( function( name ){\\n                self.gender[ name ] = false;\\n            });\\n\\n            this.direction.scale.set(1, 1, 1);\\n            this.AnimationsHandler.refresh();\\n\\n            return this;\\n        },\\n\\n        getPose: function( name ){\\n\\n            var name = name || \\\"body\\\";\\n            if ( !this[ name ] ) return;\\n            if ( !this.slots.includes( name ) ) return;\\n\\n            var pose = [];\\n\\n            for (var i in this[ name ].skeleton.bones) {\\n                var key = {}; // {\\\"pos\\\":[], \\\"rot\\\":[], \\\"scl\\\":[]};\\n                key.pos = this[ name ].skeleton.bones[i].position.toArray();\\n                key.rot = this[ name ].skeleton.bones[i].quaternion.toArray();\\n                key.scl = this[ name ].skeleton.bones[i].scale.toArray();\\n                pose.push(key);\\n            }\\n\\n            return pose;\\n        },\\n\\n\\n        toJSON: function(){\\n\\n            var data = {};\\n\\n            if ( arguments.length == 0 ) {\\n\\n                for (var i = 0; i < this.slots.length; i++) {\\n\\n                    var name = this.slots[i];\\n\\n                    if ( !name ) continue;\\n                    if ( !this[ name ] ) continue;\\n                    if ( !this.slots.includes( name ) ) continue;\\n\\n                    data[ name ] = {};\\n                    data[ name ].name      = name;\\n                    data[ name ].visible   = this[ name ].visible;\\n                    data[ name ].scale     = this[ name ].scale.toArray();\\n                    data[ name ].geometry  = this[ name ].geometry.sourceFile;\\n                    data[ name ].material  = materialtoJSON( this[ name ].material );\\n\\n                }\\n\\n            } else {\\n\\n                for (var i = 0; i < arguments.length; i++){\\n\\n                    var name = arguments[i];\\n\\n                    if ( !name ) continue;\\n                    if ( !this[ name ] ) continue;\\n                    if ( !this.slots.includes( name ) ) continue;\\n\\n                    data[ name ] = {};\\n                    data[ name ].name      = name;\\n                    data[ name ].visible   = this[ name ].visible;\\n                    data[ name ].scale     = this[ name ].scale.toArray();\\n                    data[ name ].geometry  = this[ name ].geometry.sourceFile;\\n                    data[ name ].material = materialtoJSON( this[ name ].material );\\n\\n                }\\n\\n            }\\n\\n            if ( this.getGender() ) \\n                data.gender = this.getGender();\\n\\n            var data = JSON.stringify( data );\\n\\n            if ( data === \\\"{}\\\" ) \\n                return null;\\n            else \\n                return JSON.parse( data );\\n\\n        },\\n\\n    //  fromJSON (v2.1).\\n\\n        fromJSON: function( json ){\\n\\n\\t\\t//  Make a copy of json. important!\\n\\n            if ( typeof(json) == \\\"object\\\" ) {\\n\\n                try {\\n\\n                    var json = JSON.stringify( json ); // string copy of json.\\n\\n                } catch(err) { throw err; }\\n\\n            }\\n\\n\\t\\t//  requires \\\"validation.js\\\".\\n\\n            if ( typeof(json) == \\\"string\\\" ) {\\n\\n                if ( !validator.isJSON( json ) ) {\\n                    throw \\\"Validation Error: json not valid\\\";\\n                }\\n\\n            } else {\\n\\n\\t\\t\\t\\tthrow \\\"Type Error: json is not string type.\\\";\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t\\n\\t\\t\\tvar json = JSON.parse( json ); // (now is a json copy).\\n\\n\\n            var self = this;\\n\\n        //  Set gender first.\\n\\n            this.removeAll();          // important!\\n            var gender = json.gender;  // important!\\n            this.setGender( gender );  // important!\\n\\n        //  Clear gender of json.\\n            delete json.gender; // (is a copy of json).\\n\\n        //  ORDER DOES MATTER for transparency:\\n        //   Order in localPlayer.outfit.direction.children array DOES MATTER.\\n        //  So we must deliver the outfit.direction.children array with the following order:\\n        //  [skeleton, body, eyes, hairs, stockings, underwears, tshirt, trousers, costume, dress, shoes, coat]\\n\\n            var orderMap = [];\\n\\n            (function(){\\n                if (json.skeleton) orderMap.push(\\\"skeleton\\\");\\n                if (json.body) orderMap.push(\\\"body\\\");\\n                if (json.eyes) orderMap.push(\\\"eyes\\\");\\n                if (json.glasses) orderMap.push(\\\"glasses\\\");\\n                if (json.hairs) orderMap.push(\\\"hairs\\\");\\n                if (json.hat) orderMap.push(\\\"hat\\\");\\n                if (json.stockings) orderMap.push(\\\"stockings\\\");\\n                if (json.underwears) orderMap.push(\\\"underwears\\\");\\n                if (json.costume) orderMap.push(\\\"costume\\\");\\n                if (json.tshirt) orderMap.push(\\\"tshirt\\\");\\n                if (json.trousers) orderMap.push(\\\"trousers\\\");\\n                if (json.skirt) orderMap.push(\\\"skirt\\\");\\n                if (json.dress) orderMap.push(\\\"dress\\\");\\n                if (json.shoes) orderMap.push(\\\"shoes\\\");\\n                if (json.coat) orderMap.push(\\\"coat\\\");\\n            })();\\n\\n            debugMode && console.log({\\\"orderMap\\\": orderMap});\\n\\n            var outfit = {};\\n\\t\\t\\tvar promises = [];\\n\\n            for (var i = 0; i < orderMap.length; i++){\\n\\n\\t\\t\\t\\tpromises.push(\\n\\t\\t\\t\\t\\tnew Promise(function(resolve, reject){\\n\\n\\t\\t\\t\\t\\t\\tvar object = {};\\n\\t\\t\\t\\t\\t\\tvar sortIndex = i;\\n                        var key = orderMap[i];\\n\\n\\t\\t\\t\\t\\t\\tobject.name      = json[ key ].name;\\n\\t\\t\\t\\t\\t\\tobject.visible   = json[ key ].visible;\\n\\t\\t\\t\\t\\t\\tobject.material  = json[ key ].material;\\n\\t\\t\\t\\t\\t\\tobject.geometry  = json[ key ].geometry;  // (url).\\n\\n\\t\\t\\t\\t\\t//  Scale.\\n\\t\\t\\t\\t\\t\\tvar vector = new THREE.Vector3();\\n\\t\\t\\t\\t\\t\\tobject.scale = vector.fromArray( json[ key ].scale );\\n\\n\\t\\t\\t\\t\\t//  Material.\\n\\t\\t\\t\\t\\t\\tvar material = materialfromJSON( object.material );\\n\\n\\t\\t\\t\\t\\t//  Geometry: cache first.\\n\\t\\t\\t\\t\\t\\tcaches.match( object.geometry ).then(function(response){\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( !response ) \\n\\t\\t\\t\\t\\t\\t\\t\\tthrow \\\"geometry not found! Trying to fetch geometry...\\\";\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\treturn response;\\n\\n\\t\\t\\t\\t\\t\\t}).catch(function(err){\\n                            console.error(err);\\n\\n\\t\\t\\t\\t\\t\\t\\treturn caches.open(\\\"geometries\\\").then(function(cache){\\n\\t\\t\\t\\t\\t\\t\\t\\treturn cache.add( object.geometry ).then(function(){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn cache.match( object.geometry ).then(function(response){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn response;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t}).then(function(response){\\n\\n\\t\\t\\t\\t\\t\\t\\tif (!response) throw \\\"None response returned!\\\";\\n\\n\\t\\t\\t\\t\\t\\t\\treturn response.json();\\n\\n\\t\\t\\t\\t\\t\\t}).then(function( gmtjson ){\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( !gmtjson ) throw \\\"None json returned fromJSON!\\\";\\n\\n\\t\\t\\t\\t\\t\\t\\tvar loader = new THREE.JSONLoader();\\n\\t\\t\\t\\t\\t\\t\\tvar geometry = loader.parse( gmtjson ).geometry;\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry.name = gmtjson.name;\\n\\t\\t\\t\\t\\t\\t\\tgeometry.computeFaceNormals();\\n\\t\\t\\t\\t\\t\\t\\tgeometry.computeVertexNormals();\\n\\t\\t\\t\\t\\t\\t\\tgeometry.computeBoundingBox();\\n\\t\\t\\t\\t\\t\\t\\tgeometry.computeBoundingSphere();\\n\\t\\t\\t\\t\\t\\t\\tgeometry.sourceFile = object.geometry;  // important!\\n\\n\\t\\t\\t\\t\\t\\t\\tvar skinned = new THREE.SkinnedMesh( geometry, material );\\n\\n\\t\\t\\t\\t\\t\\t\\tskinned.renderDepth = 1;\\n\\t\\t\\t\\t\\t\\t\\tskinned.frustumCulled = false;\\n\\t\\t\\t\\t\\t\\t\\tskinned.position.set( 0, 0, 0 );\\n\\t\\t\\t\\t\\t\\t\\tskinned.rotation.set( 0, 0, 0 );\\n\\t\\t\\t\\t\\t\\t\\tskinned.scale.copy( object.scale );\\n\\t\\t\\t\\t\\t\\t\\tskinned.castShadow = true;\\n\\t\\t\\t\\t\\t\\t\\tskinned.name = object.name;\\n\\t\\t\\t\\t\\t\\t\\tskinned.sortIndex = sortIndex;\\n\\n\\t\\t\\t\\t\\t\\t\\tvar obj = {};\\n\\t\\t\\t\\t\\t\\t\\tobj[ key ] = skinned;\\n\\t\\t\\t\\t\\t\\t\\tresolve( obj );\\n\\n\\t\\t\\t\\t\\t\\t\\toutfit[ key ] = skinned;\\n\\n\\t\\t\\t\\t\\t\\t}).catch(function(err){\\n                            resolve( null );\\n\\t\\t\\t\\t\\t\\t\\tconsole.error(err);\\n\\t\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t\\t}) // end of promise,\\n\\t\\t\\t\\t); // end push.\\n\\t\\t\\t}// end for.\\n\\n            debugMode && console.log(\\\"promises:\\\", promises);\\n\\n\\t\\t\\treturn Promise.all(promises).then(function(results){\\n                debugMode && console.log(\\\"results:\\\", results);\\n\\n\\t\\t\\t//  cleanup.\\n\\t\\t\\t\\tvar results = results.filter(Boolean); // important!\\n                debugMode && console.log(\\\"cleaned results:\\\", results);\\n\\n\\t\\t\\t//  add outfit.\\n\\t\\t\\t\\twhile (results.length) {\\n\\t\\t\\t\\t\\tself.add( results.shift() );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}).then(function(){\\n                debugMode && console.log(\\\"outfit:\\\", outfit);\\n\\t\\t\\t\\treturn outfit;\\n\\t\\t\\t});\\n\\n\\t\\t},\\n\\n\\n\\t//  Outfit DNA is an object that contains the outfit data that needed to\\n\\t//  create the player oufit anywhere remotly. It is player outfit assets\\n\\t//  in transfered structure ( aka like .toJSON() ).\\n\\t//\\n\\t//  .toDNA(); .fromDNA(dna); Usage:\\n\\t//      dna = localPlayer.outfit.toDNA();\\n\\t//      player = new Player();\\n\\t//      player.outfit = new AW3D.Outfit(player);\\n\\t//      player.outfit.fromDNA( dna );\\n\\n\\t//\\t.toDNA, .fromDNA (v2).\\n\\t//\\trequires \\\"rawinflate.js, rawdeflate.js, and validator.js\\\"\\n\\n        toDNA: function(){\\n\\n            return encode( JSON.stringify( this.toJSON() ) );\\n\\n            function encode( string ) {\\n                if ( !!window.RawDeflate ) {\\n                    return window.btoa( RawDeflate.deflate( string ) );\\n                } else {\\n                    return string;\\n                }\\n            }\\n\\n        },\\n\\n        fromDNA: function( dna ){\\n\\n            //  Validation.\\n\\n            if ( typeof(dna) == \\\"string\\\" ) {\\n\\n                if ( validator.isBase64( dna ) ) {\\n\\n                    return new Promise( (resolve, reject) => {\\n                        var json = JSON.parse( decode( dna ) );\\n                        resolve( this.fromJSON(json) );\\n                    }).catch( function(err){ \\n                        console.error(err);\\n                        throw err; \\n                    });\\n\\n                } else if ( validator.isJSON( dna ) ) {\\n\\n                    return new Promise( (resolve, reject) => {\\n                        var json = JSON.parse( dna );\\n                        resolve( this.fromJSON(json) );\\n                    }).catch( function(err){ \\n                        console.error(err);\\n                        throw err; \\n                    });\\n\\n                } else {\\n\\n                    return new Promise( (resolve, reject) => {\\n                        var err = \\\"DNA is not valid.\\\";\\n                        console.error( \\\"Error: \\\" + err );\\n                        reject( \\\"Validation Error: \\\" + err );\\n                        //  throw Error( err );\\n                    });\\n\\n                }\\n\\n            } else {\\n\\n                return new Promise( (resolve, reject) => {\\n                    var err = \\\"Unsupported DNA type: \\\" + typeof(dna);\\n                    console.error( \\\"Error: \\\" + err );\\n                    reject( \\\"Validation Error: \\\" + err );\\n                    //  throw Error( err );\\n                });\\n\\n            }\\n\\n            function decode( string ) {\\n                if ( !!window.RawDeflate ) {\\n                    return RawDeflate.inflate( window.atob( string ) );\\n                } else {\\n                    return string;\\n                }\\n            }\\n\\n        },\\n\\n\\n\\t};\\n\\n\\n//  AW3D AnimationHandler.js\\n\\n//  Reset THREE.AnimationHandler.animations array.\\n    THREE.AnimationHandler.animations.length = 0;\\n    AnimationManager = THREE.AnimationHandler;\\n\\n    AW3D.AnimationHandler = function ( mesh, gender ) {\\n\\n        this.mesh = mesh;\\n        this.gender = gender; // important!\\n        this.actions = {};\\n\\n    //  This create the animations of skinned mesh. \\n        this.reloadActions(); // important!\\n\\n    };\\n\\n\\n    AW3D.AnimationHandler.prototype = {\\n\\n        constructor: AW3D.AnimationHandler,\\n\\n        findAction: function(action){\\n        //  returns new array with resutls.\\n            return THREE.AnimationHandler.animations.filter( function(animation){\\n                return (animation == action); // boolean.\\n            }); \\n        },\\n\\n        findByUuid: function( name ){\\n        //  returns new array with resutls.\\n            return THREE.AnimationHandler.animations.filter( function(animation){\\n                return (animation.uuid == this.actions[ name ].uuid); // boolean.\\n            });\\n        },\\n\\n        findByName: function( name ){\\n        //  returns new array with resutls.\\n            return THREE.AnimationHandler.animations.filter( function(animation){\\n                return (animation.data.name == name); // boolean.\\n            });\\n        },\\n\\n        getCurrentAction: function(){\\n        //  returns current playing action name.\\n            for (var name in this.actions) {\\n                if ( !name ) return;\\n                var action = this.actions[ name ];\\n                if ( action.isPlaying ) {\\n                    return name;\\n                }\\n            }\\n        },\\n\\n    //  To stop an animation, find the animation in\\n    //  THREE.AnimationHandler.animations and stop it from there.\\n\\n        stop: function stop(){\\n            var self = this;\\n            Object.keys( self.actions ).forEach(function(name, i){\\n                var action = self.actions[name];\\n                self.findAction(action).forEach(function(animation){\\n                    animation.stop();\\n                });\\n            });\\n        },\\n\\n    //  To delete an action, stop the animation in \\n    //  THREE.AnimationHandler.animations and then delete it from this.actions.\\n\\n        delete: function( name ){\\n            var action = this.actions[ name ];\\n            this.findAction( action ).forEach(function(animation){\\n                animation.stop();\\n            });\\n            delete this.actions[ name ];\\n        },\\n\\n        reset: function reset(){\\n            for (var i in arguments){\\n                var name = arguments[i];\\n                this.actions[ name ].weight = 1;\\n                this.actions[ name ].timeScale = 1;\\n                this.actions[ name ].currentTime = 0;\\n            }\\n        },\\n\\n        resetAll: function(){\\n            var self = this;\\n            Object.keys( self.actions ).forEach(function(name, i){\\n                self.reset( name );\\n            });\\n        },\\n\\n        deleteAll: function(){\\n            var self = this;\\n            Object.keys( self.actions ).forEach(function(name, i){\\n                self.delete[ name ]\\n            });\\n        },\\n\\n        play: function play(){\\n            for (var i in arguments){\\n                var name = arguments[i];\\n                if ( !this.actions[ name ] ) return;\\n                this.actions[ name ].play(0);\\n            }\\n        },\\n\\n    //  To pause an animation, find the animation \\n    //  in THREE.AnimationHandler.animations and set timeScale to 0.\\n    \\n        pause: function pause(){\\n            for (var i in arguments){\\n                var name = arguments[i];\\n                var action = this.actions[ name ];\\n                this.findAction( action ).forEach(function(animation){\\n                    animation.timeScale = 0;\\n                });\\n            }\\n        },\\n\\n    //  To unpause an animation, find the animation \\n    //  in THREE.AnimationHandler.animations and set timeScale to 1.\\n\\n        continue: function(){\\n            for (var i in arguments){\\n                var name = arguments[i];\\n                var action = this.actions[ name ];\\n                this.findAction( action ).forEach(function(animation){\\n                    animation.timeScale = 1;\\n                });\\n            }\\n        },\\n\\n        weightOff: function(){\\n            for (var i in arguments){\\n                var name = arguments[i];\\n                var action = this.actions[ name ];\\n                this.findAction( action ).forEach(function(animation){\\n                    animation.weight = 0;\\n                });\\n            }\\n        },\\n\\n        weightOn: function(){\\n            for (var i in arguments){\\n                var name = arguments[i];\\n                var action = this.actions[ name ];\\n                this.findAction( action ).forEach(function(animation){\\n                    animation.weight = 1;\\n                });\\n            }\\n        },\\n\\n        fadeIn: function(){\\n            var fades = [];\\n            for (var i in arguments){\\n                var name = arguments[i];\\n                var animation = this.actions[ name ];\\n                fades.push(function fade(){\\n                    var requestId = requestAnimationFrame( fade );\\n                    animation.timeScale = 1; // !important\\n                    animation.weight += ( 0.05 * (1 - animation.weight) );\\n                    animation.play(animation.currentTime, animation.weight);\\n                    debugMode && console.log( \\\"fadeIn: \\\", round(animation.weight, 3) );\\n                    if ( round(animation.weight, 3) > 0.9 ){\\n                        cancelAnimationFrame( requestId );\\n                        animation.weight = 1;\\n                        animation.timeScale = 1;\\n                        animation.play(animation.currentTime, 1);\\n                    }\\n                });\\n            }\\n\\n        //  Call all functions in fades.\\n            while (fades.length){ \\n                fades.shift().call(); \\n            }\\n        },\\n\\n        fadeOut: function(){\\n            var fades = [];\\n            for (var i in arguments){\\n                var name = arguments[i];\\n                var action = this.actions[ name ];\\n                this.findAction( action ).forEach(function(animation){\\n                    fades.push(function fade(){\\n                        var requestId = requestAnimationFrame( fade );\\n                        animation.timeScale = 1; // !important\\n                        animation.weight -= ( 0.05 * animation.weight );\\n                        animation.play(animation.currentTime, animation.weight);\\n                        debugMode && console.log( \\\"fadeOut:\\\", round(animation.weight, 3) );\\n                        if ( round(animation.weight, 3) < 0.1 ){\\n                            cancelAnimationFrame( requestId );\\n                            animation.stop();\\n                            animation.weight = 1;\\n                            animation.timeScale = 1;\\n                        }\\n                    });\\n                });\\n            }\\n\\n        //  Call all functions in fades.\\n            while (fades.length){ \\n                fades.shift().call(); \\n            }\\n        },\\n\\n        idle: function idle(){\\n            this.actions.idle.play(0);\\n        },\\n\\n        jump: function jump(){\\n            this.actions.jump.play(0);\\n        },\\n\\n        run: function run(){\\n            this.actions.run.play(0);\\n        },\\n\\n        walk: function walk(){\\n            this.actions.walk.play(0);\\n        },\\n\\n    //  ------------------------------------------------------  //\\n    //  This create the animations of skinned mesh. important!  //\\n    //  ------------------------------------------------------  //\\n\\n        loadAction: function(){\\n\\n            for ( var i in arguments ) {\\n\\n                var name = arguments[i];\\n\\n                var data;\\n\\n                switch (this.gender) {\\n\\n                    case \\\"male\\\":\\n                        data = MaleAnimations[ name ];\\n                    break;\\n\\n                    case \\\"female\\\":\\n                        data = FemaleAnimations[ name ];\\n                    break;\\n\\n                    default:\\n                        data = Animations[ name ];\\n                    break;\\n                }\\n            \\n                var action = new THREE.Animation( this.mesh, data );\\n                action.uuid = THREE.Math.generateUUID();\\n                action.weight = 1;\\n                action.timeScale = 1;\\n                action.currentTime = 0;\\n                this.actions[ name ] = action;\\n            }\\n\\n        },\\n\\n        reloadActions: function(){\\n\\n            var self = this;\\n\\n            this.stop();\\n            this.deleteAll();\\n            this.actions = {};\\n\\n            if (this.actions.jump) this.actions.jump.loop = false;\\n\\n            if (MaleAnimations && this.gender && this.gender == \\\"male\\\") {\\n                Object.keys( MaleAnimations ).forEach(function(name, i){\\n                    self.loadAction( name );\\n                });\\n\\n                return;\\n            }\\n            \\n            if (FemaleAnimations && this.gender && this.gender == \\\"female\\\") {\\n                Object.keys( FemaleAnimations ).forEach(function(name, i){\\n                    self.loadAction( name );\\n                });\\n\\n                return;\\n            }\\n\\n            if ( Animations && !this.gender ) {\\n                Object.keys( Animations ).forEach(function(name, i){\\n                    self.loadAction( name );\\n                });\\n\\n                return;\\n            }\\n\\n            if ( this.gender && this.gender != \\\"male\\\" && this.gender != \\\"female\\\" ){\\n                console.warn( \\\"AW3D.AnimationHandler: reloadActions(\\\" \\n\\t\\t\\t\\t\\t+ this.gender + \\\"): Gender exists but is not male or female.\\\"\\n                );\\n\\n                return;\\n            }\\n\\n        },\\n\\n\\t};\\n\\n\\n//  MATERIAL TO JSON.\\n\\n//  materialtoJson.js (v1.6)\\n//  Return a promise with the \\n//  material json object resolved.\\n\\n    function materialtoJSON( material ){\\n\\n    //  MULTIMATERIAL.\\n\\n        if ( material.type == \\\"MultiMaterial\\\" || material.materials ) {\\n\\n        //  multimaterial to json.\\n\\n            var multjson = {\\n\\n                _id: \\\"\\\",\\n                type: material.type,\\n                uuid: material.uuid || THREE.Math.generateUUID(),\\n\\n            };\\n\\n\\n        //  materials to json.\\n\\n            multjson.materials = [];\\n\\n            for ( var i = 0; i < material.materials.length; i++ ){\\n\\n                multjson.materials.push( materialtoJSON( material.materials[i] ) );\\n\\n            }\\n\\n\\n            debugMode && console.log( \\\"multimaterial to json:\\\", multjson );\\n\\n            return multjson;\\n\\n        }\\n\\n\\n    //  MATERIAL.\\n\\n        var json = {};\\n\\n        for ( var name in material ){\\n\\n            if ( material[ name ] == undefined ) continue;         // important!\\n            if ( material[ name ] instanceof Function ) continue;  // important!\\n            if ( typeof(material[name]) === \\\"function\\\" ) continue; // important!\\n\\n            switch( name ){\\n\\n                case \\\"defines\\\":\\n                case \\\"program\\\":\\n                case \\\"_listeners\\\":\\n                case \\\"needsUpdate\\\":\\n                case \\\"_needsUpdate\\\":\\n                case \\\"__webglShader\\\":\\n                break;\\n\\n\\n            //  name, _id, uuid.\\n\\n                case \\\"name\\\":\\n                    json.name = material.name;\\n                break;\\n\\n                case \\\"_id\\\":\\n                    json._id = material._id || ObjectId();\\n                break;\\n\\n                case \\\"uuid\\\":\\n                    json.uuid = material.uuid || THREE.Math.generateUUID();\\n                break;\\n\\n\\n            //  texture to json.\\n\\n                case \\\"map\\\":\\n                case \\\"bumpMap\\\":\\n                case \\\"alphaMap\\\":\\n                case \\\"normalMap\\\":\\n                case \\\"emissiveMap\\\":\\n                case \\\"displacementMap\\\":\\n                case \\\"metalnessMap\\\":\\n                case \\\"roughnessMap\\\":\\n                case \\\"specularMap\\\":\\n                case \\\"lightMap\\\":\\n                case \\\"aoMap\\\":\\n\\n                    if ( !(material[ name ] instanceof THREE.Texture) ) {\\n                        throw name + \\\" is not instance of THREE.Texture\\\";\\n                    }\\n\\n                    json[ name ] = texturetoJSON( material[ name ] );\\n\\n                break;\\n\\n\\n            //  three color to hex.\\n\\n                case \\\"color\\\":\\n                case \\\"emissive\\\":\\n                case \\\"specular\\\":\\n\\n                    if ( !(material[ name ] instanceof THREE.Color) ) {\\n                        throw name + \\\" is not instance of THREE.Color\\\";\\n                    }\\n\\n                    json[ name ] = material[ name ].getHex();\\n\\n                break;\\n\\n\\n            //  vector2 to array.\\n\\n                case \\\"normalScale\\\":\\n\\n                    if ( !(material[ name ] instanceof THREE.Vector2) ) {\\n                        throw name + \\\" is not instance of THREE.Vector2\\\";\\n                    }\\n\\n                    json[ name ] = material[ name ].toArray();\\n\\n                break;\\n\\n\\n\\n                case \\\"envMap\\\":\\n                    //  TODO: cube texture.\\n                break;\\n\\n\\n                default:\\n                    json[ name ] = material[ name ];\\n                break;\\n\\n            }\\n\\n        }\\n\\n        return json;\\n    }\\n\\n\\n//  TEXTURE TO JSON.\\n//  Return a promise resolved \\n//  with the texture json object.\\n\\n    function texturetoJSON( texture ){\\n\\n        var json = {};\\n\\n        for (var name in texture ){\\n\\n            if ( texture[ name ] == undefined ) continue;\\n            if ( texture[ name ] instanceof Function ) continue;\\n            if ( typeof(texture[name]) === \\\"function\\\" ) continue;\\n\\n            switch (name){\\n\\n                case \\\"_listeners\\\":\\n                break;\\n\\n\\n            //  uuid.\\n\\n                case \\\"uuid\\\":\\n                    json[ name ] = texture[ name ] || THREE.Math.generateUUID();\\n                break;\\n\\n\\n            //  vector2 to array.\\n\\n                case \\\"offset\\\":\\n                case \\\"repeat\\\":\\n                    json[ name ] = texture[ name ].toArray();\\n                break;\\n\\n\\n            //  image to json.\\n\\n                case \\\"image\\\":\\n                    json[ name ] = texture.sourceFile || getDataURL( texture[ name ] ); // important!\\n                break;\\n\\n\\n                default:\\n                    json[ name ] = texture[ name ];\\n                break;\\n\\n            }\\n\\n        }\\n\\n        return json;\\n    }\\n\\n\\n//  IMAGE TO JSON.\\n//  Return an image object.\\n\\n    function imagetoJSON( image ){\\n\\n        return {\\n            uuid: THREE.Math.generateUUID(),\\n            src: image.src || getDataURL( image ),\\n        };\\n\\n    }\\n\\n\\n//  TEXTURE IMAGE TO JSON.\\n//  Return an image object.\\n\\n    function textureImagetoJSON( texture ){\\n\\n        return {\\n            uuid: THREE.Math.generateUUID(),\\n            src: texture.sourceFile || texture.image.src || getDataURL( texture.image )\\n        };\\n\\n    }\\n\\n\\n//  MATERIAL FROM JSON.\\n//  materialfromJson.js (v1.6)\\n//  Return a promise with the material resolved.\\n\\n    function materialfromJSON( json ){\\n\\n   //  MULTIMATERIAL.\\n\\n       if ( json.type == \\\"MultiMaterial\\\" ) {\\n\\n\\n           var materials = [];\\n\\n           for ( var i = 0; i < json.materials.length; i++ ){\\n\\n               materials.push( materialfromJSON( json.materials[i] ) );\\n\\n           }\\n\\n\\n       //  Create multimaterial.\\n\\n           var multimaterial = new THREE.MeshFaceMaterial(materials);\\n\\n           multimaterial.uuid = json.uuid || THREE.Math.generateUUID();\\n\\n           return multimaterial;\\n\\n        }\\n\\n\\n    //  MATERIAL.\\n\\n        var options = {};\\n\\n        for (var name in json){\\n\\n            if ( json[ name ] == undefined ) continue; // important!\\n\\n\\n            switch (name){\\n\\n                case \\\"_id\\\":\\n                case \\\"meta\\\":\\n                break;\\n\\n\\n            //  uuid.\\n\\n                case \\\"uuid\\\":\\n                    options.uuid = json.uuid || THREE.Math.generateUUID();\\n                break;\\n\\n\\n            //  texture from json.\\n\\n                case \\\"alphaMap\\\":\\n                case \\\"aoMap\\\":\\n                case \\\"bumpMap\\\":\\n                case \\\"displacementMap\\\":\\n                case \\\"emissiveMap\\\":\\n                case \\\"lightMap\\\":\\n                case \\\"map\\\":\\n                case \\\"metalnessMap\\\":\\n                case \\\"normalMap\\\":\\n                case \\\"roughnessMap\\\":\\n                case \\\"specularMap\\\":\\n\\n                        options[ name ] = texturefromJSON( json[ name ] );\\n\\n                break;\\n\\n\\n            //  three color to hex.\\n\\n                case \\\"color\\\":\\n                case \\\"emissive\\\":\\n                case \\\"specular\\\":\\n\\n                    options[ name ] = new THREE.Color();\\n                    options[ name ].setHex( json[ name ] );\\n\\n                break;\\n\\n\\n            //  vector2 from array.\\n\\n                case \\\"normalScale\\\":\\n\\n                    options[ name ] = new THREE.Vector2();\\n                    options[ name ].fromArray( json[ name ] );\\n\\n                break;\\n\\n\\n                case \\\"envMap\\\":\\n                    //  TODO: cube texture.\\n                break;\\n\\n\\n                default:\\n                    options[ name ] = json[ name ];\\n                break;\\n\\n            }\\n\\n        }\\n\\n        return new THREE[ options.type ](options);\\n    }\\n\\n\\n//  TEXTURE FROM JSON (v1.6)\\n//  Return a promise with the texture resolved.\\n\\n    function texturefromJSON( json ){\\n\\n        var texture = new THREE.Texture();\\n\\n        for ( var name in json ){\\n\\n            switch (name){\\n\\n                case \\\"meta\\\":\\n                case \\\"image\\\":\\n                break;\\n\\n            //  array to vector2.\\n\\n                case \\\"offset\\\":\\n                case \\\"repeat\\\":\\n\\n                    if ( json[ name ].length != 2) break;\\n\\n                    texture[ name ] = new THREE.Vector2();\\n                    texture[ name ].fromArray( json[ name ] );\\n\\n                break;\\n\\n\\n            //  wrapS & wrapT.\\n\\n                case \\\"wrap\\\":\\n\\n                    if ( json[ name ].length != 2) break;\\n                    if ( !( json[ name ] instanceof Array ) ) break;\\n\\n                    texture.wrapS = json[ name ][0];\\n                    texture.wrapT = json[ name ][1];\\n\\n                break;\\n\\n            //  image from texture json with\\\"FileReader.readAsDataURL(blob)\\\".\\n\\n                //  Check whether a match for the request is found in   \\n                //  the CacheStorage using CacheStorage.match(). If so, serve that.\\n\\n                //  If not, open the \\\"textures\\\" cache using open(), \\n                //  put the default network request in the cache using Cache.put() \\n                //  and return a clone of the default network request using return response.clone().\\n\\n                //  Clone is needed because put() consumes the response body.\\n                //  If this fails (e.g., because the network is down), return a fallback response.\\n\\n                //  Pros:\\n\\n                    //  Easy to use.\\n                    //  Small, compact, safe code.\\n                    //  Texture.image.src is string.\\n                    //  Texture.image.src is dataURL.\\n                    //  Texture.image.src can reused.\\n                    //  Texture.image.src is always valid.\\n                    //  Texture.image.src can be send everywhere.\\n                    //  Texture.image.src can converted to canvas.\\n                    //  Texture.image (canvas) size always power of 2.\\n                    //  Texture.image.src can saved in storage objects.\\n                    //  Texture.image.src can converted vice versa to blob.\\n\\n                //  Cons:\\n\\n                    //  Larger size (~33%)\\n\\t\\t\\t\\t\\t//  Take more time than URL.createObjectURL(blob);\\n\\n            //  sourceFile.\\n            //  case \\\"sourceFile\\\":\\n            //      texture.sourceFile = json[ name ]; // important!\\n            //  break;\\n\\n            //  case \\\"image\\\": (N/A).\\n                case \\\"sourceFile\\\":\\n\\n                    texture.sourceFile = json.sourceFile;\\n\\n                //  SourceFile first.\\n                    var url = json.sourceFile || json.image.src || json.image || \\\"//i.imgur.com/ODeftia.jpg\\\";\\n\\n                //  URL.\\n\\n                    if ( validator && validator.isURL( url ) ) {\\n\\n                    //  Cache first.\\n                        caches.match( url ).then(function(response){\\n\\n                            if ( !response ) \\n                                throw \\\"Texture not found!\\\";\\n                            else\\n                                return response;\\n\\n                        }).catch(function(err){\\n\\n                        //  We use cors origin mode to avoid\\n                        //  texture tainted canvases, images.\\n\\n                            return fetch( url, {\\n                                mode: \\\"cors\\\",  // important!\\n                                method: \\\"GET\\\",\\n                            });\\n\\n                        }).then(function(response){\\n\\n                            return caches.open(\\\"textures\\\").then(function(cache){\\n\\n\\t\\t\\t\\t\\t\\t\\t//  Clone is needed because put() consumes the response body.\\n\\t\\t\\t\\t\\t\\t\\t//  See: \\\"https://developer.mozilla.org/en-US/docs/Web/API/Cache/put\\\"\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar clone = response.clone();\\n\\t\\t\\t\\t\\t\\t\\t\\treturn cache.put( url, clone ).then(function(){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn response.blob();  //  important!\\n\\t\\t\\t\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t\\t\\t\\t});\\n\\n                        }).then(function(blob){\\n\\n                            var img = new Image();\\n                            img.crossOrigin = \\\"anonymous\\\";  //  important!\\n\\n                            img.onload = function(){\\n                                var canvas = makePowerOfTwo( img, true );\\n                                texture.image = canvas;\\n                                texture.needsUpdate = true;\\n\\t\\t\\t\\t\\t\\t\\t\\timg.onload = null; // optional!\\n                            };\\n\\n                        //  Get dataURL from blob.\\n\\n                            var reader = new FileReader();\\n                            reader.onload = function() {\\n                                img.src = reader.result;\\n                            };\\n\\n                            reader.readAsDataURL(blob);\\n\\n                        });\\n                        \\n                        break;\\n                    } \\n\\n                //  DataURL.\\n\\n                    if ( validator && validator.isDataURI( url ) ) {\\n                        var img = new Image();\\n                        img.crossOrigin = \\\"anonymous\\\";\\n                        img.onload = function(){\\n                            var canvas = makePowerOfTwo( img, true );\\n                            texture.image = canvas;\\n                            texture.needsUpdate = true;\\n\\t\\t\\t\\t\\t\\t\\timg.onload = null; // optional!\\n                        }; \\n\\t\\t\\t\\t\\t\\timg.src = url;  break;\\n                    } \\n\\n                break;\\n\\n                default:\\n                    texture[ name ] = json[ name ];\\n                break;\\n\\n            }\\n\\n        }\\n\\n        return texture;\\n    }\\n\\n\\n//  IMAGE FROM JSON (v1.6)\\n//  Return a promise with the image resolved.\\n\\n    function imagefromJSON( json, onLoadEnd ){\\n\\n        var url = json.src;\\n\\n    //  Cache first.\\n        caches.match( url ).then(function(response){\\n\\n            if ( !response ) \\n                throw response;\\n            else\\n                return response;\\n\\n        }).catch(function(err){\\n\\n            //  We use cors origin mode to avoid\\n            //  texture tainted canvases, images.\\n\\n            return fetch( url, {\\n                mode: \\\"cors\\\",  // important!\\n                method: \\\"GET\\\",\\n            });\\n\\n    //  TODO: REPLACE async/await FOR BACKWARD COMPETALITY.\\n        }).then(function(response){\\n\\n            return caches.open(\\\"textures\\\").then(function(cache){\\n\\n\\t\\t\\t//  Clone is needed because put() consumes the response body.\\n\\t\\t\\t//  See: \\\"https://developer.mozilla.org/en-US/docs/Web/API/Cache/put\\\"\\n\\n\\t\\t\\t\\tvar clone = response.clone();\\n\\t\\t\\t\\treturn cache.put( url, clone ).then(function(){\\n\\t\\t\\t\\t\\treturn response.blob(); //  important!\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t});\\n\\n        }).then(function(blob){\\n\\n            var img = new Image();\\n            img.crossOrigin = \\\"anonymous\\\";  //  important!\\n            img.onload = onLoadEnd;\\n\\n        //  Get dataURL from blob.\\n\\n            return new Promise(function(resolve, reject){\\n\\n                var reader = new FileReader();\\n                reader.onload = function() {\\n                    img.src = reader.result;\\n                    resolve( img );\\n                };\\n\\n                reader.readAsDataURL(blob);\\n\\n            });\\n\\n        });\\n\\n    }\\n\\n\\n//  blobToDataUrl.js\\n//  https://gist.github.com/tantaman/6921973\\n\\n    function convertToBase64(blob, callback) {\\n\\n        var reader = new FileReader();\\n\\n        reader.onload = function(e) {\\n            callback(reader.result);\\n        };\\n\\n        reader.readAsDataURL(blob);\\n    }\\n\\n\\n//  dataUrlToBlob.js\\n//  https://gist.github.com/tantaman/6921973\\n\\n    function dataURLToBlob(dataURL) {\\n\\n        var BASE64_MARKER = \\\";base64,\\\";\\n\\n        if (dataURL.indexOf(BASE64_MARKER) == -1) {\\n            var parts = dataURL.split(\\\",\\\");\\n            var contentType = parts[0].split(\\\":\\\")[1];\\n            var raw = parts[1];\\n\\n            return new Blob([raw], {type: contentType});\\n        }\\n\\n        var parts = dataURL.split(BASE64_MARKER);\\n        var contentType = parts[0].split(\\\":\\\")[1];\\n        var raw = window.atob(parts[1]);\\n        var rawLength = raw.length;\\n\\n        var uInt8Array = new Uint8Array(rawLength);\\n\\n        for (var i = 0; i < rawLength; ++i) {\\n            uInt8Array[i] = raw.charCodeAt(i);\\n        }\\n\\n        return new Blob([uInt8Array], {type: contentType});\\n    }\\n\\n\\n//  makePowerOfTwo.js\\n\\n    function makePowerOfTwo( image, natural ) {\\n\\n        var canvas = document.createElement( \\\"canvas\\\" );\\n\\n        if ( natural ){\\n            canvas.width = THREE.Math.nearestPowerOfTwo( image.naturalWidth );\\n            canvas.height = THREE.Math.nearestPowerOfTwo( image.naturalHeight );\\n        } else {\\n            canvas.width = THREE.Math.nearestPowerOfTwo( image.width );\\n            canvas.height = THREE.Math.nearestPowerOfTwo( image.height );\\n        }\\n\\n        var context = canvas.getContext( \\\"2d\\\" );\\n        context.drawImage( image, 0, 0, canvas.width, canvas.height );\\n\\n    //  debugMode && console.warn( \\\"outfitLoader:makePowerOfTwo(img):\\\", \\n    //  \\\"Image resized to:\\\", canvas.width, \\\"x\\\", canvas.height );\\n\\n        return canvas;\\n    }\\n\\n\\n//  getDataURL.js\\n\\n    function getDataURL( image ) {\\n\\n        var canvas;\\n\\n        if ( image.toDataURL !== undefined ) {\\n\\n            canvas = image;\\n\\n        } else {\\n\\n            canvas = document.createElementNS( \\\"http://www.w3.org/1999/xhtml\\\", \\\"canvas\\\" );\\n            canvas.width = image.width;\\n            canvas.height = image.height;\\n\\n            canvas.getContext( \\\"2d\\\" ).drawImage( image, 0, 0, image.width, image.height );\\n\\n        }\\n\\n        if ( canvas.width > 2048 || canvas.height > 2048 ) {\\n\\n            return canvas.toDataURL( \\\"image/jpeg\\\", 0.6 );\\n\\n        } else {\\n\\n            return canvas.toDataURL( \\\"image/png\\\" );\\n\\n        }\\n\\n    }\\n\\n\\n//  deepCopy.js\\n\\n    function deepCopy(obj) {\\n        if (Object.prototype.toString.call(obj) === \\\"[object Array]\\\") {\\n            var out = [], i = 0, len = obj.length;\\n            for ( ; i < len; i++ ) {\\n                out[i] = arguments.callee(obj[i]);\\n            }\\n            return out;\\n        }\\n        if (typeof obj === \\\"object\\\") {\\n            var out = {}, i;\\n            for ( i in obj ) {\\n                out[i] = arguments.callee(obj[i]);\\n            }\\n            return out;\\n        }\\n        return obj;\\n    }\\n\\n\\n//  round.js  source: \\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\\\"\\n\\n    function round(number, precision) {\\n        var shift = function (number, precision, reverseShift) {\\n            if (reverseShift) {\\n                precision = -precision;\\n            }  \\n            numArray = (\\\"\\\" + number).split(\\\"e\\\");\\n            return +(numArray[0] + \\\"e\\\" + (numArray[1] ? (+numArray[1] + precision) : precision));\\n        };\\n        return shift(Math.round(shift(number, precision, false)), precision, true);\\n    }\\n\\n\""
		}],
	"stylesheets": [],
	"skinned": [],
	"scripts": {
		"BCC3A53B-07C6-4FC3-B308-8F4A3E94469D": [
			{
				"name": "index.js",
				"source": "//\tdebguMode = true;\n//\tTHREE.Cache.enabled = true;\n\nvar projectId = {\n\tkind: \"app\",\n\tname: \"boilerplate (in-a-box)\",\n\tversion: \"4.1.0\",\n\tthreejs: \"r78\",\n\tdate: \"2019.09.24.23:50\", // \"YYYY.MM.DD.HH:mm\".\n\tdescription: \"Self boilerplate app made with threejs editor (r78)\",\n\trequired_libs: [\n\t\t\t\t\"watch.js\",\n\t\t\t\t\"command.js\",\n\t\t\t\t\"Objectid.js\",\n\t\t\t\t\"jquery.min.js\",\n\t\t\t\t\"rawinflate.js\",\n\t\t\t\t\"rawdeflate.js\",\n\t\t\t\t\"store2.min.js\",\n\t\t\t\t\"system.min.js\",\n\t\t\t\t\"zangodb.min.js\",\n\t\t\t\t\"signals.min.js\",\n\t\t\t\t\"bootbox.min.js\",\n\t\t\t\t\"validator.min.js\",\n\t\t\t\t\"bootstrap.min.js\",\n\t\t\t\t\"socketcluster.js\",\n\t\t\t\t\"DeviceDetector.js\",\n\t\t\t\t\"sc-codec-min-bin.js\",\n\t\t\t\t\"MathDecimalAdjustment.js\",\n\t\t\t//\tthree.\n\t\t\t\t\"shader.js\",\n\t\t\t\t\"UVsDebug.js\",\n\t\t\t\t\"Animation.js\",\n\t\t\t\t\"EditorControls.js\",\n\t\t\t\t\"AnimationHandler.js\",\n\t\t\t\t\"KeyFrameAnimation.js\",\n\t\t\t\t\"SubdivisionModifier.js\",\n\t\t\t//  MW.\n\t\t\t\t\"MW.js\",\n\t\t\t\t\"MWtps.js\",\n\t\t\t\t\"VirtualInput.js\",\n\t\t\t//  AW3D.\n\t\t\t\t\"AW3D-v0.4.js\"\n\t],\n};\n\n//\tcontrols = new THREE.EditorControls(camera, renderer.domElement);\n"
			},
			{
				"name": "world.js",
				"source": "//  MW WORLD.\n\nworld = new MW.World();\n\n//  OCTREE.\n\n//  Make a octree object, which will be the \n//  container of rigid objects such as terrain ect.\n\nvar partition = 2;\n\nvar min = new THREE.Vector3( -1000, -1000, -1000 );\nvar max = new THREE.Vector3(  1000,  1000,  1000 );\n\noctree = new MW.Octree( min, max, partition ); // important!\n\nworld.add( octree );\n\n//  GROUND.\n\nground = new THREE.Mesh(\n\tnew THREE.PlaneGeometry( 2500, 2500, 1, 1 ),\n\tnew THREE.MeshLambertMaterial({ \n\t\tcolor:0x829ec4,\n\t\twireframe:false,\n\t})\n);\n\nground.rotation.x = THREE.Math.degToRad( -90 );\n\n//  If want the ground as collision surface\n//  only, do not add the ground in the scene.\n\n//\tscene.add( ground );\n//\tground.visible = false;\n//\tground.receiveShadow = true;\n\n//  Add the ground to WALKMESH world octree object.\n//  MESHWALK use octree system to detect collision objects.\n\noctree.importThreeMesh( ground ); // important!\n\n//\tRuntime.\n\nvar clock = new THREE.Clock(); // important!\n\nfunction update(){\n\n\tvar dt = clock.getDelta(); // important!\n\tvar time = clock.getElapsedTime(); // optional!\n\n\tworld.step( dt ); // important!\n\n\tTHREE.AnimationHandler.update( dt ); // important!\n}\n\n"
			},
			{
				"name": "localPlayerController.js",
				"source": "//  PlayerController.js\n\nvar Player = function(radius){\n\n\tthis.holder = AW3D.PlayerHolder(); // important!\n\tscene.add( this.holder );\n\tthis.holder.visible = true;\n\n\tthis.holderHelper = AW3D.PlayerHolderHelper();\n\tscene.add( this.holderHelper );\n\n\tthis.sphere = AW3D.PlayerSphere();\n\tthis.sphere.position.y = 12;\n\tthis.holder.add( this.sphere ); \n\n\tvar player = this; // important!\n\n\tthis.outfit = new AW3D.OutfitManager(); // important!\n\n\tthis.outfit.update = function() {\n\n\t//  Update avatar rotation y.\n\t\tvar direction = player.controller.direction - Math.PI;\n\n\t//  \"this\" is the \"localPlayer.outfit\".\n\t\tthis.direction.rotation.y = direction;\n\n\t//  Update avatar position.\n\t\tvar x = player.controller.center.x;\n\t\tvar y = player.controller.center.y - player.controller.radius;\n\t\tvar z = player.controller.center.z;\n\n\t//  \"this\" is the \"localPlayer.outfit\".\n\t\tthis.direction.position.set( x, y, z );\n\t};\n\n\tvar radius = radius || 3;\n\tthis.controller = new MW.CharacterController( this.holder, radius );\n\tthis.controller.isWalking = false;\n\n\tthis.controller.getdata = function( action ){\n\n\t\tvar data = {};\n\t\tdata.playerid = socket.id;\n\t\tdata.radius = this.radius;\n\t\tdata.isGrounded = this.isGrounded;\n\t\tdata.isOnSlope = this.isOnSlope;\n\t\tdata.isIdling  = this.isIdling;\n\t\tdata.isJumping = this.isJumping;\n\t\tdata.isRunning = this.isRunning;\n\t\tdata.isWalking = this.isWalking;\n\t\tdata.direction = this.direction;\n\t\tdata.movementSpeed = this.movementSpeed;\n\t\tdata.jumpStartTime = this.jumpStartTime;\n\t\tdata.position = this.center.toArray();\n\t\tif (!!action) data.action = action;\n\n\t\treturn data;\n\t};\n\n\tfunction onStartJumping(){\n\t\tplayer.outfit.AnimationsHandler.weightOff(\"idle\", \"walk\", \"run\");\n\t};\n\n\tfunction onEndJumping(){\n\t\tplayer.outfit.AnimationsHandler.weightOn(\"idle\", \"walk\", \"run\");\n\n\t\tif ( player.controller.isRunning && player.controller.isWalking ) {\n\n\t\t\tplayer.outfit.AnimationsHandler.stop();\n\t\t\tplayer.controller.movementSpeed = 28;\n\t\t\tplayer.outfit.AnimationsHandler.play(\"walk\");\n\t\t\tplayer.controller.dispatchEvent({type:\"startRunning\"});\n\n\t\t} else if ( player.controller.isRunning && !player.controller.isWalking ) {\n\n\t\t\tplayer.outfit.AnimationsHandler.stop();\n\t\t\tplayer.controller.movementSpeed = 45;\n\t\t\tplayer.outfit.AnimationsHandler.play(\"run\");\n\t\t\tplayer.controller.dispatchEvent({type:\"startRunning\"});\n\n\t\t} else {\n\n\t\t\tplayer.outfit.AnimationsHandler.stop();\n\t\t\tplayer.controller.movementSpeed = 0;\n\t\t\tplayer.outfit.AnimationsHandler.play(\"idle\");\n\t\t\tplayer.controller.dispatchEvent({type:\"startIdling\"});\n\n\t\t}\n\t}\n\n\tthis.controller.addEventListener(\"endJumping\",   onEndJumping);\n\tthis.controller.addEventListener(\"startJumping\", onStartJumping);\n\n//  Add controller to world.\n\tworld.add( this.controller ); // important!\n\n\tdebugMode && console.log( \n\t\t\"world.characterPool length:\", world.characterPool.length, \n\t\t\"index:\", world.characterPool.indexOf( this.controller )\n\t);\n\n//  Add outfit to scene.\n\tscene.add(this.outfit.direction); // important!\n\n};\n\nPlayer.prototype = {\n\n//  Collect position, direction, nickname, and gender.\n\n\tgetdata: function( socket ){\n\t\tif ( !socket ) return;\n\t\tvar data = {};\n\t\tdata.playerid  = socket.id;\n\t\tdata.nickname  = this.nickname;\n\t\tdata.gender    = this.outfit.getGender();\n\t\tdata.direction = this.outfit.direction.rotation.y;\n\t\tdata.position  = this.outfit.direction.position.toArray();\n\t\tdata.dna       = this.outfit.toDNA();\n\t\tdebugMode && console.log(\"player data:\", data);\n\t\treturn data;\n\t},\n\n//  Remote player set data.\n\n\tsetdata: function( data ){\n\t\tif ( !data.playerid || data.playerid != this.playerid ) return;\n\n\t\tthis.playerid = data.playerid;\n\t\tthis.nickname = data.nickname;\n\t\tthis.outfit.setGender( data.gender );\n\t\tthis.outfit.direction.rotation.y = data.direction;\n\t\tthis.outfit.direction.position.fromArray(data.position);\n\n\t\tif (data.action != undefined) {\n\t\t\tthis.outfit.AnimationsHandler.stop();\n\t\t\tthis.outfit.AnimationsHandler.play( data.action );\n\t\t}\n\t},\n\n//  Create player outfit from dna data.\n\n\tfromDNA: function( dna ){\n\t\tvar frontAngle = Math.PI - cameraControls.getFrontAngle(); // face front.\n\t\tthis.controller.direction = frontAngle;\n\t\tthis.outfit.fromDNA( dna );\n\t\tscene.add(this.outfit.direction);\n\t\tthis.outfit.update();\n\t},\n\n//  Start remote player action.\n\tstartAction: function( running, walking, idling, speed, name, eventType ){\n\n\t\tthis.outfit.AnimationsHandler.stop();        \n\t\tthis.controller.isRunning = running;\n\t\tthis.controller.isWalking = walking;\n\t\tthis.controller.isIdling  = idling;\n\t\tthis.controller.movementSpeed = speed;\n\t\tthis.outfit.AnimationsHandler.play( name );\n\t\tthis.controller.dispatchEvent({type: eventType});\n\n\t},\n\n//  Get local player action data.\n\tgetActionData: function ( name ){\n\t\treturn {\n\t\t\tplayerid : socket.id,\n\t\t\tdirection: this.outfit.direction.rotation.y,\n\t\t\tposition : this.outfit.direction.position.toArray(),\n\t\t\taction   : name,\n\t\t};\n\t},\n\n};\n\nfunction init(){\n\n\tlocalPlayer = new Player(); // important!\n\tlocalPlayer.sphere.visible = false;\n\tdebugMode && console.log(\"localPlayer:\", localPlayer);\n\n//  cameraControl.js\n\n\tcameraControls = new MW.TPSCameraControl(camera, localPlayer.holder, {\n\t\tel: renderer.domElement,               // html renderer element.\n\t\toffset: new THREE.Vector3( 0, 15, 0 ), // camera eye height.\n\t\tradius: 40,                            // default: 37 // (distance of the character to the camera).\n\t\tminRadius: 6,                          // default: 10 // (can take and negative values, yes!!!).\n\t\tmaxRadius: 1500,                       // default: 64, runtime: 40.\n\t\trigidObjects: [],                      // collition objects for the camera.\n\t});\n\n\tcameraControls.getforward = function(){ \n\t\treturn -this.theta \n\t};\n\n\tcameraControls.setVerticalOffset = function(offset){ \n\t\tthis.offset.y = offset; \n\t};\n\n\t(cameraControls.frontAngleUpdate = function(){\n\t\trequestAnimationFrame( cameraControls.frontAngleUpdate );\n\t\tcameraControls.forward = -cameraControls.theta;\n\t})();\n\n/*\n\tcameraControls.addEventListener(\"updated\", function(){\n\t\tdefaultCameraLight.position.copy( cameraControls.camera.position );\n\t});\n*/\n\n//  KeyInputControls.js\n\n\tkeyInputControls = new MW.KeyInputControl();\n\n\tkeyInputControls.On = function(){\n\t\tif ( !keyInputControls.isOff ) return;\n\t\t$(keyInputControls).on( \"movekeyon\", onMoveKeyOn );\n\t\t$(keyInputControls).on( \"movekeyoff\", onMoveKeyOff );\n\t\t$(keyInputControls).on( \"jumpkeypress\", onJumpInput );\n\t\t$(keyInputControls).on( \"movekeychange\", onMoveKeyChange );\n\t\tkeyInputControls.isOff = false;\n\t\tdebugMode && console.log( \"keyInputControls are ON.\" );\n\t};\n\n\tkeyInputControls.Off = function(){\n\t\tif ( keyInputControls.isOff ) return;\n\t\t$(keyInputControls).off( \"movekeyon\", onMoveKeyOn );\n\t\t$(keyInputControls).off( \"movekeyoff\", onMoveKeyOff );\n\t\t$(keyInputControls).off( \"jumpkeypress\", onJumpInput );\n\t\t$(keyInputControls).off( \"movekeychange\", onMoveKeyChange );\n\t\tkeyInputControls.isOff = true;\n\t\tdebugMode && console.log( \"keyInputControls are OFF.\" );\n\t};\n\n\tkeyInputControls.update = function(){\n\n\t\tif ( keyInputControls.isOff ) return;\n\n\t\tif ( keyInputControls.isMoveKeyHolded \n\t\t\t|| localPlayer.controller.isJumping \n\t\t\t|| !localPlayer.controller.isGrounded \n\t\t\t|| localPlayer.controller.isOnSlope ){\n\n\t\t\tthis.dispatchEvent({type:\"update\"});\n\t\t}\n\t};\n\n//\tActivate keyInputControls by setting to \"off\".\n\tkeyInputControls.Off(); // important!\n//\tkeyInputControls.inRun = true;\n\n\tfunction onMoveKeyOn() { \n\t\tdebugMode && console.log(\"move key on\");\n\n\t\tif (  localPlayer.controller.isJumping \n\t\t\t|| !localPlayer.controller.isGrounded \n\t\t\t||  localPlayer.controller.isOnSlope ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlocalPlayer.controller.direction = (2 * Math.PI) - cameraControls.getFrontAngle() + this.frontAngle;\n\n\t\tlocalPlayer.outfit.AnimationsHandler.stop();\n\t\tlocalPlayer.controller.isRunning = true; \n\t\tlocalPlayer.controller.isWalking = true;\n\t\tlocalPlayer.controller.movementSpeed = 28;\n\t\tlocalPlayer.outfit.AnimationsHandler.play(\"walk\");\n\n\t}\n\n\tfunction onMoveKeyChange() {\n\t\tdebugMode && console.log(\"move key changed\");\n\t\tlocalPlayer.controller.direction = (2 * Math.PI) - cameraControls.getFrontAngle() + this.frontAngle;\n\t}\n\n\tfunction onMoveKeyOff() {\n\t\tdebugMode && console.log(\"move key off\");\n\n\t\tif (  localPlayer.controller.isJumping \n\t\t\t|| !localPlayer.controller.isGrounded \n\t\t\t||  localPlayer.controller.isOnSlope ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar finalDirection = (2 * Math.PI) - cameraControls.getFrontAngle() + this.frontAngle;\n\n\t\tlocalPlayer.controller.direction = finalDirection;\n\t\tlocalPlayer.outfit.AnimationsHandler.stop();\n\t\tlocalPlayer.controller.isRunning = false;\n\t\tlocalPlayer.controller.isWalking = false;\n\t\tlocalPlayer.controller.isIdling  = true;\n\t\tlocalPlayer.controller.movementSpeed = 0;\n\t\tlocalPlayer.outfit.AnimationsHandler.play(\"idle\");\n\t\tlocalPlayer.controller.dispatchEvent({type:\"startIdling\"});\n\n\t}\n\n\tfunction onJumpInput() {\n\t\tdebugMode && console.log(\"jump key on\");\n\n\t\tif (  localPlayer.controller.isJumping \n\t\t\t|| !localPlayer.controller.isGrounded \n\t\t\t||  localPlayer.controller.isOnSlope ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlocalPlayer.controller.jump();\n\t\tlocalPlayer.outfit.AnimationsHandler.jump();\n\n\t}\n\n//  JoystickControls.js (requires \"jquery.js\")\n\n\t$(document.head).append(\n\t\t\"<style class='joystick-controls'> \\n.gameinput-button__inner { display:table-cell; vertical-align: middle; } \\n\"\n\t\t+ \".gameinput-joystick { border:solid 0px white; border-radius:50%; position:absolute; bottom:30px; user-select:none; \"\n\t\t+ \"touch-action:none; -ms-touch-action:none; -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; } \\n\"\n\t\t+ \".gameinput-frame { position:absolute; top:0; left:0; pointer-events:none; opacity:0.5; } \\n\"\n\t\t+ \".gameinput-button { cursor:pointer; text-align:center; position:absolute; display:table; \\n\"\n\t\t+ \"box-sizing:border-box; border:1px solid #333; border-radius:50%; background:rgba( 255, 255, 255, .5 ); user-select:none; \"\n\t\t+ \"touch-action:none; -ms-touch-action:none; -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; } \\n\"\n\t\t+ \"#joystick1 { bottom:50px; right:40px; width:120px; height:120px;z-index:1; } \\n\"\n\t\t+ \"#joystick2 { bottom:50px; left:40px; width:120px; height:120px; z-index:1;} \\n\"\n\t\t+ \"#jumpButton { right:105px; bottom:240px; z-index:1; } \\n\"\n\t\t+ \"@media ( max-width: 768px ) { \\n#joystick1 { bottom:0px; right:0px; } \\n#joystick2 { bottom:0px; left:0px; } \\n\"\n\t\t+ \"#jumpButton { bottom:190px; right:65px; } \\n.gameinput-joystick { bottom:0px;} \\n} \\n\"\n\t\t+ \".gameinput-joystick__button { position:absolute; width:72px; height:72px; left:85px; top:85px; cursor:pointer; \"\n\t\t+ \"box-sizing:border-box; border-radius:50%; border:1px solid #333; background:rgba( 255, 255, 255, .5 ); } \\n\"\n\t\t+ \"</style>\"\n\t);\n\n\t$(document.body).append(\n\t\t'<div class=\"joystick-controls\" id=\"joystick-controls-1\">' \n\t\t+ '</div><div class=\"joystick-controls\" id=\"joystick-controls-2\"></div>'\n\t);\n\n\tvar joystick1Selector  = \"#joystick1\";\n\tvar joystick2Selector  = \"#joystick2\";\n\tvar jumpButtonSelector = \"#jumpButton\";\n\n\tvar joystickControlsSelector  = \".joystick-controls\";\n\tvar joystickControls1Selector = \"#joystick-controls-1\";\n\tvar joystickControls2Selector = \"#joystick-controls-2\";\n\n\tvar buttonSvgSrc = '<svg width=\"48\" height=\"48\" viewBox=\"0 0 64 64\"><path fill=\"#fff\" d=\"M44.5,54.5c-0.3-5.1-2.4-9.4-5.7-13.2C41,36,40.9,30,38.5,24.7c-1.2-2.7-3.9-4.4-6.9-3.3c-0.2,0.1-0.4,0.1-0.5,0.2c-3-4.3-6.6-8.3-10.1-11.8c-2.6-2.6-6.4,1.7-3.8,4.3c3.9,3.9,8.1,8.5,11,13.7c0,0.1,0.1,0.3,0.2,0.4c1.5,3.2,1.9,6.4,0.2,9.6c-0.3,0.5-0.4,1-0.5,1.5c-1.1,1.5-2.3,3-3.6,4.4c-0.8-2.3-1.4-4.7-1.6-7.1c-0.5-4.6-7.7-4.1-7.2,0.5c0.5,4.9,2.1,9.6,3.9,14.2c0.8,1.9,3.6,3.4,5.4,1.8c2.8-2.4,5.3-4.9,7.5-7.8c0.2,0.1,0.5,0.1,0.7,0.1c0.1,0.3,0.3,0.5,0.5,0.7c1.7,1.8,2.8,3.9,3.3,6.3c-2.2,0.8-4.6,1.4-7,1.4c-4.6,0.1-4.1,7.2,0.5,7.2c4-0.1,7.9-1.3,11.6-3C43.6,57.5,44.6,56.2,44.5,54.5z M34.2,8.9c0.7,0.1,1.6-0.1,2.3,0.3c1.5,0.8,2.6,2.1,3.2,3.6c0.2-2.2,0.5-4.3,0.8-6.5c0.5-3.7-5.1-4.7-5.7-1.1C34.6,6.3,34.3,7.8,34.2,8.9z\"/><circle fill=\"#fff\" cx=\"33.8\" cy=\"15.2\" r=\"4.9\"/></svg>';\n\n\tjoystick1  = new virtualInput.Joystick( $( joystickControls1Selector ), 94, { id: \"joystick1\" } );\n\tjoystick2  = new virtualInput.Joystick( $( joystickControls2Selector ), 94, { id: \"joystick2\" } );\n\tjumpButton = new virtualInput.Button( $( joystickControls1Selector ),   58, { id: \"jumpButton\", label: \"<b>JUMP</b>\" } ); // buttonSvgSrc\n\n\tjoystick1.addEventListener( \"active\", function () { \n\n\t\tif (  localPlayer.controller.isJumping || !localPlayer.controller.isGrounded ||  localPlayer.controller.isOnSlope ) return;\n\n\t\tlocalPlayer.controller.direction = (3 * Math.PI/2) - cameraControls.getFrontAngle() + this.angle; // important!\n\n\t\tif ( localPlayer.controller.isRunning && !localPlayer.controller.isWalking ) {\n\n\t\t\tlocalPlayer.outfit.AnimationsHandler.stop();\n\t\t\tlocalPlayer.controller.movementSpeed = 45;\n\t\t\tlocalPlayer.outfit.AnimationsHandler.play(\"run\");\n\n\t\t} else {\n\n\t\t\tlocalPlayer.outfit.AnimationsHandler.stop();\n\t\t\tlocalPlayer.controller.isRunning = true; \n\t\t\tlocalPlayer.controller.isWalking = false;  // !!!danger: \"false\" cause bug in production server ??? //\n\t\t\tlocalPlayer.controller.movementSpeed = 28;\n\t\t\tlocalPlayer.outfit.AnimationsHandler.play(\"walk\");\n\n\t\t}\n\t});\n\n\tjoystick1.addEventListener( \"disactive\", function () { \n\n\t\tif (  localPlayer.controller.isJumping || !localPlayer.controller.isGrounded ||  localPlayer.controller.isOnSlope ) return;\n\n\t\tlocalPlayer.outfit.AnimationsHandler.stop();\n\t\tlocalPlayer.controller.isRunning = false;\n\t\tlocalPlayer.controller.isWalking = false;\n\t\tlocalPlayer.controller.movementSpeed = 0;\n\t\tlocalPlayer.outfit.AnimationsHandler.play(\"idle\");\n\t\tlocalPlayer.controller.dispatchEvent({type:\"startIdling\"});\n\n\t});\n\n\tjoystick1.update = function(){\n\n\t\tif ( this.isActive ) {\n\n\t\t\tlocalPlayer.controller.direction = (3 * Math.PI/2) - cameraControls.getFrontAngle() + this.angle;\n\n\t\t\tthis.dispatchEvent({type:\"update\"}); // important!\n\n\t\t}\n\t};\n\n\tjoystick2.update = function(){\n\n\t\tif ( this.isActive ) {\n\n\t\t\tcameraControls.setLatLon(\n\t\t\t\tcameraControls.lat + this.position.y * 0.5, // deg.\n\t\t\t\tcameraControls.lon - this.position.x        // deg.\n\t\t\t);\n\n\t\t\tthis.dispatchEvent({type:\"update\"}); // important!\n\t\t}\n\t}\n\n\tjumpButton.addEventListener( \"press\", function () { \n\n\t\tif (  localPlayer.controller.isJumping || !localPlayer.controller.isGrounded || localPlayer.controller.isOnSlope ) return;\n\n\t\tlocalPlayer.controller.jump();\n\t\tlocalPlayer.outfit.AnimationsHandler.jump();\n\n\t});\n\n\n\n\twatch(cameraControls, [\"lat\", \"lon\"], function(){\n\t\tdefaultCameraLight.position.copy( camera.position );\n\t});\n\n\n\twatch(keyInputControls, \"frontAngle\", function(){\n\t\tdefaultCameraLight.position.copy( camera.position );\n\t});\n\n\n\n//\tkeyInputControls.On(); // important!\n\tconsole.log( \"application inited.\" );\n\n}\n\nfunction start(){\n\n\tkeyInputControls.On();\n\tconsole.log( \"application started.\" );\n}\n\nfunction stop(){\n\n\tkeyInputControls.Off();\n\t$(\".joystick-controls\").remove();\n\tconsole.log( \"application stopped.\" );\n}\n\n//\tRuntime.\n\nfunction update(){\n\n\tcameraControls.update();\n\tkeyInputControls.update();\n\tlocalPlayer.outfit.update();\n\tjoystick1.update();\n\tjoystick2.update();\n\n\n}\n"
			}],
		"05902F26-E7A6-4875-8D13-70E2EF94E04E": [
			{
				"name": "groundHelper.js",
				"source": "//\tgroundHelper.js\n\ndebugMode && console.log(this);\n\nvar helper = this;\nvar fontPath = \"/three/fonts/helvetiker_regular.typeface.json\";\n\ngroundHelper = groundHelper(1000, 10);  \naxisCustomHelper = customAxisHelper(5200);\naxisOriginHelper = originAxisHelper(1200);\n\nfunction init(){\n\thelper.add(groundHelper, axisOriginHelper);\n}\n\nfunction groundHelper(xz, step){\n\tif (!xz) xz = 1000;\n\tif (!step) step = 10;\n\tvar grid = new THREE.GridHelper( xz, step, 0x444444, 0x444444 );\n\tgrid.name = \"GRID\"\n\tgrid.position.y = 0;\n//\thelper.add( grid );\n\treturn grid;\n}\n\nfunction customAxisHelper( distance ){\n\tvar group = new THREE.Group();\n//\thelper.add(group);\n\n//  Lines.\n\tvar geometryAxisXpos = new THREE.Geometry();\n\tvar geometryAxisXneg = new THREE.Geometry();\n\tvar geometryAxisYpos = new THREE.Geometry();\n\tvar geometryAxisYneg = new THREE.Geometry();\n\tvar geometryAxisZpos = new THREE.Geometry();\n\tvar geometryAxisZneg = new THREE.Geometry();\n\n\tvar materialAxisXpos = new THREE.LineBasicMaterial( {color: 0xff0000} );\n\tvar materialAxisXneg = new THREE.LineBasicMaterial( {color: 0xff0000} );\n\tvar materialAxisYpos = new THREE.LineBasicMaterial( {color: 0x00ff00} );\n\tvar materialAxisYneg = new THREE.LineBasicMaterial( {color: 0x00ff00} );\n\tvar materialAxisZpos = new THREE.LineBasicMaterial( {color: 0x0000ff} );\n\tvar materialAxisZneg = new THREE.LineBasicMaterial( {color: 0x0000ff} );\n\n\tgeometryAxisXpos.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( distance, 0, 0 ) );\n\tgeometryAxisXneg.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3(-distance, 0, 0 ) );\n\tgeometryAxisYpos.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, distance, 0 ) );\n\tgeometryAxisYneg.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0,-distance, 0 ) );\n\tgeometryAxisZpos.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, distance ) );\n\tgeometryAxisZneg.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0,-distance ) );\n\n\tvar lineAxisXpos = new THREE.Line( geometryAxisXpos, materialAxisXpos );\n\tvar lineAxisXneg = new THREE.Line( geometryAxisXneg, materialAxisXneg );\n\tvar lineAxisYpos = new THREE.Line( geometryAxisYpos, materialAxisYpos );\n\tvar lineAxisYneg = new THREE.Line( geometryAxisYneg, materialAxisYneg );\n\tvar lineAxisZpos = new THREE.Line( geometryAxisZpos, materialAxisZpos );\n\tvar lineAxisZneg = new THREE.Line( geometryAxisZneg, materialAxisZneg );\n\n\tgroup.add( lineAxisXpos );\n\tgroup.add( lineAxisXneg );\n//  group.add( lineAxisYpos );\n//  group.add( lineAxisYneg );\n\tgroup.add( lineAxisZpos );\n\tgroup.add( lineAxisZneg );\n\tgroup.name = \"AXES\";\n\n\treturn group;\n}\n\nfunction originAxisHelper( distance ){\n\tvar group = new THREE.Group();\n\tvar loader = new THREE.FontLoader();\n\tloader.load( fontPath, function ( response ) {\n\t\tvar font = response;\n\t\t//\thelper.add(group);\n\n\t\t//  Font Material\n\t\tvar materialFace = new THREE.MeshBasicMaterial( { color: 0xffffff } );\n\t\tvar materialSide = new THREE.MeshBasicMaterial( { color: 0x888888 } );\n\t\tvar materialArray = [ materialFace, materialSide ];\n\t\tvar material = new THREE.MeshFaceMaterial(materialArray);\n\n\t\t//  Text Styles.\n\t\th0 = { size: 40, height: 2,   curveSegments: 10, font: font, weight: \"normal\", style: \"normal\", bevelThickness: 1, bevelSize: 2, bevelEnabled: false, material: 0, extrudeMaterial: 1 }\n\t\th1 = { size: 20, height: 1,   curveSegments: 10, font: font, weight: \"normal\", style: \"normal\", bevelThickness: 1, bevelSize: 2, bevelEnabled: false, material: 0, extrudeMaterial: 1 }\n\t\th2 = { size: 10, height: 1,   curveSegments: 10, font: font, weight: \"normal\", style: \"normal\", bevelThickness: 1, bevelSize: 2, bevelEnabled: false, material: 0, extrudeMaterial: 1 }\n\t\th3 = { size: 5,  height: 0.5, curveSegments: 10, font: font, weight: \"normal\", style: \"normal\", bevelThickness: 1, bevelSize: 2, bevelEnabled: false, material: 0, extrudeMaterial: 1 }\n\n\t\t//  Origins Group.\n\t\tgroup.add( new Text3D( \"+x\", h1, [2, 2, 5], [ distance, 20, 0], [0, -Math.PI * 0.5, 0]) );\n\t\tgroup.add( new Text3D( \"-x\", h1, [2, 2, 5], [-distance, 20, 0], [0,  Math.PI * 0.5, 0]) ); \n\t\tgroup.add( new Text3D( \"+z\", h1, [2, 2, 5], [0, 20,  distance], [0, -Math.PI,       0]) ); \n\t\tgroup.add( new Text3D( \"-z\", h1, [2, 2, 5], [0, 20, -distance], [0,              0, 0]) ); \n\t\tgroup.add( new Text3D( \"+y\", h1, [2, 2, 5], [0,   distance, 0], [ Math.PI * 0.5, 0, 0]) ); \n\t\tgroup.add( new Text3D( \"-y\", h1, [2, 2, 5], [0,  -distance, 0], [-Math.PI * 0.5, 0, 0]) ); \n\t\tgroup.name = \"ORIGINS\";\n\n\t\t//  return group;\n\n\t\tfunction Text3D(text, style, scale, position, rotation){\n\t\t\tvar geometry = new THREE.TextGeometry( text, style );\n\t\t\tvar mesh = new THREE.Mesh(geometry, material );\n\t\t\tgeometry.computeBoundingBox();\n\t\t\tvar width = geometry.boundingBox.max.x - geometry.boundingBox.min.x;\n\t\t\tmesh.scale.fromArray( scale ); \n\t\t\tmesh.geometry.center();\n\t\t\tmesh.position.fromArray( position );\n\t\t\tmesh.rotation.fromArray( rotation );\n\t\t\treturn mesh;\n\t\t}\n\n\t});\n\n\treturn group;\n}\n\n"
			}],
		"A19C133A-E409-4607-B7BD-0E2698549750": [
			{
				"name": "basic-animations.js",
				"source": "//\tbasic-animation.js\n\nAnimations = {}; // object.\n\nvar loader = new THREE.XHRLoader();\nloader.setResponseType( \"json\" );\nloader.load(\"/AW3D_db/animations.json\", function(results){\n\n\t//  returns an array of objects!\n\n\tdebugMode && console.log(\"animations:\", results);\n\n\tvar json = results.find(function(item){\n\t\treturn item._id == \"basic\";\n\t});\n\n\tdebugMode && console.log(\"basic:\", json);\n\n\tfor (var name in json){\n\t\tif ( name != \"_id\" ) Animations[name] = json[name];\n\t}\n\n});"
			},
			{
				"name": "male-animations.js",
				"source": "//\tmale-animation.js\n\nMaleAnimations = {}; // object.\n\nvar loader = new THREE.XHRLoader();\nloader.setResponseType( \"json\" );\nloader.load(\"/AW3D_db/animations.json\", function(results){\n\n\t//  returns an array of objects!\n\n\tvar json = results.find(function(item){\n\t\treturn item._id == \"male\";\n\t});\n\n\tdebugMode && console.log(\"male:\", json);\n\n\tfor (var name in json){\n\t\tif ( name != \"_id\" ) MaleAnimations[name] = json[name];\n\t}\n\n});"
			},
			{
				"name": "female-animations.js",
				"source": "//\tmale-animation.js\n\nFemaleAnimations = {}; // object.\n\nvar loader = new THREE.XHRLoader();\nloader.setResponseType( \"json\" );\nloader.load(\"/AW3D_db/animations.json\", function(results){\n\n\t//  returns an array of objects!\n\n\tvar json = results.find(function(item){\n\t\treturn item._id == \"female\";\n\t});\n\n\tdebugMode && console.log(\"female:\", json);\n\n\tfor (var name in json){\n\t\tif ( name != \"_id\" ) FemaleAnimations[name] = json[name];\n\t}\n\n});"
			}],
		"6AD93A00-35BA-4603-8634-129EA23AF066": [
			{
				"name": "skeleton-mesh-loader.js",
				"source": "skeleton = {}; // important!\n\nvar loader = new THREE.XHRLoader();\nvar url = \"/skinned/skeleton/skeleton.json\";\nloader.setResponseType( \"json\" );\nloader.load(url, function(json){\n\n\tdebugMode && console.log(\"skeleton:\", json);\n\n\tvar loader = new THREE.JSONLoader();\n\tvar object = loader.parse( json );\n\n\tdebugMode && console.log(\"object:\", object);\n\n\tvar geometry = object.geometry;\n\tgeometry.sourceFile = url;  // important!\n\tgeometry.name = json.name + \".geometry\";\n\tgeometry.computeFaceNormals();\n\tgeometry.computeVertexNormals();\n\tgeometry.computeBoundingBox();\n\tgeometry.computeBoundingSphere();\n\n\tvar material = new THREE.MeshLambertMaterial({\n\t\tside: 0,\n\t\topacity: 1,\n\t\tshading: 2,\n\t\temissive: 0,\n\t\tskinning: true,\n\t\tcolor: 16777215,\n\t\ttransparent: false,\n\t\tname: \"HF_SkeletonMaterial\",\n\t});\n\n\tvar skinned = new THREE.SkinnedMesh( geometry, material );\n\n\tskinned.renderDepth = 1;\n\tskinned.frustumCulled = false;\n\tskinned.position.set( 0, 0, 0 );\n\tskinned.rotation.set( 0, 0, 0 );\n\tskinned.scale.set( 1,1,1 );\n\tskinned.castShadow = true;\n\tskinned.name = json.name;\n\n\tskeleton = skinned; // important!\n\tlocalPlayer.outfit.add({\"skeleton\":skeleton});\n\n});\n\n/*\nfunction init(){\n//\tAdd to scene. (debugging)\n\tvar data = {\n\t\tgeometry: \"/skinned/skeleton/skeleton.json\",\n\t\tmaterial: {\n\t\t\tcolor: 16777215,\n\t\t\temissive: 0,\n\t\t\tname: \"HF_SkeletonMaterial\",\n\t\t\topacity: 1,\n\t\t\tshading: 2,\n\t\t\tside: 0,\n\t\t\tskinning: true,\n\t\t\ttransparent: false,\n\t\t\ttype: \"MeshLambertMaterial\",\n\t\t},\n\t\tname: \"body\",\n\t\tscale: [1, 1, 1],\n\t\tvisible: true,\n\t};\n\n\tlocalPlayer.outfit.fromJSON({\"skeleton\":data});\n}\n*/"
			}],
		"3854A5B6-1389-4A5F-887D-950B553DAD02": [
			{
				"name": "octree-helpers.js",
				"source": "//  Octree helpers.js\n\nvar octreehelper = this;\n\noctreeMeshHelpers = [];\noctreeEdgesHelpers = [];\n\n//  Add octree edges helpers.\noctreeHelpers( octree );\n\nfunction octreeHelpers( octree ){\n\tvar nodeIndex = octree.nodes.length - 1;\n\tvar node = octree.nodes[ nodeIndex ][0];\n\tvar x = node.max.x - node.min.x;\n\tvar y = node.max.y - node.min.y;\n\tvar z = node.max.z - node.min.z;\n\tvar geometry = new THREE.BoxGeometry(x, y, z);\n\tvar material = new THREE.MeshBasicMaterial({visible:false});\n\n\toctree.nodes[ nodeIndex ].forEach(function(node){\n\n\t\tvar x = node.max.x - node.min.x;\n\t\tvar y = node.max.y - node.min.y;\n\t\tvar z = node.max.z - node.min.z;\n\n\t\tvar mesh = new THREE.Mesh(geometry, material);\n\t\tvar helper = new THREE.EdgesHelper( mesh, 0xffff00 );\n\n\t\tmesh.position.set(\n\t\t\tnode.min.x + (x/2),\n\t\t\tnode.min.y + (y/2),\n\t\t\tnode.min.z + (z/2)\n\t\t);\n\n\t\toctreehelper.add( mesh, helper );\n\n\t\toctreeMeshHelpers.push(mesh);\n\t\toctreeEdgesHelpers.push(helper);\n\t});\n}\n\nfunction octreeNodeHelper( node ){\n\n\tvar x = node.max.x - node.min.x;\n\tvar y = node.max.y - node.min.y;\n\tvar z = node.max.z - node.min.z;\n\n\tvar geometry = new THREE.BoxGeometry(x, y, z);\n\tvar material = new THREE.MeshBasicMaterial({visible:false});\n\tvar mesh = new THREE.Mesh(geometry, material);\n\n\tmesh.position.set(\n\t\tnode.min.x + (x/2),\n\t\tnode.min.y + (y/2),\n\t\tnode.min.z + (z/2)\n\t);\n\n\toctreehelper.add( mesh );\n\toctreeMeshHelpers.push(mesh);\n\n\tvar helper = new THREE.EdgesHelper( mesh, 0xffff00 );\n\n\thelper.name = \"octree helper\";\n\toctreehelper.add( helper );\n\toctreeEdgesHelpers.push(helper);\n}\n\n/*\n//  Remove octree mesh helpers.\n    setTimeout(function(){\n        octreeMeshHelpers.forEach( function( item, i ){\n            octreehelper.remove( octreeMeshHelpers[i] );\n            var geometry = octreeMeshHelpers[i].geometry;\n            var material = octreeMeshHelpers[i].material;\n            geometry.dispose();\n            material.dispose();\n        });\n        console.log( \"octree mesh helpers has been removed.\" );\n    }, 5000);\n*/\n"
			}],
		"AF01D9C1-165B-477E-9DB6-3F8CC5BA7E3C": [
			{
				"name": "camera-light.js",
				"source": "defaultCameraLight = this;\n"
			}]
	},
	"camera": {
		"metadata": {
			"version": 4.4,
			"type": "Object",
			"generator": "Object3D.toJSON"
		},
		"object": {
			"uuid": "2354248D-2FAD-4239-908B-73D348845055",
			"type": "PerspectiveCamera",
			"name": "Camera",
			"matrix": [0.20020972192287445,2.351282502033314e-9,-0.9797530770301819,0,-0.3344773054122925,0.9399219751358032,-0.06834947317838669,0,0.9208914041519165,0.34138938784599304,0.18818150460720062,0,83.17349243164062,35.39167785644531,17.747600555419922,1],
			"fov": 50,
			"zoom": 1,
			"near": 0.1,
			"far": 10000,
			"focus": 10,
			"aspect": 1.05848623853211,
			"filmGauge": 35,
			"filmOffset": 0
		}
	},
	"scene": {
		"metadata": {
			"version": 4.4,
			"type": "Object",
			"generator": "Object3D.toJSON"
		},
		"object": {
			"uuid": "BCC3A53B-07C6-4FC3-B308-8F4A3E94469D",
			"type": "Scene",
			"name": "Scene",
			"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
			"children": [
				{
					"uuid": "AF01D9C1-165B-477E-9DB6-3F8CC5BA7E3C",
					"type": "DirectionalLight",
					"name": "Default Camera Light",
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,57.883541107177734,16.780786514282227,69.53287506103516,1],
					"color": 16777215,
					"intensity": 0.5
				},
				{
					"uuid": "9434477B-B3D8-4832-8154-CC8A8AD68FFC",
					"type": "Group",
					"name": "Lights",
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
					"children": [
						{
							"uuid": "11880467-1961-4E81-8D71-66BC39DFA18E",
							"type": "DirectionalLight",
							"name": "DirectionalLight 1",
							"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,50,50,1],
							"color": 16777215,
							"intensity": 0.5
						},
						{
							"uuid": "1F367C36-34FA-41A0-B723-1CB1D350E369",
							"type": "DirectionalLight",
							"name": "DirectionalLight 2",
							"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,-35,55,-35,1],
							"color": 16777215,
							"intensity": 0.5
						},
						{
							"uuid": "51FC0AE7-DB3F-49CF-8C6A-AFE849A0C554",
							"type": "DirectionalLight",
							"name": "DirectionalLight 3",
							"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,35,55,-35,1],
							"color": 16777215,
							"intensity": 0.5
						}]
				},
				{
					"uuid": "05902F26-E7A6-4875-8D13-70E2EF94E04E",
					"type": "Group",
					"name": "Ground Helper",
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
				},
				{
					"uuid": "3854A5B6-1389-4A5F-887D-950B553DAD02",
					"type": "Group",
					"name": "Octree Helpers",
					"visible": false,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
				},
				{
					"uuid": "A19C133A-E409-4607-B7BD-0E2698549750",
					"type": "Group",
					"name": "Animations Loader",
					"visible": false,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
				},
				{
					"uuid": "6AD93A00-35BA-4603-8634-129EA23AF066",
					"type": "Group",
					"name": "Skinned Meshes Loader",
					"visible": false,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
				}]
		}
	}
}