{
	"metadata": {
		"type": "App"
	},
	"project": {
		"vr": false,
		"cache": false,
		"editable": false,
		"debugMode": true,
		"shadows": true
	},
	"scripts": {
		"BCC3A53B-07C6-4FC3-B308-8F4A3E94469D": [
			{
				"name": "index.js",
				"source": "//\tdebguMode = true;\n//\tTHREE.Cache.enabled = true;\n\nvar projectId = {\n\tkind: \"app\",\n\tname: \"boilerplate (in-a-box)\",\n\tversion: \"4.1.0\",\n\tthreejs: \"r78\",\n\tdate: \"2019.09.24.23:50\", // \"YYYY.MM.DD.HH:mm\".\n\tdescription: \"Self boilerplate app made with threejs editor (r78)\",\n\trequired_libs: [\n\t\t\"command.js\",\n\t\t\"Objectid.js\",\n\t\t\"jquery.min.js\",\n\t\t\"rawinflate.js\",\n\t\t\"rawdeflate.js\",\n\t\t\"store2.min.js\",\n\t\t\"system.min.js\",\n\t\t\"zangodb.min.js\",\n\t\t\"signals.min.js\",\n\t\t\"bootbox.min.js\",\n\t\t\"validator.min.js\",\n\t\t\"bootstrap.min.js\",\n\t\t\"socketcluster.js\",\n\t\t\"DeviceDetector.js\",\n\t\t\"sc-codec-min-bin.js\",\n\t\t\"MathDecimalAdjustment.js\",\n\t//\tthreejs.\n\t\t\"UVsDebug.js\",\n\t\t\"Animation.js\",\n\t\t\"EditorControls.js\",\n\t\t\"AnimationHandler.js\",\n\t\t\"KeyFrameAnimation.js\",\n\t\t\"SubdivisionModifier.js\",\n\t],\n};\n\n//\tcontrols = new THREE.EditorControls(camera, renderer.domElement);\n"
			},
			{
				"name": "watch.js",
				"source": "/**\n * DEVELOPED BY\n * GIL LOPES BUENO\n * gilbueno.mail@gmail.com\n *\n * WORKS WITH:\n * IE8*, IE 9+, FF 4+, SF 5+, WebKit, CH 7+, OP 12+, BESEN, Rhino 1.7+\n * For IE8 (and other legacy browsers) WatchJS will use dirty checking  \n *\n * FORK:\n * https://github.com/melanke/Watch.JS\n *\n * LICENSE: MIT\n */\n\n\"use strict\";\n(function (factory) {\n    if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like enviroments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(factory);\n    } else {\n        // Browser globals\n        window.WatchJS = factory();\n        window.watch = window.WatchJS.watch;\n        window.unwatch = window.WatchJS.unwatch;\n        window.callWatchers = window.WatchJS.callWatchers;\n    }\n}(function () {\n\n    var WatchJS = {\n        noMore: false,        // use WatchJS.suspend(obj) instead\n        useDirtyCheck: false, // use only dirty checking to track changes.\n        preserveExistingSetters: false\n    },\n    lengthsubjects = [];\n    \n    var dirtyChecklist = [];\n    var pendingChanges = []; // used coalesce changes from defineProperty and __defineSetter__\n    \n    var supportDefineProperty = false;\n    try {\n        supportDefineProperty = Object.defineProperty && Object.defineProperty({},'x', {});\n    } catch(ex) {  /* not supported */  }\n\n    var isFunction = function (functionToCheck) {\n        var getType = {};\n        return functionToCheck && getType.toString.call(functionToCheck) == '[object Function]';\n    };\n\n    var isInt = function (x) {\n        return x % 1 === 0;\n    };\n\n    var isArray = function(obj) {\n        return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n\n    var isObject = function(obj) {\n        return {}.toString.apply(obj) === '[object Object]';\n    };\n    \n    var getObjDiff = function(a, b){\n        var aplus = [],\n        bplus = [];\n\n        if(!(typeof a == \"string\") && !(typeof b == \"string\")){\n\n            if (isArray(a) && b) {\n                for (var i=0; i<a.length; i++) {\n                    if (b[i] === undefined) aplus.push(i);\n                }\n            } else {\n                for(var i in a){\n                    if (a.hasOwnProperty(i)) {\n                        if(b && !b.hasOwnProperty(i)) {\n                            aplus.push(i);\n                        }\n                    }\n                }\n            }\n\n            if (isArray(b) && a) {\n                for (var j=0; j<b.length; j++) {\n                    if (a[j] === undefined) bplus.push(j);\n                }\n            } else {\n                for(var j in b){\n                    if (b.hasOwnProperty(j)) {\n                        if(a && !a.hasOwnProperty(j)) {\n                            bplus.push(j);\n                        }\n                    }\n                }\n            }\n        }\n\n        return {\n            added: aplus,\n            removed: bplus\n        }\n    };\n\n    var clone = function(obj){\n\n        if (null == obj || \"object\" != typeof obj) {\n            return obj;\n        }\n\n        var copy = obj.constructor();\n\n        for (var attr in obj) {\n            copy[attr] = obj[attr];\n        }\n\n        return copy;        \n\n    }\n\n    var getExistingSetter = function (obj, propName) {\n        if (WatchJS.preserveExistingSetters) {\n            var existing = Object.getOwnPropertyDescriptor(obj, propName);\n            return existing.set;\n        }\n\n        return undefined;\n    }\n\n    var defineGetAndSet = function (obj, propName, getter, setter) {\n        try {\n            var existingSetter = getExistingSetter(obj, propName);\n            Object.defineProperty(obj, propName, {\n                get: getter,\n                set: function(value) {\n                    setter.call(this, value, true); // coalesce changes\n                    if (existingSetter) {\n                        existingSetter(value);\n                    }\n                },\n                enumerable: true,\n                configurable: true\n            });\n        }\n        catch(e1) {\n            try{\n                Object.prototype.__defineGetter__.call(obj, propName, getter);\n                Object.prototype.__defineSetter__.call(obj, propName, function(value) {\n                    setter.call(this,value,true); // coalesce changes\n                });\n            }\n            catch(e2) {\n                observeDirtyChanges(obj,propName,setter);\n                //throw new Error(\"watchJS error: browser not supported :/\")\n            }\n        }\n\n    };\n\n    var defineProp = function (obj, propName, value) {\n        try {\n            Object.defineProperty(obj, propName, {\n                enumerable: false,\n                configurable: true,\n                writable: false,\n                value: value\n            });\n        } catch(error) {\n            obj[propName] = value;\n        }\n    };\n\n    var observeDirtyChanges = function(obj,propName,setter) {\n        dirtyChecklist[dirtyChecklist.length] = {\n            prop:       propName,\n            object:     obj,\n            orig:       clone(obj[propName]),\n            callback:   setter\n        }        \n    }\n    \n    var watch = function () {\n\n        if (isFunction(arguments[1])) {\n            watchAll.apply(this, arguments);\n        } else if (isArray(arguments[1])) {\n            watchMany.apply(this, arguments);\n        } else {\n            watchOne.apply(this, arguments);\n        }\n\n    };\n\n\n    var watchAll = function (obj, watcher, level, addNRemove) {\n\n        if ((typeof obj == \"string\") || (!(obj instanceof Object) && !isArray(obj))) { //accepts only objects and array (not string)\n            return;\n        }\n\n        if(isArray(obj)) {\n            defineWatcher(obj, \"__watchall__\", watcher, level); // watch all changes on the array\n            if (level===undefined||level > 0) {\n                for (var prop = 0; prop < obj.length; prop++) { // watch objects in array\n                   watchAll(obj[prop],watcher,level, addNRemove);\n                }\n            }\n        } \n        else {\n            var prop,props = [];\n            for (prop in obj) { //for each attribute if obj is an object\n                if (prop == \"$val\" || (!supportDefineProperty && prop === 'watchers')) {\n                    continue;\n                }\n\n                if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n                    props.push(prop); //put in the props\n                }\n            }\n            watchMany(obj, props, watcher, level, addNRemove); //watch all items of the props\n        }\n\n\n        if (addNRemove) {\n            pushToLengthSubjects(obj, \"$$watchlengthsubjectroot\", watcher, level);\n        }\n    };\n\n\n    var watchMany = function (obj, props, watcher, level, addNRemove) {\n\n        if ((typeof obj == \"string\") || (!(obj instanceof Object) && !isArray(obj))) { //accepts only objects and array (not string)\n            return;\n        }\n\n        for (var i=0; i<props.length; i++) { //watch each property\n            var prop = props[i];\n            watchOne(obj, prop, watcher, level, addNRemove);\n        }\n\n    };\n\n    var watchOne = function (obj, prop, watcher, level, addNRemove) {\n        if ((typeof obj == \"string\") || (!(obj instanceof Object) && !isArray(obj))) { //accepts only objects and array (not string)\n            return;\n        }\n\n        if(isFunction(obj[prop])) { //dont watch if it is a function\n            return;\n        }\n        if(obj[prop] != null && (level === undefined || level > 0)){\n            watchAll(obj[prop], watcher, level!==undefined? level-1 : level); //recursively watch all attributes of this\n        }\n\n        defineWatcher(obj, prop, watcher, level);\n\n        if(addNRemove && (level === undefined || level > 0)){\n            pushToLengthSubjects(obj, prop, watcher, level);\n        }\n\n    };\n\n    var unwatch = function () {\n\n        if (isFunction(arguments[1])) {\n            unwatchAll.apply(this, arguments);\n        } else if (isArray(arguments[1])) {\n            unwatchMany.apply(this, arguments);\n        } else {\n            unwatchOne.apply(this, arguments);\n        }\n\n    };\n\n    var unwatchAll = function (obj, watcher) {\n\n        if (obj instanceof String || (!(obj instanceof Object) && !isArray(obj))) { //accepts only objects and array (not string)\n            return;\n        }\n\n        if (isArray(obj)) {\n            var props = ['__watchall__'];\n            for (var prop = 0; prop < obj.length; prop++) { //for each item if obj is an array\n                props.push(prop); //put in the props\n            }\n            unwatchMany(obj, props, watcher); //watch all itens of the props\n        } else {\n            var unwatchPropsInObject = function (obj2) {\n                var props = [];\n                for (var prop2 in obj2) { //for each attribute if obj is an object\n                    if (obj2.hasOwnProperty(prop2)) {\n                        if (obj2[prop2] instanceof Object) {\n                            unwatchPropsInObject(obj2[prop2]); //recurs into object props\n                        } else {\n                            props.push(prop2); //put in the props\n                        }\n                    }\n                }\n                unwatchMany(obj2, props, watcher); //unwatch all of the props\n            };\n            unwatchPropsInObject(obj);\n        }\n    };\n\n\n    var unwatchMany = function (obj, props, watcher) {\n\n        for (var prop2 in props) { //watch each attribute of \"props\" if is an object\n            if (props.hasOwnProperty(prop2)) {\n                unwatchOne(obj, props[prop2], watcher);\n            }\n        }\n    };\n\n    var timeouts = [],\n        timerID = null;\n    function clearTimerID() {\n        timerID = null;\n        for(var i=0; i< timeouts.length; i++) {\n            timeouts[i]();\n        }\n        timeouts.length = 0;\n    }\n    var getTimerID= function () {\n        if (!timerID)  {\n            timerID = setTimeout(clearTimerID);\n        }\n        return timerID;\n    }\n    var registerTimeout = function(fn) { // register function to be called on timeout\n        if (timerID==null) getTimerID();\n        timeouts[timeouts.length] = fn;\n    }\n    \n    // Track changes made to an array, object or an object's property \n    // and invoke callback with a single change object containing type, value, oldvalue and array splices\n    // Syntax: \n    //      trackChange(obj, callback, recursive, addNRemove)\n    //      trackChange(obj, prop, callback, recursive, addNRemove)\n    var trackChange = function() {\n        var fn = (isFunction(arguments[2])) ? trackProperty : trackObject ;\n        fn.apply(this,arguments);\n    }\n\n    // track changes made to an object and invoke callback with a single change object containing type, value and array splices\n    var trackObject= function(obj, callback, recursive, addNRemove) {\n        var change = null,lastTimerID = -1;\n        var isArr = isArray(obj);\n        var level,fn = function(prop, action, newValue, oldValue) {\n            var timerID = getTimerID();\n            if (lastTimerID!==timerID) { // check if timer has changed since last update\n                lastTimerID = timerID;\n                change = {\n                    type: 'update'\n                }\n                change['value'] = obj;\n                change['splices'] = null;\n                registerTimeout(function() {\n                    callback.call(this,change);\n                    change = null;\n                });\n            }\n            // create splices for array changes\n            if (isArr && obj === this && change !== null)  {                \n                if (action==='pop'||action==='shift') {\n                    newValue = [];\n                    oldValue = [oldValue];\n                }\n                else if (action==='push'||action==='unshift') {\n                    newValue = [newValue];\n                    oldValue = [];\n                }\n                else if (action!=='splice') { \n                    return; // return here - for reverse and sort operations we don't need to return splices. a simple update will do\n                }\n                if (!change.splices) change.splices = [];\n                change.splices[change.splices.length] = {\n                    index: prop,\n                    deleteCount: oldValue ? oldValue.length : 0,\n                    addedCount: newValue ? newValue.length : 0,\n                    added: newValue,\n                    deleted: oldValue\n                };\n            }\n\n        }  \n        level = (recursive==true) ? undefined : 0;        \n        watchAll(obj,fn, level, addNRemove);\n    }\n    \n    // track changes made to the property of an object and invoke callback with a single change object containing type, value, oldvalue and splices\n    var trackProperty = function(obj,prop,callback,recursive, addNRemove) { \n        if (obj && prop) {\n            watchOne(obj,prop,function(prop, action, newvalue, oldvalue) {\n                var change = {\n                    type: 'update'\n                }\n                change['value'] = newvalue;\n                change['oldvalue'] = oldvalue;\n                if (recursive && isObject(newvalue)||isArray(newvalue)) {\n                    trackObject(newvalue,callback,recursive, addNRemove);\n                }               \n                callback.call(this,change);\n            },0)\n            \n            if (recursive && isObject(obj[prop])||isArray(obj[prop])) {\n                trackObject(obj[prop],callback,recursive, addNRemove);\n            }                           \n        }\n    }\n    \n    \n    var defineWatcher = function (obj, prop, watcher, level) {\n        var newWatcher = false;\n        var isArr = isArray(obj);\n        \n        if (!obj.watchers) {\n            defineProp(obj, \"watchers\", {});\n            if (isArr) {\n                // watch array functions\n                watchFunctions(obj, function(index,action,newValue, oldValue) {\n                    addPendingChange(obj, index, action,newValue, oldValue);\n                    if (level !== 0 && newValue && (isObject(newValue) || isArray(newValue))) {\n                        var i,n, ln, wAll, watchList = obj.watchers[prop];\n                        if ((wAll = obj.watchers['__watchall__'])) {\n                            watchList = watchList ? watchList.concat(wAll) : wAll;\n                        }\n                        ln = watchList ?  watchList.length : 0;\n                        for (i = 0; i<ln; i++) {\n                            if (action!=='splice') {\n                                watchAll(newValue, watchList[i], (level===undefined)?level:level-1);\n                            }\n                            else {\n                                // watch spliced values\n                                for(n=0; n < newValue.length; n++) {\n                                    watchAll(newValue[n], watchList[i], (level===undefined)?level:level-1);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n        }\n\n        if (!obj.watchers[prop]) {\n            obj.watchers[prop] = [];\n            if (!isArr) newWatcher = true;\n        }\n\n        for (var i=0; i<obj.watchers[prop].length; i++) {\n            if(obj.watchers[prop][i] === watcher){\n                return;\n            }\n        }\n\n        obj.watchers[prop].push(watcher); //add the new watcher to the watchers array\n\n        if (newWatcher) {\n            var val = obj[prop];            \n            var getter = function () {\n                return val;                        \n            };\n\n            var setter = function (newval, delayWatcher) {\n                var oldval = val;\n                val = newval;                \n                if (level !== 0 \n                    && obj[prop] && (isObject(obj[prop]) || isArray(obj[prop]))\n                    && !obj[prop].watchers) {\n                    // watch sub properties\n                    var i,ln = obj.watchers[prop].length; \n                    for(i=0; i<ln; i++) {\n                        watchAll(obj[prop], obj.watchers[prop][i], (level===undefined)?level:level-1);\n                    }\n                }\n\n                //watchFunctions(obj, prop);\n                \n                if (isSuspended(obj, prop)) {\n                    resume(obj, prop);\n                    return;\n                }\n\n                if (!WatchJS.noMore){ // this does not work with Object.observe\n                    //if (JSON.stringify(oldval) !== JSON.stringify(newval)) {\n                    if (oldval !== newval) {\n                        if (!delayWatcher) {\n                            callWatchers(obj, prop, \"set\", newval, oldval);\n                        }\n                        else {\n                            addPendingChange(obj, prop, \"set\", newval, oldval);\n                        }\n                        WatchJS.noMore = false;\n                    }\n                }\n            };\n\n            if (WatchJS.useDirtyCheck) {\n                observeDirtyChanges(obj,prop,setter);\n            }\n            else {\n                defineGetAndSet(obj, prop, getter, setter);\n            }\n        }\n\n    };\n\n    var callWatchers = function (obj, prop, action, newval, oldval) {\n        if (prop !== undefined) {\n            var ln, wl, watchList = obj.watchers[prop];\n            if ((wl = obj.watchers['__watchall__'])) {\n                watchList = watchList ? watchList.concat(wl) : wl;\n            }\n            ln = watchList ? watchList.length : 0;\n            for (var wr=0; wr< ln; wr++) {\n                watchList[wr].call(obj, prop, action, newval, oldval);\n            }\n        } else {\n            for (var prop in obj) {//call all\n                if (obj.hasOwnProperty(prop)) {\n                    callWatchers(obj, prop, action, newval, oldval);\n                }\n            }\n        }\n    };\n\n    var methodNames = ['pop', 'push', 'reverse', 'shift', 'sort', 'slice', 'unshift', 'splice'];\n    var defineArrayMethodWatcher = function (obj, original, methodName, callback) {\n        defineProp(obj, methodName, function () {\n            var index = 0;\n            var i,newValue, oldValue, response;                        \n            // get values before splicing array \n            if (methodName === 'splice') {\n               var start = arguments[0];\n               var end = start + arguments[1];\n               oldValue = obj.slice(start,end);\n               newValue = [];\n               for(i=2;i<arguments.length;i++) {\n                   newValue[i-2] = arguments[i];\n               }\n               index = start;\n            } \n            else {\n                newValue = arguments.length > 0 ? arguments[0] : undefined;\n            } \n\n            response = original.apply(obj, arguments);\n            if (methodName !== 'slice') {\n                if (methodName === 'pop') {\n                    oldValue = response;\n                    index = obj.length;\n                }\n                else if (methodName === 'push') {\n                    index = obj.length-1;\n                }\n                else if (methodName === 'shift') {\n                    oldValue = response;\n                }\n                else if (methodName !== 'unshift' && newValue===undefined) {\n                    newValue = response;\n                }\n                callback.call(obj, index, methodName,newValue, oldValue)\n            }\n            return response;\n        });\n    };\n\n    var watchFunctions = function(obj, callback) {\n\n        if (!isFunction(callback) || !obj || (obj instanceof String) || (!isArray(obj))) {\n            return;\n        }\n\n        for (var i = methodNames.length, methodName; i--;) {\n            methodName = methodNames[i];\n            defineArrayMethodWatcher(obj, obj[methodName], methodName, callback);\n        }\n\n    };\n\n    var unwatchOne = function (obj, prop, watcher) {\n        if (prop) {\n            if (obj.watchers && obj.watchers[prop]) {\n                if (watcher === undefined) {\n                    delete obj.watchers[prop]; // remove all property watchers\n                }\n                else {\n                    for (var i = 0; i < obj.watchers[prop].length; i++) {\n                        var w = obj.watchers[prop][i];\n                        if (w == watcher) {\n                            obj.watchers[prop].splice(i, 1);\n                        }\n                    }\n                }\n            }\n        } else {\n            delete obj.watchers;\n        }\n\n        removeFromLengthSubjects(obj, prop, watcher);\n        removeFromDirtyChecklist(obj, prop);\n    };\n    \n    // suspend watchers until next update cycle\n    var suspend = function(obj, prop) {\n        if (obj.watchers) {\n            var name = '__wjs_suspend__'+(prop!==undefined ? prop : '');\n            obj.watchers[name] = true;\n        }\n    }\n    \n    var isSuspended = function(obj, prop) {\n        return obj.watchers \n               && (obj.watchers['__wjs_suspend__'] || \n                   obj.watchers['__wjs_suspend__'+prop]);\n    }\n    \n    // resumes preivously suspended watchers\n    var resume = function(obj, prop) {\n        registerTimeout(function() {\n            delete obj.watchers['__wjs_suspend__'];\n            delete obj.watchers['__wjs_suspend__'+prop];\n        })\n    }\n\n    var pendingTimerID = null;\n    var addPendingChange = function(obj,prop, mode, newval, oldval) {\n        pendingChanges[pendingChanges.length] = {\n            obj:obj,\n            prop: prop,\n            mode: mode,\n            newval: newval,\n            oldval: oldval\n        };\n        if (pendingTimerID===null) {\n            pendingTimerID = setTimeout(applyPendingChanges);\n        }\n    };\n    \n    \n    var applyPendingChanges = function()  {\n        // apply pending changes\n        var change = null;\n        pendingTimerID = null;\n        for(var i=0;i < pendingChanges.length;i++) {\n            change = pendingChanges[i];\n            callWatchers(change.obj, change.prop, change.mode, change.newval, change.oldval);\n        }\n        if (change) {\n            pendingChanges = [];\n            change = null;\n        }        \n    }\n\n    var loop = function(){\n\n        // check for new or deleted props\n        for(var i=0; i<lengthsubjects.length; i++) {\n\n            var subj = lengthsubjects[i];\n\n            if (subj.prop === \"$$watchlengthsubjectroot\") {\n\n                var difference = getObjDiff(subj.obj, subj.actual);\n\n                if(difference.added.length || difference.removed.length){\n                    if(difference.added.length){\n                        watchMany(subj.obj, difference.added, subj.watcher, subj.level - 1, true);\n                    }\n\n                    subj.watcher.call(subj.obj, \"root\", \"differentattr\", difference, subj.actual);\n                }\n                subj.actual = clone(subj.obj);\n\n\n            } else {\n\n                var difference = getObjDiff(subj.obj[subj.prop], subj.actual);\n\n                if(difference.added.length || difference.removed.length){\n                    if(difference.added.length){\n                        for (var j=0; j<subj.obj.watchers[subj.prop].length; j++) {\n                            watchMany(subj.obj[subj.prop], difference.added, subj.obj.watchers[subj.prop][j], subj.level - 1, true);\n                        }\n                    }\n\n                    callWatchers(subj.obj, subj.prop, \"differentattr\", difference, subj.actual);\n                }\n\n                subj.actual = clone(subj.obj[subj.prop]);\n\n            }\n\n        }\n        \n        // start dirty check\n        var n, value;\n        if (dirtyChecklist.length > 0) {\n            for (var i = 0; i < dirtyChecklist.length; i++) {\n                n = dirtyChecklist[i];\n                value = n.object[n.prop];\n                if (!compareValues(n.orig, value)) {\n                    n.orig = clone(value);\n                    n.callback(value);\n                }\n            }\n        }\n\n    };\n\n    var compareValues =  function(a,b) {\n        var i, state = true;\n        if (a!==b)  {\n            if (isObject(a)) {\n                for(i in a) {\n                    if (!supportDefineProperty && i==='watchers') continue;\n                    if (a[i]!==b[i]) {\n                        state = false;\n                        break;\n                    };\n                }\n            }\n            else {\n                state = false;\n            }\n        }\n        return state;\n    }\n    \n    var pushToLengthSubjects = function(obj, prop, watcher, level){\n\n        var actual;\n\n        if (prop === \"$$watchlengthsubjectroot\") {\n            actual =  clone(obj);\n        } else {\n            actual = clone(obj[prop]);\n        }\n\n        lengthsubjects.push({\n            obj: obj,\n            prop: prop,\n            actual: actual,\n            watcher: watcher,\n            level: level\n        });\n    };\n\n    var removeFromLengthSubjects = function(obj, prop, watcher){\n        for (var i=0; i<lengthsubjects.length; i++) {\n            var subj = lengthsubjects[i];\n\n            if (subj.obj == obj) {\n                if (!prop || subj.prop == prop) {\n                    if (!watcher || subj.watcher == watcher) {\n                        // if we splice off one item at position i\n                        // we need to decrement i as the array is one item shorter\n                        // so when we increment i in the loop statement we\n                        // will land at the correct index.\n                        // if it's not decremented, you won't delete all length subjects\n                        lengthsubjects.splice(i--, 1);\n                    }\n                }\n            }\n        }\n\n    };\n    \n    var removeFromDirtyChecklist = function(obj, prop){\n        var notInUse;\n        for (var i=0; i<dirtyChecklist.length; i++) {\n            var n = dirtyChecklist[i];\n            var watchers = n.object.watchers;\n            notInUse = (\n                n.object == obj \n                && (!prop || n.prop == prop)\n                && watchers\n                && (!prop || !watchers[prop] || watchers[prop].length == 0 )\n            );\n            if (notInUse)  {\n                // we use the same syntax as in removeFromLengthSubjects\n                dirtyChecklist.splice(i--, 1);\n            }\n        }\n\n    };    \n\n    setInterval(loop, 50);\n\n    WatchJS.watch = watch;\n    WatchJS.unwatch = unwatch;\n    WatchJS.callWatchers = callWatchers;\n    WatchJS.suspend = suspend; // suspend watchers    \n    WatchJS.onChange = trackChange;  // track changes made to object or  it's property and return a single change object\n\n    return WatchJS;\n\n}));\n"
			},
			{
				"name": "Animation.js",
				"source": "/**\n * @author mikael emtinger / http://gomo.se/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Animation = function ( root, data ) {\n\n\tthis.root = root;\n\tthis.data = THREE.AnimationHandler.init( data );\n\tthis.hierarchy = THREE.AnimationHandler.parse( root );\n\n\tthis.currentTime = 0;\n\tthis.timeScale = 1;\n\n\tthis.isPlaying = false;\n\tthis.loop = true;\n\tthis.weight = 0;\n\n\tthis.interpolationType = THREE.AnimationHandler.LINEAR;\n\n};\n\nTHREE.Animation.prototype = {\n\n\tconstructor: THREE.Animation,\n\n\tkeyTypes:  [ \"pos\", \"rot\", \"scl\" ],\n\n\tplay: function ( startTime, weight ) {\n\n\t\tthis.currentTime = startTime !== undefined ? startTime : 0;\n\t\tthis.weight = weight !== undefined ? weight : 1;\n\n\t\tthis.isPlaying = true;\n\n\t\tthis.reset();\n\n\t\tTHREE.AnimationHandler.play( this );\n\n\t},\n\n\tstop: function() {\n\n\t\tthis.isPlaying = false;\n\n\t\tTHREE.AnimationHandler.stop( this );\n\n\t},\n\n\treset: function () {\n\n\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\n\n\t\t\tvar object = this.hierarchy[ h ];\n\n\t\t\tif ( object.animationCache === undefined ) {\n\n\t\t\t\tobject.animationCache = {\n\t\t\t\t\tanimations: {},\n\t\t\t\t\tblending: {\n\t\t\t\t\t\tpositionWeight: 0.0,\n\t\t\t\t\t\tquaternionWeight: 0.0,\n\t\t\t\t\t\tscaleWeight: 0.0\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar name = this.data.name;\n\t\t\tvar animations = object.animationCache.animations;\n\t\t\tvar animationCache = animations[ name ];\n\n\t\t\tif ( animationCache === undefined ) {\n\n\t\t\t\tanimationCache = {\n\t\t\t\t\tprevKey: { pos: 0, rot: 0, scl: 0 },\n\t\t\t\t\tnextKey: { pos: 0, rot: 0, scl: 0 },\n\t\t\t\t\toriginalMatrix: object.matrix\n\t\t\t\t};\n\n\t\t\t\tanimations[ name ] = animationCache;\n\n\t\t\t}\n\n\t\t\t// Get keys to match our current time\n\n\t\t\tfor ( var t = 0; t < 3; t ++ ) {\n\n\t\t\t\tvar type = this.keyTypes[ t ];\n\n\t\t\t\tvar prevKey = this.data.hierarchy[ h ].keys[ 0 ];\n\t\t\t\tvar nextKey = this.getNextKeyWith( type, h, 1 );\n\n\t\t\t\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\n\n\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\n\n\t\t\t\t}\n\n\t\t\t\tanimationCache.prevKey[ type ] = prevKey;\n\t\t\t\tanimationCache.nextKey[ type ] = nextKey;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tresetBlendWeights: function () {\n\n\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\n\n\t\t\tvar object = this.hierarchy[ h ];\n\t\t\tvar animationCache = object.animationCache;\n\n\t\t\tif ( animationCache !== undefined ) {\n\n\t\t\t\tvar blending = animationCache.blending;\n\n\t\t\t\tblending.positionWeight = 0.0;\n\t\t\t\tblending.quaternionWeight = 0.0;\n\t\t\t\tblending.scaleWeight = 0.0;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdate: ( function() {\n\n\t\tvar points = [];\n\t\tvar target = new THREE.Vector3();\n\t\tvar newVector = new THREE.Vector3();\n\t\tvar newQuat = new THREE.Quaternion();\n\n\t\t// Catmull-Rom spline\n\n\t\tvar interpolateCatmullRom = function ( points, scale ) {\n\n\t\t\tvar c = [], v3 = [],\n\t\t\tpoint, intPoint, weight, w2, w3,\n\t\t\tpa, pb, pc, pd;\n\n\t\t\tpoint = ( points.length - 1 ) * scale;\n\t\t\tintPoint = Math.floor( point );\n\t\t\tweight = point - intPoint;\n\n\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\t\tc[ 1 ] = intPoint;\n\t\t\tc[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;\n\t\t\tc[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;\n\n\t\t\tpa = points[ c[ 0 ] ];\n\t\t\tpb = points[ c[ 1 ] ];\n\t\t\tpc = points[ c[ 2 ] ];\n\t\t\tpd = points[ c[ 3 ] ];\n\n\t\t\tw2 = weight * weight;\n\t\t\tw3 = weight * w2;\n\n\t\t\tv3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );\n\t\t\tv3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );\n\t\t\tv3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );\n\n\t\t\treturn v3;\n\n\t\t};\n\n\t\tvar interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {\n\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t\t};\n\n\t\treturn function ( delta ) {\n\n\t\t\tif ( this.isPlaying === false ) return;\n\n\t\t\tthis.currentTime += delta * this.timeScale;\n\n\t\t\tif ( this.weight === 0 )\n\t\t\t\treturn;\n\n\t\t\t//\n\n\t\t\tvar duration = this.data.length;\n\n\t\t\tif ( this.currentTime > duration || this.currentTime < 0 ) {\n\n\t\t\t\tif ( this.loop ) {\n\n\t\t\t\t\tthis.currentTime %= duration;\n\n\t\t\t\t\tif ( this.currentTime < 0 )\n\t\t\t\t\t\tthis.currentTime += duration;\n\n\t\t\t\t\tthis.reset();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.stop();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\n\n\t\t\t\tvar object = this.hierarchy[ h ];\n\t\t\t\tvar animationCache = object.animationCache.animations[ this.data.name ];\n\t\t\t\tvar blending = object.animationCache.blending;\n\n\t\t\t\t// loop through pos/rot/scl\n\n\t\t\t\tfor ( var t = 0; t < 3; t ++ ) {\n\n\t\t\t\t\t// get keys\n\n\t\t\t\t\tvar type    = this.keyTypes[ t ];\n\t\t\t\t\tvar prevKey = animationCache.prevKey[ type ];\n\t\t\t\t\tvar nextKey = animationCache.nextKey[ type ];\n\n\t\t\t\t\tif ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||\n\t\t\t\t\t\t( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {\n\n\t\t\t\t\t\tprevKey = this.data.hierarchy[ h ].keys[ 0 ];\n\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, 1 );\n\n\t\t\t\t\t\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\n\n\t\t\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tanimationCache.prevKey[ type ] = prevKey;\n\t\t\t\t\t\tanimationCache.nextKey[ type ] = nextKey;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );\n\n\t\t\t\t\tvar prevXYZ = prevKey[ type ];\n\t\t\t\t\tvar nextXYZ = nextKey[ type ];\n\n\t\t\t\t\tif ( scale < 0 ) scale = 0;\n\t\t\t\t\tif ( scale > 1 ) scale = 1;\n\n\t\t\t\t\t// interpolate\n\n\t\t\t\t\tif ( type === \"pos\" ) {\n\n\t\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {\n\n\t\t\t\t\t\t\tnewVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\n\t\t\t\t\t\t\tnewVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\n\t\t\t\t\t\t\tnewVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\n\n\t\t\t\t\t\t\t// blend\n\t\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.positionWeight );\n\t\t\t\t\t\t\tobject.position.lerp( newVector, proportionalWeight );\n\t\t\t\t\t\t\tblending.positionWeight += this.weight;\n\n\t\t\t\t\t\t} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\n\t\t\t\t\t\t\t\t\tthis.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\t\t\t\t\t\tpoints[ 0 ] = this.getPrevKeyWith( \"pos\", h, prevKey.index - 1 )[ \"pos\" ];\n\t\t\t\t\t\t\tpoints[ 1 ] = prevXYZ;\n\t\t\t\t\t\t\tpoints[ 2 ] = nextXYZ;\n\t\t\t\t\t\t\tpoints[ 3 ] = this.getNextKeyWith( \"pos\", h, nextKey.index + 1 )[ \"pos\" ];\n\n\t\t\t\t\t\t\tscale = scale * 0.33 + 0.33;\n\n\t\t\t\t\t\t\tvar currentPoint = interpolateCatmullRom( points, scale );\n\t\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.positionWeight );\n\t\t\t\t\t\t\tblending.positionWeight += this.weight;\n\n\t\t\t\t\t\t\t// blend\n\n\t\t\t\t\t\t\tvar vector = object.position;\n\n\t\t\t\t\t\t\tvector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;\n\t\t\t\t\t\t\tvector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;\n\t\t\t\t\t\t\tvector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;\n\n\t\t\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\t\t\t\t\t\t\tvar forwardPoint = interpolateCatmullRom( points, scale * 1.01 );\n\n\t\t\t\t\t\t\t\ttarget.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );\n\t\t\t\t\t\t\t\ttarget.sub( vector );\n\t\t\t\t\t\t\t\ttarget.y = 0;\n\t\t\t\t\t\t\t\ttarget.normalize();\n\n\t\t\t\t\t\t\t\tvar angle = Math.atan2( target.x, target.z );\n\t\t\t\t\t\t\t\tobject.rotation.set( 0, angle, 0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( type === \"rot\" ) {\n\n\t\t\t\t\t\tTHREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );\n\n\t\t\t\t\t\t// Avoid paying the cost of an additional slerp if we don't have to\n\t\t\t\t\t\tif ( blending.quaternionWeight === 0 ) {\n\n\t\t\t\t\t\t\tobject.quaternion.copy( newQuat );\n\t\t\t\t\t\t\tblending.quaternionWeight = this.weight;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );\n\t\t\t\t\t\t\tTHREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );\n\t\t\t\t\t\t\tblending.quaternionWeight += this.weight;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( type === \"scl\" ) {\n\n\t\t\t\t\t\tnewVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\n\t\t\t\t\t\tnewVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\n\t\t\t\t\t\tnewVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\n\n\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );\n\t\t\t\t\t\tobject.scale.lerp( newVector, proportionalWeight );\n\t\t\t\t\t\tblending.scaleWeight += this.weight;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t};\n\n\t} )(),\n\n\tgetNextKeyWith: function ( type, h, key ) {\n\n\t\tvar keys = this.data.hierarchy[ h ].keys;\n\n\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\n\t\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\t\tkey = key < keys.length - 1 ? key : keys.length - 1;\n\n\t\t} else {\n\n\t\t\tkey = key % keys.length;\n\n\t\t}\n\n\t\tfor ( ; key < keys.length; key ++ ) {\n\n\t\t\tif ( keys[ key ][ type ] !== undefined ) {\n\n\t\t\t\treturn keys[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this.data.hierarchy[ h ].keys[ 0 ];\n\n\t},\n\n\tgetPrevKeyWith: function ( type, h, key ) {\n\n\t\tvar keys = this.data.hierarchy[ h ].keys;\n\n\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\n\t\t\tthis.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\t\tkey = key > 0 ? key : 0;\n\n\t\t} else {\n\n\t\t\tkey = key >= 0 ? key : key + keys.length;\n\n\t\t}\n\n\n\t\tfor ( ; key >= 0; key -- ) {\n\n\t\t\tif ( keys[ key ][ type ] !== undefined ) {\n\n\t\t\t\treturn keys[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this.data.hierarchy[ h ].keys[ keys.length - 1 ];\n\n\t}\n\n};\n"
			},
			{
				"name": "AnimationHandler.js",
				"source": "/**\n * @author mikael emtinger / http://gomo.se/\n */\n\nTHREE.AnimationHandler = {\n\n\tLINEAR: 0,\n\tCATMULLROM: 1,\n\tCATMULLROM_FORWARD: 2,\n\n\t//\n\n\tadd: function () {\n\n\t\tconsole.warn( 'THREE.AnimationHandler.add() has been deprecated.' );\n\n\t},\n\tget: function () {\n\n\t\tconsole.warn( 'THREE.AnimationHandler.get() has been deprecated.' );\n\n\t},\n\tremove: function () {\n\n\t\tconsole.warn( 'THREE.AnimationHandler.remove() has been deprecated.' );\n\n\t},\n\n\t//\n\n\tanimations: [],\n\n\tinit: function ( data ) {\n\n\t\tif ( data.initialized === true ) return data;\n\n\t\t// loop through all keys\n\n\t\tfor ( var h = 0; h < data.hierarchy.length; h ++ ) {\n\n\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\t// remove minus times\n\n\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].time < 0 ) {\n\n\t\t\t\t\t data.hierarchy[ h ].keys[ k ].time = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// create quaternions\n\n\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&\n\t\t\t\t  ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {\n\n\t\t\t\t\tvar quat = data.hierarchy[ h ].keys[ k ].rot;\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// prepare morph target keys\n\n\t\t\tif ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {\n\n\t\t\t\t// get all used\n\n\t\t\t\tvar usedMorphTargets = {};\n\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\tvar morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];\n\t\t\t\t\t\tusedMorphTargets[ morphTargetName ] = - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tdata.hierarchy[ h ].usedMorphTargets = usedMorphTargets;\n\n\n\t\t\t\t// set all used on all frames\n\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\t\tvar influences = {};\n\n\t\t\t\t\tfor ( var morphTargetName in usedMorphTargets ) {\n\n\t\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {\n\n\t\t\t\t\t\t\t\tinfluences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {\n\n\t\t\t\t\t\t\tinfluences[ morphTargetName ] = 0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// remove all keys that are on the same time\n\n\t\t\tfor ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {\n\n\t\t\t\t\tdata.hierarchy[ h ].keys.splice( k, 1 );\n\t\t\t\t\tk --;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// set index\n\n\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\tdata.hierarchy[ h ].keys[ k ].index = k;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdata.initialized = true;\n\n\t\treturn data;\n\n\t},\n\n\tparse: function ( root ) {\n\n\t\tvar parseRecurseHierarchy = function ( root, hierarchy ) {\n\n\t\t\thierarchy.push( root );\n\n\t\t\tfor ( var c = 0; c < root.children.length; c ++ )\n\t\t\t\tparseRecurseHierarchy( root.children[ c ], hierarchy );\n\n\t\t};\n\n\t\t// setup hierarchy\n\n\t\tvar hierarchy = [];\n\n\t\tif ( root instanceof THREE.SkinnedMesh ) {\n\n\t\t\tfor ( var b = 0; b < root.skeleton.bones.length; b ++ ) {\n\n\t\t\t\thierarchy.push( root.skeleton.bones[ b ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tparseRecurseHierarchy( root, hierarchy );\n\n\t\t}\n\n\t\treturn hierarchy;\n\n\t},\n\n\tplay: function ( animation ) {\n\n\t\tif ( this.animations.indexOf( animation ) === - 1 ) {\n\n\t\t\tthis.animations.push( animation );\n\n\t\t}\n\n\t},\n\n\tstop: function ( animation ) {\n\n\t\tvar index = this.animations.indexOf( animation );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.animations.splice( index, 1 );\n\n\t\t}\n\n\t},\n\n\tupdate: function ( deltaTimeMS ) {\n\n\t\tfor ( var i = 0; i < this.animations.length; i ++ ) {\n\n\t\t\tthis.animations[ i ].resetBlendWeights();\n\n\t\t}\n\n\t\tfor ( var i = 0; i < this.animations.length; i ++ ) {\n\n\t\t\tthis.animations[ i ].update( deltaTimeMS );\n\n\t\t}\n\n\t}\n\n};\n"
			},
			{
				"name": "KeyFrameAnimation.js",
				"source": "/**\n * @author mikael emtinger / http://gomo.se/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author khang duong\n * @author erik kitson\n */\n\nTHREE.KeyFrameAnimation = function ( data ) {\n\n\tthis.root = data.node;\n\tthis.data = THREE.AnimationHandler.init( data );\n\tthis.hierarchy = THREE.AnimationHandler.parse( this.root );\n\tthis.currentTime = 0;\n\tthis.timeScale = 0.001;\n\tthis.isPlaying = false;\n\tthis.isPaused = true;\n\tthis.loop = true;\n\n\t// initialize to first keyframes\n\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\n\n\t\tvar keys = this.data.hierarchy[ h ].keys,\n\t\t\tsids = this.data.hierarchy[ h ].sids,\n\t\t\tobj = this.hierarchy[ h ];\n\n\t\tif ( keys.length && sids ) {\n\n\t\t\tfor ( var s = 0; s < sids.length; s ++ ) {\n\n\t\t\t\tvar sid = sids[ s ],\n\t\t\t\t\tnext = this.getNextKeyWith( sid, h, 0 );\n\n\t\t\t\tif ( next ) {\n\n\t\t\t\t\tnext.apply( sid );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tobj.matrixAutoUpdate = false;\n\t\t\tthis.data.hierarchy[ h ].node.updateMatrix();\n\t\t\tobj.matrixWorldNeedsUpdate = true;\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.KeyFrameAnimation.prototype = {\n\n\tconstructor: THREE.KeyFrameAnimation,\n\n\tplay: function ( startTime ) {\n\n\t\tthis.currentTime = startTime !== undefined ? startTime : 0;\n\n\t\tif ( this.isPlaying === false ) {\n\n\t\t\tthis.isPlaying = true;\n\n\t\t\t// reset key cache\n\n\t\t\tvar h, hl = this.hierarchy.length,\n\t\t\t\tobject,\n\t\t\t\tnode;\n\n\t\t\tfor ( h = 0; h < hl; h ++ ) {\n\n\t\t\t\tobject = this.hierarchy[ h ];\n\t\t\t\tnode = this.data.hierarchy[ h ];\n\n\t\t\t\tif ( node.animationCache === undefined ) {\n\n\t\t\t\t\tnode.animationCache = {};\n\t\t\t\t\tnode.animationCache.prevKey = null;\n\t\t\t\t\tnode.animationCache.nextKey = null;\n\t\t\t\t\tnode.animationCache.originalMatrix = object.matrix;\n\n\t\t\t\t}\n\n\t\t\t\tvar keys = this.data.hierarchy[ h ].keys;\n\n\t\t\t\tif ( keys.length > 1 ) {\n\n\t\t\t\t\tnode.animationCache.prevKey = keys[ 0 ];\n\t\t\t\t\tnode.animationCache.nextKey = keys[ 1 ];\n\n\t\t\t\t\tthis.startTime = Math.min( keys[ 0 ].time, this.startTime );\n\t\t\t\t\tthis.endTime = Math.max( keys[ keys.length - 1 ].time, this.endTime );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.update( 0 );\n\n\t\t}\n\n\t\tthis.isPaused = false;\n\t},\n\n\tstop: function () {\n\n\t\tthis.isPlaying = false;\n\t\tthis.isPaused  = false;\n\n\t\t// reset JIT matrix and remove cache\n\n\t\tfor ( var h = 0; h < this.data.hierarchy.length; h ++ ) {\n\n\t\t\tvar obj = this.hierarchy[ h ];\n\t\t\tvar node = this.data.hierarchy[ h ];\n\n\t\t\tif ( node.animationCache !== undefined ) {\n\n\t\t\t\tvar original = node.animationCache.originalMatrix;\n\n\t\t\t\toriginal.copy( obj.matrix );\n\t\t\t\tobj.matrix = original;\n\n\t\t\t\tdelete node.animationCache;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdate: function ( delta ) {\n\n\t\tif ( this.isPlaying === false ) return;\n\n\t\tthis.currentTime += delta * this.timeScale;\n\n\t\t//\n\n\t\tvar duration = this.data.length;\n\n\t\tif ( this.loop === true && this.currentTime > duration ) {\n\n\t\t\tthis.currentTime %= duration;\n\n\t\t}\n\n\t\tthis.currentTime = Math.min( this.currentTime, duration );\n\n\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\n\n\t\t\tvar object = this.hierarchy[ h ];\n\t\t\tvar node = this.data.hierarchy[ h ];\n\n\t\t\tvar keys = node.keys,\n\t\t\t\tanimationCache = node.animationCache;\n\n\n\t\t\tif ( keys.length ) {\n\n\t\t\t\tvar prevKey = animationCache.prevKey;\n\t\t\t\tvar nextKey = animationCache.nextKey;\n\n\t\t\t\tif ( nextKey.time <= this.currentTime ) {\n\n\t\t\t\t\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\n\n\t\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimationCache.prevKey = prevKey;\n\t\t\t\t\tanimationCache.nextKey = nextKey;\n\n\t\t\t\t}\n\n\t\t\t\tif ( nextKey.time >= this.currentTime ) {\n\n\t\t\t\t\tprevKey.interpolate( nextKey, this.currentTime );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tprevKey.interpolate( nextKey, nextKey.time );\n\n\t\t\t\t}\n\n\t\t\t\tthis.data.hierarchy[ h ].node.updateMatrix();\n\t\t\t\tobject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tgetNextKeyWith: function ( sid, h, key ) {\n\n\t\tvar keys = this.data.hierarchy[ h ].keys;\n\t\tkey = key % keys.length;\n\n\t\tfor ( ; key < keys.length; key ++ ) {\n\n\t\t\tif ( keys[ key ].hasTarget( sid ) ) {\n\n\t\t\t\treturn keys[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn keys[ 0 ];\n\n\t},\n\n\tgetPrevKeyWith: function ( sid, h, key ) {\n\n\t\tvar keys = this.data.hierarchy[ h ].keys;\n\t\tkey = key >= 0 ? key : key + keys.length;\n\n\t\tfor ( ; key >= 0; key -- ) {\n\n\t\t\tif ( keys[ key ].hasTarget( sid ) ) {\n\n\t\t\t\treturn keys[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn keys[ keys.length - 1 ];\n\n\t}\n\n};\n"
			},
			{
				"name": "MW.js",
				"source": "// MW.js\n\n/*!\n* @author yomotsu http://yomotsu.net/\n* MIT License\n*/\n\nMW = {};\n\n\nMW.triangle = {};\n\n\nMW.triangle.makeBoundingBox = function ( triangle ) {\n\n  var bb = new THREE.Box3();\n\n  bb.min = bb.min.min( triangle.a );\n  bb.min = bb.min.min( triangle.b );\n  bb.min = bb.min.min( triangle.c );\n\n  bb.max = bb.max.max( triangle.a );\n  bb.max = bb.max.max( triangle.b );\n  bb.max = bb.max.max( triangle.c );\n\n  return bb;\n\n};\n\nMW.triangle.makeBoundingSphere = function ( triangle, normal ) {\n \n  var bs = new THREE.Sphere(),\n      v = new THREE.Vector3(),\n      v0 = new THREE.Vector3(),\n      v1 = new THREE.Vector3(),\n      e0 = new THREE.Vector3(),\n      e1 = new THREE.Vector3(),\n      a, b, c, d, e,\n      div, t, s;\n \n  // obtuse triangle\n \n  v0.subVectors( triangle.b, triangle.a );\n  v1.subVectors( triangle.c, triangle.a );\n \n  if ( v0.dot( v1 ) <= 0 ) {\n \n    bs.center.addVectors( triangle.b, triangle.c ).divideScalar( 2 );\n    bs.radius = v.subVectors( triangle.b, triangle.c ).length() / 2;\n    return bs;\n \n  }\n \n  v0.subVectors( triangle.a, triangle.b );\n  v1.subVectors( triangle.c, triangle.b );\n \n  if ( v0.dot( v1 ) <= 0 ) {\n \n    bs.center.addVectors( triangle.a, triangle.c ).divideScalar( 2 );\n    bs.radius = v.subVectors( triangle.a, triangle.c ).length() / 2;\n    return bs;\n \n  }\n \n  v0.subVectors( triangle.a, triangle.c );\n  v1.subVectors( triangle.b, triangle.c );\n \n  if ( v0.dot( v1 ) <= 0 ) {\n \n    bs.center.addVectors( triangle.a, triangle.b ).divideScalar( 2 );\n    bs.radius = v.subVectors( triangle.a, triangle.b ).length() / 2;\n    return bs;\n \n  }\n \n  // acute‐angled triangle\n \n  if ( !normal ) {\n \n    normal = triangle.normal();\n \n  }\n \n  v0.crossVectors( v.subVectors( triangle.c, triangle.b ), normal );\n  v1.crossVectors( v.subVectors( triangle.c, triangle.a ), normal );\n \n  e0.addVectors( triangle.c, triangle.b ).multiplyScalar( .5 );\n  e1.addVectors( triangle.c, triangle.a ).multiplyScalar( .5 );\n \n  a = v0.dot( v1 );\n  b = v0.dot( v0 );\n  d = v1.dot( v1 );\n  c = -v.subVectors( e1, e0 ).dot( v0 );\n  e = -v.subVectors( e1, e0 ).dot( v1 );\n \n  div = - a * a + b * d;\n  // t = ( - a * c + b * e ) / div;\n  s = ( - c * d + a * e ) / div;\n \n  bs.center = e0.clone().add( v0.clone().multiplyScalar( s ) );\n  bs.radius = v.subVectors( bs.center, triangle.a ).length();\n  return bs;\n \n}\n\n// @author yomotsu\n// MIT License\n\n;( function ( THREE, ns ) {\n\n  'use strict';\n\n  ns.collision = {};\n\n  // aabb: <THREE.Box3>\n  // Plane: <THREE.Plane>\n  ns.collision.isIntersectionAABBPlane = function ( aabb, Plane ) {\n\n    var center = new THREE.Vector3().addVectors( aabb.max, aabb.min ).multiplyScalar( 0.5 ),\n        extents = new THREE.Vector3().subVectors( aabb.max, center );\n\n    var r = extents.x * Math.abs( Plane.normal.x ) + extents.y * Math.abs( Plane.normal.y ) + extents.z * Math.abs( Plane.normal.z );\n    var s = Plane.normal.dot( center ) - Plane.constant;\n\n    return Math.abs( s ) <= r;\n\n  };\n\n  // based on http://www.gamedev.net/topic/534655-aabb-triangleplane-intersection--distance-to-plane-is-incorrect-i-have-solved-it/\n  //\n  // a: <THREE.Vector3>, // vertex of a triangle\n  // b: <THREE.Vector3>, // vertex of a triangle\n  // c: <THREE.Vector3>, // vertex of a triangle\n  // aabb: <THREE.Box3>\n  ns.collision.isIntersectionTriangleAABB = function ( a, b, c, aabb ) {\n\n    var p0, p1, p2, r;\n    \n    // Compute box center and extents of AABoundingBox (if not already given in that format)\n    var center = new THREE.Vector3().addVectors( aabb.max, aabb.min ).multiplyScalar( 0.5 ),\n        extents = new THREE.Vector3().subVectors( aabb.max, center );\n\n    // Translate triangle as conceptually moving AABB to origin\n    var v0 = new THREE.Vector3().subVectors( a, center ),\n        v1 = new THREE.Vector3().subVectors( b, center ),\n        v2 = new THREE.Vector3().subVectors( c, center );\n\n    // Compute edge vectors for triangle\n    var f0 = new THREE.Vector3().subVectors( v1, v0 ),\n        f1 = new THREE.Vector3().subVectors( v2, v1 ),\n        f2 = new THREE.Vector3().subVectors( v0, v2 );\n\n    // Test axes a00..a22 (category 3)\n    var a00 = new THREE.Vector3( 0, -f0.z, f0.y ),\n        a01 = new THREE.Vector3( 0, -f1.z, f1.y ),\n        a02 = new THREE.Vector3( 0, -f2.z, f2.y ),\n        a10 = new THREE.Vector3( f0.z, 0, -f0.x ),\n        a11 = new THREE.Vector3( f1.z, 0, -f1.x ),\n        a12 = new THREE.Vector3( f2.z, 0, -f2.x ),\n        a20 = new THREE.Vector3( -f0.y, f0.x, 0 ),\n        a21 = new THREE.Vector3( -f1.y, f1.x, 0 ),\n        a22 = new THREE.Vector3( -f2.y, f2.x, 0 );\n\n    // Test axis a00\n    p0 = v0.dot( a00 );\n    p1 = v1.dot( a00 );\n    p2 = v2.dot( a00 );\n    r = extents.y * Math.abs( f0.z ) + extents.z * Math.abs( f0.y );\n\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n      return false; // Axis is a separating axis\n\n    }\n\n    // Test axis a01\n    p0 = v0.dot( a01 );\n    p1 = v1.dot( a01 );\n    p2 = v2.dot( a01 );\n    r = extents.y * Math.abs( f1.z ) + extents.z * Math.abs( f1.y );\n\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n      return false; // Axis is a separating axis\n\n    }\n\n    // Test axis a02\n    p0 = v0.dot( a02 );\n    p1 = v1.dot( a02 );\n    p2 = v2.dot( a02 );\n    r = extents.y * Math.abs( f2.z ) + extents.z * Math.abs( f2.y );\n\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n      return false; // Axis is a separating axis\n\n    }\n\n    // Test axis a10\n    p0 = v0.dot( a10 );\n    p1 = v1.dot( a10 );\n    p2 = v2.dot( a10 );\n    r = extents.x * Math.abs( f0.z ) + extents.z * Math.abs( f0.x );\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n      return false; // Axis is a separating axis\n\n    }\n\n    // Test axis a11\n    p0 = v0.dot( a11 );\n    p1 = v1.dot( a11 );\n    p2 = v2.dot( a11 );\n    r = extents.x * Math.abs( f1.z ) + extents.z * Math.abs( f1.x );\n\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n      return false; // Axis is a separating axis\n\n    }\n\n    // Test axis a12\n    p0 = v0.dot( a12 );\n    p1 = v1.dot( a12 );\n    p2 = v2.dot( a12 );\n    r = extents.x * Math.abs( f2.z ) + extents.z * Math.abs( f2.x );\n\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n      return false; // Axis is a separating axis\n\n    }\n\n    // Test axis a20\n    p0 = v0.dot( a20 );\n    p1 = v1.dot( a20 );\n    p2 = v2.dot( a20 );\n    r = extents.x * Math.abs( f0.y ) + extents.y * Math.abs( f0.x );\n\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n      return false; // Axis is a separating axis\n\n    }\n\n    // Test axis a21\n    p0 = v0.dot( a21 );\n    p1 = v1.dot( a21 );\n    p2 = v2.dot( a21 );\n    r = extents.x * Math.abs( f1.y ) + extents.y * Math.abs( f1.x );\n\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n      return false; // Axis is a separating axis\n\n    }\n\n    // Test axis a22\n    p0 = v0.dot( a22 );\n    p1 = v1.dot( a22 );\n    p2 = v2.dot( a22 );\n    r = extents.x * Math.abs( f2.y ) + extents.y * Math.abs( f2.x );\n\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n      return false; // Axis is a separating axis\n\n    }\n\n    // Test the three axes corresponding to the face normals of AABB b (category 1).\n    // Exit if...\n    // ... [-extents.x, extents.x] and [min(v0.x,v1.x,v2.x), max(v0.x,v1.x,v2.x)] do not overlap\n    if ( Math.max( v0.x, v1.x, v2.x ) < -extents.x || Math.min( v0.x, v1.x, v2.x ) > extents.x ) {\n\n      return false;\n\n    }\n    // ... [-extents.y, extents.y] and [min(v0.y,v1.y,v2.y), max(v0.y,v1.y,v2.y)] do not overlap\n    if ( Math.max( v0.y, v1.y, v2.y ) < -extents.y || Math.min( v0.y, v1.y, v2.y ) > extents.y ) {\n\n      return false;\n\n    }\n    // ... [-extents.z, extents.z] and [min(v0.z,v1.z,v2.z), max(v0.z,v1.z,v2.z)] do not overlap\n    if ( Math.max( v0.z, v1.z, v2.z ) < -extents.z || Math.min( v0.z, v1.z, v2.z ) > extents.z ) {\n\n      return false;\n\n    }\n\n    // Test separating axis corresponding to triangle face normal (category 2)\n    // Face Normal is -ve as Triangle is clockwise winding (and XNA uses -z for into screen)\n    var plane = new THREE.Plane();\n    plane.normal = new THREE.Vector3().copy( f1 ).cross( f0 ).normalize();\n    plane.constant = plane.normal.dot( a );\n    \n    return ns.collision.isIntersectionAABBPlane( aabb, plane );\n\n  };\n\n\n  // sphere1: <THREE.Sphere>\n  // sphere2: <THREE.Sphere>\n  ns.collision.isIntersectionSphereSphere = function ( sphere1, sphere2 ) {\n\n    var radiusSum = sphere1.radius + sphere2.radius;\n\n    return sphere1.center.distanceToSquared( sphere2.center ) <= ( radiusSum * radiusSum );\n\n  };\n\n  // Section 5.1.3\n  // sphere: <THREE.Sphere>\n  // aabb: <THREE.Box3>\n\n  ns.collision.isIntersectionSphereAABB = function ( sphere, aabb ) {\n\n    var sqDist = 0;\n\n    if ( sphere.center.x < aabb.min.x ) { sqDist += ( aabb.min.x - sphere.center.x ) * ( aabb.min.x - sphere.center.x ); }\n    if ( sphere.center.x > aabb.max.x ) { sqDist += ( sphere.center.x - aabb.max.x ) * ( sphere.center.x - aabb.max.x ); }\n\n    if ( sphere.center.y < aabb.min.y ) { sqDist += ( aabb.min.y - sphere.center.y ) * ( aabb.min.y - sphere.center.y ); }\n    if ( sphere.center.y > aabb.max.y ) { sqDist += ( sphere.center.y - aabb.max.y ) * ( sphere.center.y - aabb.max.y ); }\n\n    if ( sphere.center.z < aabb.min.z ) { sqDist += ( aabb.min.z - sphere.center.z ) * ( aabb.min.z - sphere.center.z ); }\n    if ( sphere.center.z > aabb.max.z ) { sqDist += ( sphere.center.z - aabb.max.z ) * ( sphere.center.z - aabb.max.z ); }\n\n    return sqDist <= sphere.radius * sphere.radius;\n\n  };\n\n\n  //http://clb.demon.fi/MathGeoLib/docs/Triangle.cpp_code.html#459\n\n  // sphere: <THREE.Sphere>\n  // a: <THREE.Vector3>, // vertex of a triangle\n  // b: <THREE.Vector3>, // vertex of a triangle\n  // c: <THREE.Vector3>, // vertex of a triangle\n  // normal: <THREE.Vector3>, // normal of a triangle\n  ns.collision.isIntersectionSphereTriangle = function ( sphere, a, b, c, normal ) {\n    // http://realtimecollisiondetection.net/blog/?p=103\n\n    // vs plain of traiangle face\n    var A = new THREE.Vector3(),\n        B = new THREE.Vector3(),\n        C = new THREE.Vector3(),\n        rr,\n        V = new THREE.Vector3(),\n        d,\n        e;\n\n    A.subVectors( a, sphere.center );\n    B.subVectors( b, sphere.center );\n    C.subVectors( c, sphere.center );\n    rr = sphere.radius * sphere.radius;\n    V.crossVectors( B.clone().sub( A ), C.clone().sub( A ) );\n    d = A.dot( V );\n    e = V.dot( V );\n\n    if ( d * d > rr * e ) {\n\n      return false;\n\n    }\n\n    // vs triangle vertex\n    var aa,\n        ab,\n        ac,\n        bb,\n        bc,\n        cc;\n\n    aa = A.dot( A );\n    ab = A.dot( B );\n    ac = A.dot( C );\n    bb = B.dot( B );\n    bc = B.dot( C );\n    cc = C.dot( C );\n\n    if (\n      ( aa > rr ) & ( ab > aa ) & ( ac > aa ) ||\n      ( bb > rr ) & ( ab > bb ) & ( bc > bb ) ||\n      ( cc > rr ) & ( ac > cc ) & ( bc > cc )\n    ) {\n\n      return false;\n\n    }\n\n    // vs edge\n    var AB = new THREE.Vector3(),\n        BC = new THREE.Vector3(),\n        CA = new THREE.Vector3(),\n        d1,\n        d2,\n        d3,\n        e1,\n        e2,\n        e3,\n        Q1 = new THREE.Vector3(),\n        Q2 = new THREE.Vector3(),\n        Q3 = new THREE.Vector3(),\n        QC = new THREE.Vector3(),\n        QA = new THREE.Vector3(),\n        QB = new THREE.Vector3();\n\n    AB.subVectors( B, A );\n    BC.subVectors( C, B );\n    CA.subVectors( A, C );\n    d1 = ab - aa;\n    d2 = bc - bb;\n    d3 = ac - cc;\n    e1 = AB.dot( AB );\n    e2 = BC.dot( BC );\n    e3 = CA.dot( CA );\n    Q1.subVectors( A.multiplyScalar( e1 ), AB.multiplyScalar( d1 ) );\n    Q2.subVectors( B.multiplyScalar( e2 ), BC.multiplyScalar( d2 ) );\n    Q3.subVectors( C.multiplyScalar( e3 ), CA.multiplyScalar( d3 ) );\n    QC.subVectors( C.multiplyScalar( e1 ), Q1 );\n    QA.subVectors( A.multiplyScalar( e2 ), Q2 );\n    QB.subVectors( B.multiplyScalar( e3 ), Q3 );\n\n    if (\n      ( Q1.dot( Q1 ) > rr * e1 * e1 ) && ( Q1.dot( QC ) >= 0 ) ||\n      ( Q2.dot( Q2 ) > rr * e2 * e2 ) && ( Q2.dot( QA ) >= 0 ) ||\n      ( Q3.dot( Q3 ) > rr * e3 * e3 ) && ( Q3.dot( QB ) >= 0 )\n    ) {\n\n      return false;\n\n    }\n\n    var distance = Math.sqrt( d * d / e ) - sphere.radius - 1,\n        contactPoint = new THREE.Vector3(),\n        negatedNormal = new THREE.Vector3( -normal.x, -normal.y, -normal.z );\n\n    contactPoint.copy( sphere.center ).add( negatedNormal.multiplyScalar( distance ) );\n\n    return {\n      distance    : distance,\n      contactPoint: contactPoint\n    };\n\n  };\n\n  // based on Real-Time Collision Detection Section 5.3.4\n  // p: <THREE.Vector3>, // line3.start\n  // q: <THREE.Vector3>, // line3.end\n  // a: <THREE.Vector3>, // triangle.a\n  // b: <THREE.Vector3>, // triangle.b\n  // c: <THREE.Vector3>, // triangle.c\n  // normal: <THREE.Vector3>, // triangle.normal, optional\n\n  // var scalarTriple = function ( a, b, c ) {\n\n  //   var m = b.clone().cross( c );\n  //   return a.dot( m );\n\n  // }\n\n  // var vectorTriple = function ( a, b, c ) {\n\n  //   var m = b.clone().cross( c );\n  //   return a.clone().cross( m );\n\n  // }\n\n  // ns.collision.isIntersectionLineTriangle = function ( p, q, a, b, c, precision ) {\n\n  //   var pq = q.clone().sub( p ),\n  //       pa = a.clone().sub( p ),\n  //       pb = b.clone().sub( p ),\n  //       pc = c.clone().sub( p ),\n  //       u, v, w;\n\n  //   u = scalarTriple( pq, pc, pb );\n\n  //   if ( u < 0 ) { return false; }\n\n  //   v = scalarTriple( pq, pa, pc );\n\n  //   if ( v < 0 ) { return false; }\n\n  //   w = scalarTriple( pq, pb, pa );\n\n  //   if ( w < 0 ) { return false; }\n\n  //   var denom = 1 / ( u + v + w );\n  //   u *= denom;\n  //   v *= denom;\n  //   w *= denom;\n\n  //   var au = a.clone().multiplyScalar( u ),\n  //       bv = b.clone().multiplyScalar( v ),\n  //       cw = c.clone().multiplyScalar( w ),\n  //       contactPoint = au.clone().add( bv ).add( cw );\n\n  //   return {\n  //     contactPoint: contactPoint\n  //   }\n\n  // }\n\n  ns.collision.testSegmentTriangle = function ( p, q, a, b, c ) {\n\n    var ab = b.clone().sub( a );\n    var ac = c.clone().sub( a );\n    var qp = p.clone().sub( q );\n\n    var n = ab.clone().cross( ac );\n\n    var d = qp.dot( n );\n    if ( d <= 0 ) { return false; }\n\n    var ap = p.clone().sub( a );\n    var t = ap.dot( n );\n\n    if ( t < 0 ) { return 0; }\n    if ( t > d ) { return 0; }\n\n    var e = qp.clone().cross( ap );\n    var v = ac.dot( e );\n\n    if ( v < 0 || v > d ) { return 0; }\n\n    var w = ab.clone().dot( e ) * -1;\n\n    if ( w < 0 || v + w > d ) { return 0; }\n\n    var ood = 1 / d;\n    t *= ood;\n    v *= ood;\n    w *= ood;\n    var u = 1 - v - w;\n\n    var au = a.clone().multiplyScalar( u ),\n        bv = b.clone().multiplyScalar( v ),\n        cw = c.clone().multiplyScalar( w ),\n        contactPoint = au.clone().add( bv ).add( cw );\n\n    return {\n      contactPoint: contactPoint\n    }\n\n}\n\n} )( THREE, MW );\n\n\n// @author yomotsu\n// MIT License\n\n;( function ( THREE, ns ) {\n\n  'use strict';\n\n  ns.World = function () {\n\n    // console.log( 'THREEFIELD.World' );\n\n    this.colliderPool  = [];\n    this.characterPool = [];\n\n  };\n\n  ns.World.prototype.add = function ( object ) {\n    \n    if ( object instanceof ns.Octree ) {\n\n      this.colliderPool.push( object );\n\n    } else if ( object instanceof ns.CharacterController ) {\n\n      this.characterPool.push( object );\n      object.world = this;\n\n    }\n\n  };\n\n  ns.World.prototype.step = function ( dt ) {\n\n    var character,\n        octree,\n        sphere,\n        intersectedNodes,\n        faces,\n        contactInfo,\n        i, ii, iii, l, ll, lll;\n\n    for ( i = 0, l = this.characterPool.length; i < l; i ++ ) {\n\n      character = this.characterPool[ i ];\n\n      // octree で絞られた node に含まれる face だけを\n      // charactore に渡して判定する\n      for ( ii = 0, ll = this.colliderPool.length; ii < ll; ii ++ ) {\n\n        octree = this.colliderPool[ ii ];\n        sphere = new THREE.Sphere( character.center, character.radius + character.groundPadding );\n        intersectedNodes = octree.getIntersectedNodes( sphere, octree.maxDepth );\n        faces = ns.Octree.uniqTriangkesfromNodes( intersectedNodes );\n\n      }\n      \n      character.collisionCandidate = faces;\n      character.update( dt );\n\n    }\n\n  };\n\n} )( THREE, MW );\n\n// @author yomotsu\n// MIT License\n\n// OcTree with Morton Order\n// based on http://marupeke296.com/COL_3D_No15_Octree.html\n//\n//       +------+------+\n//       |\\   2  \\   3  \\\n//       | +------+------+\n//       + |\\      \\      \\\n//       |\\| +------+------+\n//       | + |      |      |\n//       +0|\\|   6  |   7  |\n//        \\| +------+------+\n//         + |      |      |\n//    y     \\|   4  |   5  |\n//    |      +------+------+\n//    +--x\n//     \\\n//      z\n//\n//\n//       +------+------+\n//       |\\   6  \\   7  \\\n//       | +------+------+\n//       + |\\      \\      \\\n//       |\\| +------+------+\n//       | + |      |      |\n//       +4|\\|   2  |   3  |\n//        \\| +------+------+\n//         + |      |      |\n//  z y     \\|   0  |   1  |\n//   \\|      +------+------+\n//    +--x\n//\n\n;( function ( THREE, ns ) {\n\n  'use strict';\n\n  // min: <THREE.Vector3>\n  // max: <THREE.Vector3>\n  // maxDepth: <Number>\n  ns.Octree = function ( min, max, maxDepth ) {\n\n    this.min = min;\n    this.max = max;\n    this.maxDepth = maxDepth;\n    this.nodes = [];\n\n    var i, length, depth, mortonNumber,\n        pow2, pow4,\n        indexX, indexY, indexZ,\n        nodeBoxSize = new THREE.Vector3(),\n        nodeBoxMin = new THREE.Vector3(),\n        nodeBoxMax = new THREE.Vector3();\n\n    for ( depth = 0; depth < this.maxDepth; depth ++ ) {\n\n      this.nodes.push( [] );\n      pow2 = Math.pow( 2, depth );\n      pow4 = Math.pow( 4, depth );\n      nodeBoxSize.subVectors( this.max, this.min ).divideScalar( pow2 );\n\n      for ( i = 0, length = Math.pow( 8, depth ); i < length; i ++ ) {\n\n        indexX = i % pow2;\n        indexY = ( i / pow4 )|0;\n        indexZ = ( ( i / pow2 )|0 ) % pow2;\n\n        nodeBoxMin.set(\n          this.min.x + indexX * nodeBoxSize.x,\n          this.min.y + indexY * nodeBoxSize.y,\n          this.min.z + indexZ * nodeBoxSize.z\n        );\n        nodeBoxMax.copy( nodeBoxMin ).add( nodeBoxSize );\n\n        mortonNumber = ns.Octree.getMortonNumber( indexX, indexY, indexZ );\n        this.nodes[ depth ][ mortonNumber ] = new ns.OctreeNode( this, depth, mortonNumber, nodeBoxMin, nodeBoxMax );\n\n      }\n\n    }\n\n  };\n\n  ns.Octree.prototype = {\n\n    constructor: ns.Octree,\n\n    importThreeMesh: function ( threeMesh ) {\n\n\n      var i, ii, l, ll,\n          vec3 = new THREE.Vector3(),\n          geometry,\n          geometryId,\n          face,\n          normal,\n          index,\n          count,\n          start,\n          a, b, c,\n        \tvA  = new THREE.Vector3(),\n        \tvB  = new THREE.Vector3(),\n        \tvC  = new THREE.Vector3(),\n        \tvnA = new THREE.Vector3(),\n        \tvnB = new THREE.Vector3(),\n        \tvnC = new THREE.Vector3(),\n          ab  = new THREE.Vector3(),\n          cb  = new THREE.Vector3(),\n          faceNormal;\n\n      threeMesh.updateMatrix();\n\n      geometryId = threeMesh.geometry.uuid;\n      geometry   = threeMesh.geometry.clone();\n      geometry.applyMatrix( threeMesh.matrix );\n      geometry.computeVertexNormals();\n\n      if ( geometry instanceof THREE.BufferGeometry ) {\n\n        if ( geometry.index !== undefined ) {\n\n          var indices   = geometry.index.array;\n          var positions = geometry.attributes.position.array;\n          var normals   = geometry.attributes.normal.array;\n          var offsets   = geometry.groups;\n\n          if ( offsets.length === 0 ) {\n\n            offsets = [ { start: 0, count: indices.length, index: 0 } ];\n\n          }\n\n          for ( i = 0, l = offsets.length; i < l; ++ i ) {\n\n            start  = offsets[ i ].start;\n            count  = offsets[ i ].count;\n            index  = offsets[ i ].materialIndex;\n\n            for ( ii = start, ll = start + count; ii < ll; ii += 3 ) {\n\n              a = index + indices[ ii ];\n              b = index + indices[ ii + 1 ];\n              c = index + indices[ ii + 2 ];\n\n              vA = vec3.fromArray( positions, a * 3 ).clone();\n              vB = vec3.fromArray( positions, b * 3 ).clone();\n              vC = vec3.fromArray( positions, c * 3 ).clone();\n\n              // https://github.com/mrdoob/three.js/issues/4691\n              // make face normal\n              cb.subVectors( vC, vB );\n              ab.subVectors( vA, vB );\n              faceNormal = cb.cross( ab ).normalize().clone();\n\n              face = new ns.Face(\n                vA,\n                vB,\n                vC,\n                faceNormal,\n                geometryId\n              );\n\n              this.addFace( face );\n\n            }\n\n          }\n\n        }\n\n        return;\n\n      }\n\n      geometry.computeFaceNormals();\n\n      for ( i = 0, l = geometry.faces.length; i < l; i ++ ) {\n\n        face = new ns.Face(\n          geometry.vertices[ geometry.faces[ i ].a ],\n          geometry.vertices[ geometry.faces[ i ].b ],\n          geometry.vertices[ geometry.faces[ i ].c ],\n          geometry.faces[ i ].normal,\n          geometryId\n        );\n        this.addFace( face );\n\n      }\n\n    },\n\n    addFace: function ( face ) {\n\n      var i, ii, l, ll, node, targetNodes = [], tmp = [], isIntersected;\n\n      targetNodes = this.nodes[ 0 ].slice( 0 );\n\n      for ( i = 0, l = this.maxDepth; i < l; i ++ ) {\n\n        for ( ii = 0, ll = targetNodes.length; ii < ll; ii ++ ) {\n\n          node = targetNodes[ ii ];\n          isIntersected = ns.collision.isIntersectionTriangleAABB( face.a, face.b, face.c, node );\n\n          if ( isIntersected ) {\n\n            node.trianglePool.push( face );\n\n            if ( i + 1 !== this.maxDepth ) {\n\n              tmp = tmp.concat( node.getChildNodes() );\n\n            }\n\n          }\n\n        }\n\n        if ( tmp.length === 0 ) {\n\n          break;\n\n        }\n\n        targetNodes = tmp.slice( 0 );\n        tmp.length = 0;\n\n      }\n\n    },\n\n    removeThreeMesh: function ( meshID ) {\n\n      var that = this;\n\n      this.nodes.forEach( function ( nodeDepth ) {\n\n        nodeDepth.forEach( function ( node ) {\n\n          var newTrianglePool = [];\n\n          node.trianglePool.forEach( function ( face ) {\n\n            if ( face.meshID !== meshID ) {\n\n              newTrianglePool.push( face );\n\n            }\n\n          } );\n\n          node.trianglePool = newTrianglePool;\n\n        } );\n\n      } );\n\n    },\n\n    getIntersectedNodes: function ( sphere, depth ) {\n\n      var i, ii, l, ll, node, targetNodes = [], tmp = [],\n          isIntersected, intersectedNodes = [], isAtMaxDepth;\n\n      isIntersected = ns.collision.isIntersectionSphereAABB( sphere, this );\n\n      if ( !isIntersected ) {\n\n        return [];\n\n      }\n\n      targetNodes = this.nodes[ 0 ].slice( 0 );\n\n      for ( i = 0, l = depth; i < l; i ++ ) {\n\n        for ( ii = 0, ll = targetNodes.length; ii < ll; ii ++ ) {\n\n          node = targetNodes[ ii ];\n          isIntersected = ns.collision.isIntersectionSphereAABB( sphere, node );\n\n          if ( isIntersected ) {\n\n            isAtMaxDepth = ( i + 1 === depth );\n\n            if ( isAtMaxDepth ) {\n\n              if ( node.trianglePool.length !== 0 ) {\n\n                intersectedNodes.push( node );\n\n              }\n\n            } else {\n\n              tmp = tmp.concat( node.getChildNodes() );\n\n            }\n\n          }\n\n        }\n\n        targetNodes = tmp.slice( 0 );\n        tmp.length = 0;\n\n      }\n\n      return intersectedNodes;\n\n    }\n\n  };\n\n  ns.Octree.separate3Bit = function ( n ) {\n\n    n = ( n | n << 8 ) & 0x0000f00f;\n    n = ( n | n << 4 ) & 0x000c30c3;\n    n = ( n | n << 2 ) & 0x00249249;\n    return n;\n\n  };\n\n  ns.Octree.getMortonNumber = function ( x, y, z ) {\n\n    return ns.Octree.separate3Bit( x ) |\n           ns.Octree.separate3Bit( y ) << 1 |\n           ns.Octree.separate3Bit( z ) << 2;\n\n  };\n\n  ns.Octree.uniqTriangkesfromNodes = function ( nodes ) {\n\n    var i, ii, iii, l, ll, lll, uniq = [], isContained = false;\n\n    if ( nodes.length === 0 ) {\n\n      return [];\n\n    } else if ( nodes.length === 1 ) {\n\n      return nodes[ 0 ].trianglePool.slice( 0 );\n\n    }\n\n    for ( i = 0, l = nodes.length; i < l; i ++ ) {\n\n      for ( ii = 0, ll = nodes[ i ].trianglePool.length; ii < ll; ii ++ ) {\n\n        for ( iii = 0, lll = uniq.length; iii < lll; iii ++ ) {\n\n          if ( nodes[ i ].trianglePool[ ii ] === uniq[ iii ] ) {\n\n            isContained = true;\n\n          }\n\n        }\n\n        if ( !isContained ) {\n\n          uniq.push( nodes[ i ].trianglePool[ ii ] );\n\n        }\n\n        isContained = false;\n\n      }\n\n    }\n\n    return uniq;\n\n  };\n\n  //\n\n  ns.OctreeNode = function ( tree, depth, mortonNumber, min, max ) {\n\n    this.tree = tree;\n    this.depth = depth;\n    this.mortonNumber = mortonNumber;\n    this.min = new THREE.Vector3( min.x, min.y, min.z );\n    this.max = new THREE.Vector3( max.x, max.y, max.z );\n    this.trianglePool = [];\n\n  };\n\n  ns.OctreeNode.prototype = {\n\n    constructor: ns.OctreeNode,\n\n    getParentNode: function () {\n\n      if ( this.depth === 0 ) {\n\n        return null;\n\n      }\n\n      this.tree.nodes[ this.depth ][ this.mortonNumber >> 3 ];\n\n    },\n\n    getChildNodes: function () {\n\n      if ( this.tree.maxDepth === this.depth ) {\n\n        return null;\n\n      }\n\n      var firstChild = this.mortonNumber << 3;\n\n      return [\n        this.tree.nodes[ this.depth + 1 ][ firstChild ],\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 1 ],\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 2 ],\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 3 ],\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 4 ],\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 5 ],\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 6 ],\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 7 ]\n      ];\n\n    }\n\n  };\n\n  //\n\n  // a: <THREE.Vector3>\n  // b: <THREE.Vector3>\n  // c: <THREE.Vector3>\n  // normal: <THREE.Vector3>\n  // meshID: <String>\n  ns.Face = function ( a, b, c, normal, meshID ) {\n\n    this.a = a.clone();\n    this.b = b.clone();\n    this.c = c.clone();\n    this.normal = normal.clone();\n    this.meshID = meshID;\n\n  };\n\n  ns.Face.prototype = {\n\n    constructor: ns.Face\n\n  };\n\n  // origin   : <THREE.Vector3>\n  // direction: <THREE.Vector3>\n  // distance : <Float>\n  ns.Ray = function ( origin, direction, distance ) {\n    this.origin = origin;\n    this.direction = direction;\n    this.distance = distance;\n  };\n\n} )( THREE, MW );\n\n\n"
			},
			{
				"name": "MWtps.js",
				"source": "// MWtps.js\n\n/*!\n* @author yomotsu http://yomotsu.net/\n* MIT License\n*/\n\n;( function ( THREE, ns ) {\n\n  'use strict';\n\n  ns.CharacterController = function ( object3d, radius ) {\n\n    Object.assign( this, THREE.EventDispatcher.prototype );  //  THREE.EventDispatcher.prototype.apply( this );\n    this.object = object3d;\n    this.center = this.object.position.clone();\n    this.radius = radius;\n    this.groundPadding = 0.5;\n    this.maxSlopeGradient = Math.cos( THREE.Math.degToRad( 50 ) );\n    this.isGrounded = false;\n    this.isOnSlope  = false;\n    this.isIdling   = false;\n    this.isRunning  = false;\n    this.isJumping  = false;\n    this.direction  = 0; // 0 to 2PI(=360deg) in rad\n    this.movementSpeed = 28; // default: 50; // Meters Per Second\n    this.velocity = new THREE.Vector3( 0, -10, 0 );\n    this.currentJumpPower = 0;\n    this.jumpStartTime = 0;\n    this.groundHeight = 0;\n    this.groundNormal = new THREE.Vector3();\n    this.collisionCandidate;\n    this.contactInfo = [];\n\n  };\n\n  ns.CharacterController.prototype = {\n\n    constructor: ns.CharacterController,\n\n    update: function ( dt ) {\n\n      this.isGrounded = false;\n      this.isOnSlope  = false;\n      this.groundHeight = -Infinity;\n      this.groundNormal.set( 0, 1, 0 );\n\n      this.updateGrounding();\n      this.updateJumping();\n      this.updatePosition( dt );\n      this.collisionDetection();\n      this.solvePosition();\n      this.updateVelocity();\n      this.events();\n\n    },\n\n    updateVelocity: function () {\n\n      var FALL_VELOCITY = -50,\n          frontDierction = -Math.cos( this.direction ),\n          rightDierction = -Math.sin( this.direction ),\n          normal,\n          isHittingCeiling = false,\n          wallNomal2D,\n          direction2D,\n          wallAngle,\n          frontAngle,\n          negativeFrontAngle,\n          i, l;\n      \n      this.velocity.set(\n        rightDierction * this.movementSpeed * this.isRunning, \n        FALL_VELOCITY,\n        frontDierction * this.movementSpeed * this.isRunning\n      );\n\n      if ( this.contactInfo.length === 0 && !this.isJumping ) {\n\n        return;\n\n      } else if ( this.isGrounded && !this.isOnSlope && !this.isJumping ) {\n\n        this.velocity.y = 0;\n\n      } else if ( this.isOnSlope ) {\n\n        var slidingDownVelocity = FALL_VELOCITY;\n        var holizontalSpead = - slidingDownVelocity / ( 1 - this.groundNormal.y ) * 0.2;\n\n        this.velocity.x = this.groundNormal.x * holizontalSpead;\n        this.velocity.y = FALL_VELOCITY;\n        this.velocity.z = this.groundNormal.z * holizontalSpead;\n\n      } else if ( !this.isGrounded && !this.isOnSlope && this.isJumping ) {\n\n        this.velocity.y = this.currentJumpPower * -FALL_VELOCITY;\n\n      }\n\n\n      // vs walls and sliding on the wall\n      direction2D = new THREE.Vector2( rightDierction, frontDierction );\n      frontAngle = Math.atan2( direction2D.y, direction2D.x );\n      negativeFrontAngle = Math.atan2( -direction2D.y, -direction2D.x );\n      \n      for ( i = 0, l = this.contactInfo.length; i < l; i ++ ) {\n\n        normal = this.contactInfo[ i ].face.normal;\n        // var distance = this.contactInfo[ i ].distance;\n\n        if ( this.maxSlopeGradient < normal.y || this.isOnSlope ) {\n\n          continue;\n\n        }\n\n        if ( !isHittingCeiling && normal.y < 0 ) {\n\n          isHittingCeiling = true;\n\n        }\n\n        wallNomal2D = new THREE.Vector2( normal.x, normal.z ).normalize();\n        wallAngle = Math.atan2( wallNomal2D.y, wallNomal2D.x );\n\n        if (\n          Math.abs( negativeFrontAngle - wallAngle ) >= Math.PI * 0.5 && //  90deg\n          Math.abs( negativeFrontAngle - wallAngle ) <= Math.PI * 1.5    // 270deg\n        ) {\n\n          continue;\n\n        }\n\n        wallNomal2D.set(\n          direction2D.dot( wallNomal2D ) * wallNomal2D.x,\n          direction2D.dot( wallNomal2D ) * wallNomal2D.y\n        );\n        direction2D.subVectors( direction2D, wallNomal2D );\n\n        this.velocity.x = direction2D.x * this.movementSpeed * this.isRunning;\n        this.velocity.z = direction2D.y * this.movementSpeed * this.isRunning;\n\n      }\n\n      if ( isHittingCeiling ) {\n\n        this.velocity.y = Math.min( 0, this.velocity.y );\n        this.isJumping = false;\n\n      }\n\n    },\n\n    updateGrounding: function () {\n\n      // \"頭上からほぼ無限に下方向までの線 (segment)\" vs \"フェイス (triangle)\" の\n      // 交差判定を行う\n      // もし、フェイスとの交差点が「頭上」から「下groundPadding」までの間だったら\n      // 地面上 (isGrounded) にいることとみなす\n      //\n      //   ___\n      //  / | \\\n      // |  |  | player sphere\n      //  \\_|_/\n      //    |\n      //---[+]---- ground\n      //    |\n      //    |\n      //    | segment (player's head to almost -infinity)\n\n\n      var i, l,\n          groundContactInfo,\n          groundContactInfoTmp,\n          faces = this.collisionCandidate,\n          distanceToGround;\n\n      var head = new THREE.Vector3(\n        this.center.x,\n        this.center.y + this.radius,\n        this.center.z\n      );\n\n      var to = new THREE.Vector3(\n        this.center.x,\n        this.center.y - 1e10,\n        this.center.z\n      );\n\n      for ( i = 0, l = faces.length; i < l; i ++ ) {\n\n        groundContactInfoTmp = ns.collision.testSegmentTriangle( head, to, faces[ i ].a, faces[ i ].b, faces[ i ].c );\n\n        if ( groundContactInfoTmp && !groundContactInfo ) {\n\n          groundContactInfo = groundContactInfoTmp;\n          groundContactInfo.face = faces[ i ];\n\n        } else if (\n          groundContactInfoTmp &&\n          groundContactInfoTmp.contactPoint.y > groundContactInfo.contactPoint.y\n        ) {\n          \n          groundContactInfo = groundContactInfoTmp;\n          groundContactInfo.face = faces[ i ];\n\n        }\n\n      }\n\n      if ( !groundContactInfo ) {\n\n        return;\n\n      }\n\n      this.groundHeight = groundContactInfo.contactPoint.y;\n      this.groundNormal.copy( groundContactInfo.face.normal );\n\n      var top    = head.y;\n      var bottom = this.center.y - this.radius - this.groundPadding;\n\n      if ( this.isJumping && 0 < this.currentJumpPower ) {\n\n        this.isOnSlope  = false;\n        this.isGrounded = false;\n        return;\n\n      }\n\n      this.isGrounded = ( bottom <= this.groundHeight && this.groundHeight <= top );\n      this.isOnSlope  = ( this.groundNormal.y <= this.maxSlopeGradient );\n\n      if ( this.isGrounded ) {\n\n        this.isJumping = false;\n\n      }\n\n    },\n\n    updatePosition: function ( dt ) {\n\n      var x = this.center.x + this.velocity.x * dt,\n          y = this.center.y + this.velocity.y * dt,\n          z = this.center.z + this.velocity.z * dt;\n\n      if ( this.isGrounded ) {\n\n        y = this.groundHeight + this.radius;\n\n      }\n\n      this.center.set( x, y, z );\n\n    },\n\n    collisionDetection: function () {\n\n      var i, l,\n          faces = this.collisionCandidate,\n          contactInfo;\n\n      this.contactInfo.length = 0;\n\n      for ( i = 0, l = faces.length; i < l; i ++ ) {\n\n        contactInfo = ns.collision.isIntersectionSphereTriangle( this, faces[ i ].a, faces[ i ].b, faces[ i ].c, faces[ i ].normal );\n\n        if ( !contactInfo ) {\n\n          continue;\n\n        }\n\n        contactInfo.face = faces[ i ];\n        this.contactInfo.push( contactInfo );\n\n      }\n\n    },\n\n    solvePosition: function () {\n\n      var face,\n          normal,\n          distance,\n          point1 = new THREE.Vector3(),\n          point2 = new THREE.Vector3(),\n          direction = new THREE.Vector3(),\n          plainD,\n          t,\n          translateScoped = new THREE.Vector3(),\n          translate = new THREE.Vector3(),\n          i, l;\n\n      if ( this.contactInfo.length === 0 ) {\n\n        this.object.position.copy( this.center );\n        return;\n\n      }\n\n      // \n      // vs walls and sliding on the wall\n\n      for ( i = 0, l = this.contactInfo.length; i < l; i ++ ) {\n\n        face = this.contactInfo[ i ].face;\n        normal = this.contactInfo[ i ].face.normal;\n        distance = this.contactInfo[ i ].distance;\n\n        // if ( 0 <= distance ) {\n\n        //   continue;\n\n        // }\n\n        if ( this.maxSlopeGradient < normal.y ) {\n\n          // this triangle is a ground or slope, not a wall or ceil.\n          continue;\n\n        }\n\n        var isSlopeFace = ( this.maxSlopeGradient <= face.normal.y && face.normal.y < 1 );\n\n        if ( this.isJumping && 0 >= this.currentJumpPower && isSlopeFace ) {\n\n          this.isJumping = false;\n          this.isGrounded = true;\n          // console.log( 'jump end' );\n\n        }\n\n        if ( this.isGrounded || this.isOnSlope ) {\n\n          // http://gamedev.stackexchange.com/questions/80293/how-do-i-resolve-a-sphere-triangle-collision-in-a-given-direction\n          point1.copy( normal ).multiplyScalar( -this.radius ).add( this.center );\n          direction.set( normal.x, 0, normal.z ).normalize();\n          plainD = face.a.dot( normal );\n          t = ( plainD - ( normal.x * point1.x + normal.y * point1.y + normal.z * point1.z ) ) / ( normal.x * direction.x + normal.y * direction.y + normal.z * direction.z );\n          point2.copy( direction ).multiplyScalar( t ).add( point1 );\n          translateScoped.subVectors( point2, point1 );\n\n          if ( Math.abs( translate.x ) > Math.abs( translateScoped.x ) ) {\n\n            translate.x += translateScoped.x;\n\n          }\n\n          if ( Math.abs( translate.z ) > Math.abs( translateScoped.z ) ) {\n\n            translate.z += translateScoped.z;\n\n          }\n\n          // break;\n          continue;\n\n        }\n\n      }\n\n      this.center.add( translate );\n      this.object.position.copy( this.center );\n\n    },\n\n    events: function () {\n\n      var isFirstUpdate = true,\n          wasGrounded,\n          wasOnSlope,\n          wasIdling,\n          wasRunning,\n          wasJumping;\n\n      return function () {\n\n        if ( isFirstUpdate ) {\n\n            isFirstUpdate = false;\n            wasGrounded = this.isGrounded;\n            wasOnSlope  = this.isOnSlope;\n            wasIdling   = this.isIdling;\n            wasRunning  = this.isRunning;\n            wasJumping  = this.isJumping;\n            return;\n\n        }\n\n        if ( !wasRunning && !this.isRunning && this.isGrounded && !this.isIdling ) {\n\n            this.isIdling = true;\n            this.dispatchEvent( { type: 'startIdling' } );\n\n        } else if (\n          ( !wasRunning && this.isRunning && !this.isJumping && this.isGrounded ) ||\n          ( !wasGrounded && this.isGrounded && this.isRunning ) ||\n          ( wasOnSlope && !this.isOnSlope && this.isRunning && this.isGrounded )\n        ) {\n\n            this.isIdling = false;\n            this.dispatchEvent( { type: 'startRunning' } );\n          \n        } else if ( !wasJumping && this.isJumping ) {\n\n            this.isIdling = false;\n            this.dispatchEvent( { type: 'startJumping' } );\n          \n        } else if ( !wasOnSlope && this.isOnSlope ) {\n\n            this.dispatchEvent( { type: 'startSliding' } );\n          \n        } else if ( wasGrounded && !this.isGrounded && !this.isJumping ) {\n\n            this.dispatchEvent( { type: 'startFalling' } );\n          \n        }\n\n        if ( !wasGrounded && this.isGrounded ) {\n\n            this.dispatchEvent( { type: 'endJumping' } );\n          \n        }\n\n        wasGrounded = this.isGrounded;\n        wasOnSlope  = this.isOnSlope;\n        wasIdling   = this.isIdling;\n        wasRunning  = this.isRunning;\n        wasJumping  = this.isJumping;\n\n      };\n\n    }(),\n\n    setDirection : function () {\n\n\n\n    },\n\n    jump: function () {\n      \n      if ( this.isJumping || !this.isGrounded || this.isOnSlope ) {\n\n        return;\n\n      }\n\n      // since ios dose not support porformance.now()\n      // this.jumpStartTime = performance.now();\n      this.jumpStartTime = Date.now();\n      this.currentJumpPower = 0.01;\n      this.isJumping = true;\n\n    },\n\n    updateJumping: function () {\n\n      var JUMP_DURATION = 1500;\n\n      if ( !this.isJumping ) {\n\n        return;\n\n      }\n\n      // since ios dose not support porformance.now()\n      // var elapsed = performance.now() - this.jumpStartTime;\n      var elapsed = Date.now() - this.jumpStartTime;\n      var progress = elapsed / JUMP_DURATION;\n      this.currentJumpPower = Math.cos( Math.min( progress, 1 ) * Math.PI );\n\n    }\n\n  }\n\n} )( THREE, MW );\n\n// @author yomotsu\n// MIT License\n\nMW.AnimationController = function ( mesh ) {\n\n  this.mesh   = mesh;\n  this.motion = {};\n  this.mixer  = new THREE.AnimationMixer( mesh );\n  this.currentMotionName = \"\";\n\n  var i, l, anim;\n\n  for ( i = 0, l = this.mesh.geometry.animations.length; i < l; i ++ ) {\n\n    anim = this.mesh.geometry.animations[ i ];\n    this.motion[ anim.name ] = this.mixer.clipAction( anim );\n    this.motion[ anim.name ].setEffectiveWeight( 1 );\n\n  }\n  \n};\n\nMW.AnimationController.prototype = {\n\n  play: function ( name ) {\n\n    if ( this.currentMotionName === name ) { return; }\n\n    if ( this.motion[ this.currentMotionName ] ) {\n\n      var from = this.motion[ this.currentMotionName ].play();\n      var to   = this.motion[ name ].play();\n\n      from.enabled = true;\n      to.enabled = true;\n\n      from.crossFadeTo( to, .3 );\n\n    } else {\n\n      this.motion[ name ].enabled = true;\n      this.motion[ name ].play();\n\n    }\n\n    this.currentMotionName = name;\n\n  },\n\n  turn: function () {\n\n    var DURATION  = 200;\n    var TAU = 2 * Math.PI;\n\n    var mod = function ( a, n ) { return ( a % n + n ) % n; };\n\n    var getDeltaAngle = function ( current, target ) {\n\n      var a = mod( ( current - target ), TAU );\n      var b = mod( ( target - current ), TAU );\n\n      return a < b ? -a : b;\n\n    };\n\n    return function ( rad, immediate ) {\n\n\n      var that       = this;\n      var progress   = 0;\n      var prevRotY   = this.mesh.rotation.y;\n      var targetRotY = rad;\n      var deltaY     = getDeltaAngle( prevRotY, targetRotY );\n      // var duration   = Math.abs( deltaY ) * 100;\n      var start      = Date.now();\n      var end        = start + DURATION;\n\n      if ( immediate ) {\n\n        this.mesh.rotation.y = targetRotY;\n        return;\n\n      }\n\n      if ( this._targetRotY === targetRotY ) { return; }\n\n      this._targetRotY = targetRotY;\n\n      ( function () {\n\n        var _targetRotY = targetRotY;\n\n        ( function interval () {\n\n          var now = Date.now();\n          var isAborted = _targetRotY !== that._targetRotY;\n\n          if ( isAborted ) { return; }\n\n          if ( now >= end ) {\n\n            that.mesh.rotation.y = _targetRotY;\n            delete that._targetRotY;\n            return;\n\n          }\n\n          requestAnimationFrame( interval );\n          progress = ( now - start ) / DURATION;\n          that.mesh.rotation.y = prevRotY + deltaY * progress;\n\n        } )();\n\n      } )();\n\n    }\n\n  }(),\n\n  update: function ( delta ) {\n\n    this.mixer.update( delta );\n\n  }\n\n};\n\n// @author yomotsu\n// MIT License\n\n;( function ( THREE, ns ) {\n\n  'use strict';\n\n  var KEY_W     = 87,\n      KEY_UP    = 38,\n      KEY_S     = 83,\n      KEY_DOWN  = 40,\n      KEY_A     = 65,\n      KEY_LEFT  = 37,\n      KEY_D     = 68,\n      KEY_RIGHT = 39,\n      KEY_SPACE = 32,\n      KEY_R     = 82; // hack //\n\n  var DEG_0   = THREE.Math.degToRad(   0 ),\n      DEG_45  = THREE.Math.degToRad(  45 ),\n      DEG_90  = THREE.Math.degToRad(  90 ),\n      DEG_135 = THREE.Math.degToRad( 135 ),\n      DEG_180 = THREE.Math.degToRad( 180 ),\n      DEG_225 = THREE.Math.degToRad( 225 ),\n      DEG_270 = THREE.Math.degToRad( 270 ),\n      DEG_315 = THREE.Math.degToRad( 315 ),\n      DEG_360 = THREE.Math.degToRad( 360 );\n\n  ns.KeyInputControl = function () {\n    \n    Object.assign( this, THREE.EventDispatcher.prototype );  //  THREE.EventDispatcher.prototype.apply( this );\n\n    this.isDisabled = false;\n\n    this.isUp    = false;\n    this.isDown  = false;\n    this.isLeft  = false;\n    this.isRight = false;\n    this.inRun   = false; // hack.\n    this.isMoveKeyHolded = false;\n    this.frontAngle = 0;\n\n    this._keydownListener = onkeydown.bind( this );\n    this._keyupListener   = onkeyup.bind( this );\n    this._blurListener    = onblur.bind( this );\n\n    window.addEventListener( 'keydown', this._keydownListener, false );\n    window.addEventListener( 'keyup',   this._keyupListener,   false );\n    window.addEventListener( 'blur',    this._blurListener,    false );\n\n  };\n\n  ns.KeyInputControl.prototype.jump = function () {\n\n    this.dispatchEvent( { type: 'jumpkeypress' } );\n\n  };\n\n  ns.KeyInputControl.prototype.updateAngle = function () {\n\n    var up    = this.isUp;\n    var down  = this.isDown;\n    var left  = this.isLeft;\n    var right = this.isRight;\n\n    if (  up && !left && !down && !right )      { this.frontAngle = DEG_0  ; }\n    else if (  up &&  left && !down && !right ) { this.frontAngle = DEG_45 ; }\n    else if ( !up &&  left && !down && !right ) { this.frontAngle = DEG_90 ; }\n    else if ( !up &&  left &&  down && !right ) { this.frontAngle = DEG_135; }\n    else if ( !up && !left &&  down && !right ) { this.frontAngle = DEG_180; }\n    else if ( !up && !left &&  down &&  right ) { this.frontAngle = DEG_225; }\n    else if ( !up && !left && !down &&  right ) { this.frontAngle = DEG_270; }\n    else if (  up && !left && !down &&  right ) { this.frontAngle = DEG_315; }\n\n  };\n\n\n  function onkeydown ( e ) {\n\n    if ( this.isDisabled ) { return; }\n\n    switch ( e.keyCode ) {\n\n      case KEY_W :\n      case KEY_UP :\n        this.isUp = true;\n        break;\n\n      case KEY_S :\n      case KEY_DOWN :\n        this.isDown = true;\n        break;\n\n      case KEY_A :\n      case KEY_LEFT :\n        this.isLeft = true;\n        break;\n\n      case KEY_D :\n      case KEY_RIGHT :\n        this.isRight = true;\n        break;\n\n      case KEY_SPACE :\n        this.jump();\n        break;\n\n      default:\n        return;\n\n    }\n    \n    var prevAngle = this.frontAngle;\n\n    this.updateAngle();\n\n    if ( prevAngle !== this.frontAngle ) {\n\n      this.dispatchEvent( { type: 'movekeychange' } );\n\n    }\n\n    if (\n      ( this.isUp || this.isDown || this.isLeft || this.isRight ) &&\n      !this.isMoveKeyHolded\n    ) {\n\n      this.isMoveKeyHolded = true;\n      this.dispatchEvent( { type: 'movekeyon' } );\n\n    }\n\n  }\n\n  function onkeyup ( e ) {\n\n    if ( this.isDisabled ) { return; }\n\n    switch ( e.keyCode ) {\n\n      case KEY_W :\n      case KEY_UP :\n        this.isUp = false;\n        break;\n\n      case KEY_S :\n      case KEY_DOWN :\n        this.isDown = false;\n        break;\n        \n      case KEY_A :\n      case KEY_LEFT :\n        this.isLeft = false;\n        break;\n\n      case KEY_D :\n      case KEY_RIGHT :\n        this.isRight = false;\n        break;\n\n      case KEY_SPACE :\n        break;\n\n      case KEY_R:\n        this.inRun = !this.inRun; // hack //  console.log(\"case KEY_R:\", e.keyCode, this.inRun);\n        break;\n\n      default:\n        return;\n\n    }\n    \n    var prevAngle = this.frontAngle;\n\n    this.updateAngle();\n\n    if ( prevAngle !== this.frontAngle ) {\n\n      this.dispatchEvent( { type: 'movekeychange' } );\n\n    }\n\n    if ( !this.isUp && !this.isDown && !this.isLeft && !this.isRight &&\n      (\n           e.keyCode === KEY_W\n        || e.keyCode === KEY_UP\n        || e.keyCode === KEY_S\n        || e.keyCode === KEY_DOWN\n        || e.keyCode === KEY_A\n        || e.keyCode === KEY_LEFT\n        || e.keyCode === KEY_D\n        || e.keyCode === KEY_RIGHT\n      )\n    ) {\n\n      this.isMoveKeyHolded = false;\n      this.dispatchEvent( { type: 'movekeyoff' } );\n\n    }\n\n  }\n\n  function onblur ( e ) {\n\n    this.isUp    = false;\n    this.isDown  = false;\n    this.isLeft  = false;\n    this.isRight = false;\n//  this.inRun   = false; // hack // DO NOT SET TO FALSE ON BLUR. //\n    \n    if ( this.isMoveKeyHolded ) {\n\n      this.isMoveKeyHolded = false;\n      this.dispatchEvent( { type: 'movekeyoff' } );\n\n    }\n\n  }\n\n} )( THREE, MW );\n\n// @author yomotsu\n// MIT License\n\n;( function ( THREE, ns ) {\n\n  'use strict';\n\n  var PI2     = Math.PI * 2,\n      PI_HALF = Math.PI / 2;\n\n  var modulo = function ( n, d ) {\n\n    return ( ( n % d ) + d ) % d;\n\n  };\n\n  // camera              isntance of THREE.Camera\n  // trackObject         isntance of THREE.Object3D\n  // params.el           DOM element\n  // params.radius       number\n  // params.minRadius    number\n  // params.maxRadius    number\n  // params.rigidObjects array of inctances of THREE.Mesh\n  ns.TPSCameraControl = function ( camera, trackObject, params ) {\n\n    Object.assign( this, THREE.EventDispatcher.prototype );  //  THREE.EventDispatcher.prototype.apply( this );\n    this.camera = camera;\n    this.trackObject  = trackObject;\n    this.el           = params && params.el || document.body;\n    this.offset       = params && params.offset || new THREE.Vector3( 0, 0, 0 ),\n    this.radius       = params && params.radius    || 10;\n    this.minRadius    = params && params.minRadius || 1;\n    this.maxRadius    = params && params.maxRadius || 30;\n    this.rigidObjects = params && params.rigidObjects || [];\n    this.lat   = 0;\n    this.lon   = 0;\n    this.phi   = 0; // angle of zenith\n    this.theta = 0; // angle of azimuth\n    this.mouseAccelerationX = params && params.mouseAccelerationX !== undefined ? params.mouseAccelerationX : 100;\n    this.mouseAccelerationY = params && params.mouseAccelerationY !== undefined ? params.mouseAccelerationY : 30;\n    this._pointerStart = { x: 0, y: 0 };\n    this._pointerLast  = { x: 0, y: 0 };\n\n    this.setNearPlainCornersWithPadding();\n    this.update();\n\n    this._mousedownListener = onmousedown.bind( this );\n    this._mouseupListener   = onmouseup.bind( this );\n    this._mousedragListener = onmousedrag.bind( this );\n    this._scrollListener    = onscroll.bind( this );\n\n    this.el.addEventListener( 'mousedown', this._mousedownListener, false );\n    this.el.addEventListener( 'mouseup',   this._mouseupListener,   false );\n    this.el.addEventListener( 'mousewheel',     this._scrollListener, false );\n    this.el.addEventListener( 'DOMMouseScroll', this._scrollListener, false );\n\n  };\n\n  ns.TPSCameraControl.prototype = {\n\n    constructor: ns.TPSCameraControl,\n\n    update: function () {\n\n      var position,\n          distance;\n\n      this._center = new THREE.Vector3(\n        this.trackObject.matrixWorld.elements[ 12 ] + this.offset.x,\n        this.trackObject.matrixWorld.elements[ 13 ] + this.offset.y,\n        this.trackObject.matrixWorld.elements[ 14 ] + this.offset.z\n      );\n      position = new THREE.Vector3(\n        Math.cos( this.phi ) * Math.cos( this.theta + PI_HALF ),\n        Math.sin( this.phi ),\n        Math.cos( this.phi ) * Math.sin( this.theta + PI_HALF )\n      );\n      distance = this.collisionTest( position.clone().normalize() );\n      position.multiplyScalar( distance );\n      position.add( this._center );\n      this.camera.position.copy( position );\n\n      if ( this.lat === 90 ) {\n\n        this.camera.up.set(\n          Math.cos( this.theta + Math.PI ),\n          0,\n          Math.sin( this.theta + Math.PI )\n        );\n\n      } else if ( this.lat === -90 ) {\n\n        this.camera.up.set(\n          Math.cos( this.theta ),\n          0,\n          Math.sin( this.theta )\n        );\n\n      } else {\n\n        this.camera.up.set( 0, 1, 0 );\n\n      }\n\n      this.camera.lookAt( this._center );\n      this.dispatchEvent( { type: 'updated' } );\n\n    },\n\n    getFrontAngle: function () {\n\n      return PI2 + this.theta;\n\n    },\n\n    setNearPlainCornersWithPadding: function () {\n\n      var near = this.camera.near,\n          halfFov = this.camera.fov * 0.5,\n          h = ( Math.tan( THREE.Math.degToRad( halfFov ) ) * near ),\n          w = h * this.camera.aspect;\n\n      this.nearPlainCornersWithPadding = [\n        new THREE.Vector3( -w - near, -h - near, 0 ),\n        new THREE.Vector3(  w + near, -h - near, 0 ),\n        new THREE.Vector3(  w + near,  h + near, 0 ),\n        new THREE.Vector3( -w - near,  h + near, 0 )\n      ];\n\n    },\n\n    setLatLon: function ( lat, lon ) {\n\n      this.lat = lat >  90 ?  90 :\n                 lat < -90 ? -90 :\n                 lat;\n      this.lon = lon < 0 ? 360 + lon % 360 : lon % 360;\n\n      this.phi   =  THREE.Math.degToRad( this.lat );\n      this.theta = -THREE.Math.degToRad( this.lon );\n\n    },\n\n    collisionTest: function ( direction ) {\n\n      var i,\n          distance = this.radius,\n          nearPlainCorner,\n          rotationMatrix = new THREE.Matrix4(),\n          rotationX = new THREE.Matrix4().makeRotationX( this.phi ),\n          rotationY = new THREE.Matrix4().makeRotationY( this.theta ),\n          origin,\n          raycaster,\n          intersects;\n\n      rotationMatrix.multiplyMatrices( rotationX, rotationY );\n\n      for ( i = 0; i < 4; i ++ ) {\n\n        nearPlainCorner = this.nearPlainCornersWithPadding[ i ].clone();\n        nearPlainCorner.applyMatrix4( rotationMatrix );\n\n        origin = new THREE.Vector3(\n          this._center.x + nearPlainCorner.x,\n          this._center.y + nearPlainCorner.y,\n          this._center.z + nearPlainCorner.z\n        );\n        raycaster = new THREE.Raycaster(\n          origin,           // origin\n          direction,        // direction\n          this.camera.near, // near\n          this.radius       // far\n        );\n        intersects = raycaster.intersectObjects( this.rigidObjects );\n\n        if ( intersects.length !== 0 && intersects[ 0 ].distance < distance ) {\n\n          distance = intersects[ 0 ].distance;\n\n        }\n\n      }\n\n      return distance;\n\n    }\n\n  };\n\n  function onmousedown ( event ) {\n\n    this.dispatchEvent( { type: 'mousedown' } );\n    this._pointerStart.x = event.clientX;\n    this._pointerStart.y = event.clientY;\n    this._pointerLast.x = this.lon;\n    this._pointerLast.y = this.lat;\n    this.el.removeEventListener( 'mousemove', this._mousedragListener, false );\n    this.el.addEventListener( 'mousemove', this._mousedragListener, false );\n//  document.body.className += ' js-TPSCameraDragging';\n    document.body.classList.add(\"js-TPSCameraDragging\");\n\n  }\n\n  function onmouseup () {\n\n    this.dispatchEvent( { type: 'mouseup' } );\n    this.el.removeEventListener( 'mousemove', this._mousedragListener, false );\n//  document.body.className = document.body.className.replace( / js-TPSCameraDragging/g, '' );\n    document.body.classList.remove(\"js-TPSCameraDragging\");\n\n  }\n\n  function onmousedrag ( event ) {\n\n    var w = this.el.offsetWidth,\n        h = this.el.offsetHeight,\n        x = ( this._pointerStart.x - event.clientX ) / w * 2,\n        y = ( this._pointerStart.y - event.clientY ) / h * 2;\n\n    this.setLatLon(\n      this._pointerLast.y + y * this.mouseAccelerationY,\n      this._pointerLast.x + x * this.mouseAccelerationX\n    );\n\n  }\n\n  function onscroll ( event ) {\n\n    event.preventDefault();\n\n    if ( event.wheelDeltaY ) {\n\n      // WebKit\n      this.radius -= event.wheelDeltaY * 0.05;\n\n    } else if ( event.wheelDelta ) {\n\n      // IE\n      this.radius -= event.wheelDelta * 0.05 ;\n\n    } else if ( event.detail ) {\n\n      // Firefox\n      this.radius += event.detail;\n\n    }\n\n    this.radius = Math.max( this.radius, this.minRadius );\n    this.radius = Math.min( this.radius, this.maxRadius );\n\n  }\n\n} )( THREE, MW );\n"
			},
			{
				"name": "VirtualInput.js",
				"source": "/*!\n * @author yomotsu http://yomotsu.net/\n * MIT License\n */\n\nvirtualInput = {};\n\n( function ( ns ) {\n\n    var _ua = function () {\n        return {\n            Touch: typeof document.ontouchstart != \"undefined\",\n            Pointer: window.navigator.pointerEnabled,\n            MSPoniter: window.navigator.msPointerEnabled\n        }\n    };\n\n    ns._start = \"pointerdown MSPointerDown touchstart mousedown\";\n    ns._move  = \"pointermove MSPointerMove touchmove  mousemove\";\n    ns._end   = \"pointerup   MSPointerUp   touchend   mouseup\";\n\n    ns.Joystick = function ( $container, size, params ) {\n\n        Object.assign( this, THREE.EventDispatcher.prototype );  //  THREE.EventDispatcher.prototype.apply( this );\n\n        this.angle = 0;\n        this.position = { x: 0, y: 0 };\n        this.pointerId = null;\n        this.isActive = false;\n\n        this.width = size * 2;\n        this.halfWidth = size;\n\n        var that = this;\n        var id = params && params.id ? params.id  : '';\n        var template = [\n          '<div class=\"gameinput-joystick\" id=\"' + id + '\">',\n            '<div class=\"gameinput-joystick__button\"></div>',\n            '<svg class=\"gameinput-frame\" width=\"' + this.width + '\" height=\"' + this.width + '\" viewbox=\"0 0 64 64\">',\n              '<polygon points=\"32 19 34 21 30 21\" fill=\"#fff\"></polygon>',\n              '<polygon points=\"45 32 43 34 43 30\" fill=\"#fff\"></polygon>',\n              '<polygon points=\"32 45 34 43 30 43\" fill=\"#fff\"></polygon>',\n              '<polygon points=\"19 32 21 34 21 30\" fill=\"#fff\"></polygon>',\n              '<circle cx=\"32\" cy=\"32\" r=\"16\" fill=\"none\" stroke=\"#fff\" stroke-width=\"' + ( this.halfWidth / 64 ) + '\"></circle>',\n            '</svg>',\n          '</div>'\n        ].join( '' );\n\n        var $win = $( window );\n        this.$all = $( template );\n        this.$button = this.$all.find( \".gameinput-joystick__button\" );\n        $container.append( this.$all );\n\n        this.$all.css({\n            width:  this.width,\n            height: this.width\n        });\n\n        this.$button.css({\n            width:  size * .6,\n            height: size * .6\n        });\n\n        this.offset = this.$all.offset();\n        this.buttonRadius = this.$button.width() / 2;\n        this.frameRadius = size / 2;\n    //  this.position = { x: 0, y: 0 };\n\n        var onbuttondown = function ( event ) {\n\n            event.preventDefault();\n            event.stopPropagation();\n            \n            that.dispatchEvent( { type: 'active' } );\n            that.isActive = true;\n            \n            if ( event.originalEvent.pointerId ) {\n            \n                that.pointerId = event.originalEvent.pointerId;\n            \n            } else if ( event.originalEvent.changedTouches ) {\n            \n                that.pointerId = event.originalEvent.changedTouches[ event.originalEvent.changedTouches.length - 1 ].identifier;\n            \n            }\n            \n            var coordinate = that.getEventCoordinate( event );\n            \n            if ( !coordinate ) { return; }\n            \n            that.setPosition( coordinate.x, coordinate.y );\n            \n            $win.on( ns._move, onbuttonmove );\n            $win.on( ns._end,  onbuttonup );\n\n        };\n\n        var onbuttonmove = function ( event ) {\n\n            event.preventDefault();\n            event.stopPropagation();\n            \n            var coordinate = that.getEventCoordinate( event );\n            \n            if ( !coordinate ) {\n                return;\n            }\n            \n            that.setPosition( coordinate.x, coordinate.y );\n\n        };\n\n        var onbuttonup = function ( event ) {\n\n            event.stopPropagation();\n\n            var wasEventHappend;\n\n            if ( event.originalEvent.pointerId ) {\n\n                if ( that.pointerId !== event.originalEvent.pointerId ) {\n                    return;\n                }\n\n            } else if ( event.originalEvent.changedTouches ) {\n            \n                for ( i = 0, l = event.originalEvent.changedTouches.length; i < l; i ++ ) {\n                \n                    if ( that.pointerId === event.originalEvent.changedTouches[ i ].identifier ) {\n                        wasEventHappend = true;\n                        break;\n                    }\n                \n                    if ( !wasEventHappend ) {\n                        return;\n                    }\n                \n                }\n            \n            }\n\n            that.dispatchEvent( { type: \"disactive\" } );\n            that.isActive = false;\n            that.setPosition( 0, 0 );\n            $win.off( ns._move, onbuttonmove );\n            $win.off( ns._end,  onbuttonup );\n\n        };\n\n        this.setCSSPosition( 0, 0 );\n        this.$all.on( ns._start, onbuttondown );\n\n        $win.on( \"resize\", function () {\n\n            that.offset = that.$all.offset();\n\n        });\n\n    };\n\n    ns.Joystick.prototype.getLength = function ( x, y ) {\n        return Math.sqrt( Math.pow( x, 2 ) + Math.pow( y, 2 ) );\n    };\n\n    ns.Joystick.prototype.getAngle = function ( lengthX, lengthY ) {\n\n        if ( lengthX === 0 && lengthY === 0 ) {\n          return this.angle;\n        }\n\n        var angle = Math.atan( lengthY / lengthX );\n\n        if ( 0 > lengthX && 0 <= lengthY ) {\n          //the second quadrant\n          angle += Math.PI;\n\n        } else if ( 0 > lengthX && 0 > lengthY ) {\n          //the third quadrant\n          angle += Math.PI;\n\n        } else if ( 0 <= lengthX && 0 > lengthY ) {\n          //the fourth quadrant\n          angle += Math.PI * 2;\n\n        }\n\n        this.angle = angle;\n        return angle;\n\n    };\n\n    ns.Joystick.prototype.getPointOnRadius = function ( angle ) {\n\n        return {\n          x: Math.cos( angle ),\n          y: Math.sin( angle )\n        };\n\n    };\n\n    ns.Joystick.prototype.getEventCoordinate = function ( event ) {\n\n        var x, y, _event = null, i, l;\n\n        if ( event.originalEvent.pointerId ) {\n\n            if ( this.pointerId === event.originalEvent.pointerId ) {\n                _event = event.originalEvent;\n            }\n\n        } else if ( event.originalEvent.changedTouches ) {\n\n            for ( i = 0, l = event.originalEvent.changedTouches.length; i < l; i ++ ) {\n                if ( this.pointerId === event.originalEvent.changedTouches[ i ].identifier ) {\n                  _event = event.originalEvent.changedTouches[ i ];\n                }\n            }\n\n        } else {\n\n            _event = event;\n\n        }\n\n        if ( _event === null ) {\n            return false;\n        }\n\n        x = (   ( _event.clientX - this.offset.left ) - this.halfWidth ) / this.halfWidth * 2;\n        y = ( - ( _event.clientY - this.offset.top  ) + this.halfWidth ) / this.halfWidth * 2;\n\n        return { x: x, y: y };\n\n    };\n\n    ns.Joystick.prototype.setPosition = function ( x, y ) {\n\n        this.position.x = x;\n        this.position.y = y;\n        var length = this.getLength( x, y );\n        var angle = this.getAngle( x, y );\n\n        if ( 1 >= length ) {\n            this.setCSSPosition( x, y );\n            return;\n        }\n\n        var pointOnRadius = this.getPointOnRadius( angle );\n        this.setCSSPosition( pointOnRadius.x, pointOnRadius.y );\n\n    };\n\n    ns.Joystick.prototype.setCSSPosition = function ( x, y ) {\n\n        this.$button.css( {\n            left: ( this.halfWidth + x * this.frameRadius - this.buttonRadius ),\n            top:  ( this.halfWidth - y * this.frameRadius - this.buttonRadius )\n        });\n\n    };\n\n    ns.Button = function ( $container, size, params ) {\n\n        Object.assign( this, THREE.EventDispatcher.prototype );  // THREE.EventDispatcher.prototype.apply( this );\n\n        var that = this;\n        var id = params && params.id ? params.id  : \"\";\n        var label = params.label;\n        var template = [\n          '<div class=\"gameinput-button\" id=\"' + id + '\">',\n            '<div class=\"gameinput-button__inner\">',\n              label,\n            '</div>',\n          '</div>'\n        ].join( \"\" );\n        var $button = $( template );\n        $container.append( $button );\n        $button.css( {\n            width: size,\n            height: size\n        });\n\n        $button.on( ns._start, function () {\n            that.dispatchEvent( { type: \"press\" } );\n        });\n\n    };\n\n})( virtualInput );\n"
			},
			{
				"name": "UVsDebug.js",
				"source": "/* \n * @author zz85 / http://github.com/zz85\n * @author WestLangley / http://github.com/WestLangley\n *\n * tool for \"unwrapping\" and debugging three.js \n * geometries UV mapping\n *\n * Sample usage:\n *\tdocument.body.appendChild( THREE.UVsDebug( new THREE.SphereGeometry( 10, 10, 10, 10 ) );\n *\n */\n \nTHREE.UVsDebug = function( geometry, size ) {\n\n\t// handles wrapping of uv.x > 1 only\n    \n\tvar abc = 'abc';\n\n\tvar uv, u, ax, ay;\n\tvar i, il, j, jl;\n\tvar vnum;\n\n\tvar a = new THREE.Vector2();\n\tvar b = new THREE.Vector2();\n\n\tvar geo = ( geometry instanceof THREE.BufferGeometry ) ? new THREE.Geometry().fromBufferGeometry( geometry ) : geometry;\n\n\tvar faces = geo.faces;\n\tvar uvs = geo.faceVertexUvs[ 0 ];\n\n\tvar canvas = document.createElement( 'canvas' );\n\tvar width = size || 1024;   // power of 2 required for wrapping\n\tvar height = size || 1024;\n\tcanvas.width = width;\n\tcanvas.height = height;\n\n\tvar ctx = canvas.getContext( '2d' );\n\tctx.lineWidth = 1;\n\tctx.strokeStyle = 'rgba( 0, 0, 0, 1.0 )';\n\tctx.textAlign = 'center';\n\n\t// paint background white\n\n\tctx.fillStyle = 'rgba( 255, 255, 255, 1.0 )';\n\tctx.fillRect( 0, 0, width, height );\n\n\tfor ( i = 0, il = uvs.length; i < il; i ++ ) {\n\n\t\tuv = uvs[ i ];\n\n\t\t// draw lines\n\n\t\tctx.beginPath();\n\n\t\ta.set( 0, 0 );\n\n\t\tfor ( j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\tu = uv[ j ];\n\n\t\t\ta.x += u.x;\n\t\t\ta.y += u.y;\n\n\t\t\tif ( j == 0 ) {\n\n\t\t\t\tctx.moveTo( u.x * width, ( 1 - u.y ) * height );\n\n\t\t\t} else {\n\n\t\t\t\tctx.lineTo( u.x * width, ( 1 - u.y ) * height );\n\n\t\t\t}\n\n\t\t}\n\n\t\tctx.closePath();\n\t\tctx.stroke();\n\n\t\ta.divideScalar( jl );\n\n\t}\n\n\treturn canvas;\n\n};\n\n//  disable labels.\n\n/*\n\t\t// label the face number\n\n\t\tctx.font = \"12pt Arial bold\";\n\t\tctx.fillStyle = 'rgba( 0, 0, 0, 1.0 )';\n\t\tctx.fillText( i, a.x * width, ( 1 - a.y ) * height );\n\n\t\tif ( a.x > 0.95 ) {\n\n\t\t\t// wrap x // 0.95 is arbitrary\n\n\t\t\tctx.fillText( i, ( a.x % 1 ) * width, ( 1 - a.y ) * height );\n\n\t\t}\n\n\t\tctx.font = \"8pt Arial bold\";\n\t\tctx.fillStyle = 'rgba( 0, 0, 0, 1.0 )';\n\n\t\t// label uv edge orders\n\n\t\tfor ( j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\tu = uv[ j ];\n\t\t\tb.addVectors( a, u ).divideScalar( 2 );\n\n\t\t\tvnum = faces[ i ][ abc[ j ] ];\n\t\t\tctx.fillText( abc[ j ] + vnum, b.x * width, ( 1 - b.y ) * height );\n\n\t\t\tif ( b.x > 0.95 ) {\n\n\t\t\t\t// wrap x\n\n\t\t\t\tctx.fillText( abc[ j ] + vnum, ( b.x % 1 ) * width, ( 1 - b.y ) * height );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn canvas;\n\n};\n*/\n\n"
			},
			{
				"name": "SubdivisionModifier.js",
				"source": "/*\n *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\n *\t@author centerionware / http://www.centerionware.com\n *\n *\tSubdivision Geometry Modifier\n *\t\tusing Loop Subdivision Scheme\n *\n *\tReferences:\n *\t\thttp://graphics.stanford.edu/~mdfisher/subdivision.html\n *\t\thttp://www.holmes3d.net/graphics/subdivision/\n *\t\thttp://www.cs.rutgers.edu/~decarlo/readings/subdiv-sg00c.pdf\n *\n *\tKnown Issues:\n *\t\t- currently doesn't handle \"Sharp Edges\"\n */\n\nTHREE.SubdivisionModifier = function ( subdivisions ) {\n\n\tthis.subdivisions = ( subdivisions === undefined ) ? 1 : subdivisions;\n\n};\n\n// Applies the \"modify\" pattern\nTHREE.SubdivisionModifier.prototype.modify = function ( geometry ) {\n\n\tvar repeats = this.subdivisions;\n\n\twhile ( repeats -- > 0 ) {\n\n\t\tthis.smooth( geometry );\n\n\t}\n\n\tgeometry.computeFaceNormals();\n\tgeometry.computeVertexNormals();\n\n};\n\n( function() {\n\n\t// Some constants\n\tvar WARNINGS = ! true; // Set to true for development\n\tvar ABC = [ 'a', 'b', 'c' ];\n\n\n\tfunction getEdge( a, b, map ) {\n\n\t\tvar vertexIndexA = Math.min( a, b );\n\t\tvar vertexIndexB = Math.max( a, b );\n\n\t\tvar key = vertexIndexA + \"_\" + vertexIndexB;\n\n\t\treturn map[ key ];\n\n\t}\n\n\n\tfunction processEdge( a, b, vertices, map, face, metaVertices ) {\n\n\t\tvar vertexIndexA = Math.min( a, b );\n\t\tvar vertexIndexB = Math.max( a, b );\n\n\t\tvar key = vertexIndexA + \"_\" + vertexIndexB;\n\n\t\tvar edge;\n\n\t\tif ( key in map ) {\n\n\t\t\tedge = map[ key ];\n\n\t\t} else {\n\n\t\t\tvar vertexA = vertices[ vertexIndexA ];\n\t\t\tvar vertexB = vertices[ vertexIndexB ];\n\n\t\t\tedge = {\n\n\t\t\t\ta: vertexA, // pointer reference\n\t\t\t\tb: vertexB,\n\t\t\t\tnewEdge: null,\n\t\t\t\t// aIndex: a, // numbered reference\n\t\t\t\t// bIndex: b,\n\t\t\t\tfaces: [] // pointers to face\n\n\t\t\t};\n\n\t\t\tmap[ key ] = edge;\n\n\t\t}\n\n\t\tedge.faces.push( face );\n\n\t\tmetaVertices[ a ].edges.push( edge );\n\t\tmetaVertices[ b ].edges.push( edge );\n\n\n\t}\n\n\tfunction generateLookups( vertices, faces, metaVertices, edges ) {\n\n\t\tvar i, il, face, edge;\n\n\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tmetaVertices[ i ] = { edges: [] };\n\n\t\t}\n\n\t\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tface = faces[ i ];\n\n\t\t\tprocessEdge( face.a, face.b, vertices, edges, face, metaVertices );\n\t\t\tprocessEdge( face.b, face.c, vertices, edges, face, metaVertices );\n\t\t\tprocessEdge( face.c, face.a, vertices, edges, face, metaVertices );\n\n\t\t}\n\n\t}\n\n\tfunction newFace( newFaces, a, b, c ) {\n\n\t\tnewFaces.push( new THREE.Face3( a, b, c ) );\n\n\t}\n\n\tfunction midpoint( a, b ) {\n\n\t\treturn ( Math.abs( b - a ) / 2 ) + Math.min( a, b );\n\n\t}\n\n\tfunction newUv( newUvs, a, b, c ) {\n\n\t\tnewUvs.push( [ a.clone(), b.clone(), c.clone() ] );\n\n\t}\n\n\t/////////////////////////////\n\n\t// Performs one iteration of Subdivision\n\tTHREE.SubdivisionModifier.prototype.smooth = function ( geometry ) {\n\n\t\tvar tmp = new THREE.Vector3();\n\n\t\tvar oldVertices, oldFaces, oldUvs;\n\t\tvar newVertices, newFaces, newUVs = [];\n\n\t\tvar n, l, i, il, j, k;\n\t\tvar metaVertices, sourceEdges;\n\n\t\t// new stuff.\n\t\tvar sourceEdges, newEdgeVertices, newSourceVertices;\n\n\t\toldVertices = geometry.vertices; // { x, y, z}\n\t\toldFaces = geometry.faces; // { a: oldVertex1, b: oldVertex2, c: oldVertex3 }\n\t\toldUvs = geometry.faceVertexUvs[ 0 ];\n\n\t\tvar hasUvs = oldUvs !== undefined && oldUvs.length > 0;\n\n\t\t/******************************************************\n\t\t *\n\t\t * Step 0: Preprocess Geometry to Generate edges Lookup\n\t\t *\n\t\t *******************************************************/\n\n\t\tmetaVertices = new Array( oldVertices.length );\n\t\tsourceEdges = {}; // Edge => { oldVertex1, oldVertex2, faces[]  }\n\n\t\tgenerateLookups( oldVertices, oldFaces, metaVertices, sourceEdges );\n\n\n\t\t/******************************************************\n\t\t *\n\t\t *\tStep 1.\n\t\t *\tFor each edge, create a new Edge Vertex,\n\t\t *\tthen position it.\n\t\t *\n\t\t *******************************************************/\n\n\t\tnewEdgeVertices = [];\n\t\tvar other, currentEdge, newEdge, face;\n\t\tvar edgeVertexWeight, adjacentVertexWeight, connectedFaces;\n\n\t\tfor ( i in sourceEdges ) {\n\n\t\t\tcurrentEdge = sourceEdges[ i ];\n\t\t\tnewEdge = new THREE.Vector3();\n\n\t\t\tedgeVertexWeight = 3 / 8;\n\t\t\tadjacentVertexWeight = 1 / 8;\n\n\t\t\tconnectedFaces = currentEdge.faces.length;\n\n\t\t\t// check how many linked faces. 2 should be correct.\n\t\t\tif ( connectedFaces != 2 ) {\n\n\t\t\t\t// if length is not 2, handle condition\n\t\t\t\tedgeVertexWeight = 0.5;\n\t\t\t\tadjacentVertexWeight = 0;\n\n\t\t\t\tif ( connectedFaces != 1 ) {\n\n\t\t\t\t\tif ( WARNINGS ) console.warn( 'Subdivision Modifier: Number of connected faces != 2, is: ', connectedFaces, currentEdge );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewEdge.addVectors( currentEdge.a, currentEdge.b ).multiplyScalar( edgeVertexWeight );\n\n\t\t\ttmp.set( 0, 0, 0 );\n\n\t\t\tfor ( j = 0; j < connectedFaces; j ++ ) {\n\n\t\t\t\tface = currentEdge.faces[ j ];\n\n\t\t\t\tfor ( k = 0; k < 3; k ++ ) {\n\n\t\t\t\t\tother = oldVertices[ face[ ABC[ k ] ] ];\n\t\t\t\t\tif ( other !== currentEdge.a && other !== currentEdge.b ) break;\n\n\t\t\t\t}\n\n\t\t\t\ttmp.add( other );\n\n\t\t\t}\n\n\t\t\ttmp.multiplyScalar( adjacentVertexWeight );\n\t\t\tnewEdge.add( tmp );\n\n\t\t\tcurrentEdge.newEdge = newEdgeVertices.length;\n\t\t\tnewEdgeVertices.push( newEdge );\n\n\t\t\t// console.log(currentEdge, newEdge);\n\n\t\t}\n\n\t\t/******************************************************\n\t\t *\n\t\t *\tStep 2.\n\t\t *\tReposition each source vertices.\n\t\t *\n\t\t *******************************************************/\n\n\t\tvar beta, sourceVertexWeight, connectingVertexWeight;\n\t\tvar connectingEdge, connectingEdges, oldVertex, newSourceVertex;\n\t\tnewSourceVertices = [];\n\n\t\tfor ( i = 0, il = oldVertices.length; i < il; i ++ ) {\n\n\t\t\toldVertex = oldVertices[ i ];\n\n\t\t\t// find all connecting edges (using lookupTable)\n\t\t\tconnectingEdges = metaVertices[ i ].edges;\n\t\t\tn = connectingEdges.length;\n\n\t\t\tif ( n == 3 ) {\n\n\t\t\t\tbeta = 3 / 16;\n\n\t\t\t} else if ( n > 3 ) {\n\n\t\t\t\tbeta = 3 / ( 8 * n ); // Warren's modified formula\n\n\t\t\t}\n\n\t\t\t// Loop's original beta formula\n\t\t\t// beta = 1 / n * ( 5/8 - Math.pow( 3/8 + 1/4 * Math.cos( 2 * Math. PI / n ), 2) );\n\n\t\t\tsourceVertexWeight = 1 - n * beta;\n\t\t\tconnectingVertexWeight = beta;\n\n\t\t\tif ( n <= 2 ) {\n\n\t\t\t\t// crease and boundary rules\n\t\t\t\t// console.warn('crease and boundary rules');\n\n\t\t\t\tif ( n == 2 ) {\n\n\t\t\t\t\tif ( WARNINGS ) console.warn( '2 connecting edges', connectingEdges );\n\t\t\t\t\tsourceVertexWeight = 3 / 4;\n\t\t\t\t\tconnectingVertexWeight = 1 / 8;\n\n\t\t\t\t\t// sourceVertexWeight = 1;\n\t\t\t\t\t// connectingVertexWeight = 0;\n\n\t\t\t\t} else if ( n == 1 ) {\n\n\t\t\t\t\tif ( WARNINGS ) console.warn( 'only 1 connecting edge' );\n\n\t\t\t\t} else if ( n == 0 ) {\n\n\t\t\t\t\tif ( WARNINGS ) console.warn( '0 connecting edges' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewSourceVertex = oldVertex.clone().multiplyScalar( sourceVertexWeight );\n\n\t\t\ttmp.set( 0, 0, 0 );\n\n\t\t\tfor ( j = 0; j < n; j ++ ) {\n\n\t\t\t\tconnectingEdge = connectingEdges[ j ];\n\t\t\t\tother = connectingEdge.a !== oldVertex ? connectingEdge.a : connectingEdge.b;\n\t\t\t\ttmp.add( other );\n\n\t\t\t}\n\n\t\t\ttmp.multiplyScalar( connectingVertexWeight );\n\t\t\tnewSourceVertex.add( tmp );\n\n\t\t\tnewSourceVertices.push( newSourceVertex );\n\n\t\t}\n\n\n\t\t/******************************************************\n\t\t *\n\t\t *\tStep 3.\n\t\t *\tGenerate Faces between source vertices\n\t\t *\tand edge vertices.\n\t\t *\n\t\t *******************************************************/\n\n\t\tnewVertices = newSourceVertices.concat( newEdgeVertices );\n\t\tvar sl = newSourceVertices.length, edge1, edge2, edge3;\n\t\tnewFaces = [];\n\n\t\tvar uv, x0, x1, x2;\n\t\tvar x3 = new THREE.Vector2();\n\t\tvar x4 = new THREE.Vector2();\n\t\tvar x5 = new THREE.Vector2();\n\n\t\tfor ( i = 0, il = oldFaces.length; i < il; i ++ ) {\n\n\t\t\tface = oldFaces[ i ];\n\n\t\t\t// find the 3 new edges vertex of each old face\n\n\t\t\tedge1 = getEdge( face.a, face.b, sourceEdges ).newEdge + sl;\n\t\t\tedge2 = getEdge( face.b, face.c, sourceEdges ).newEdge + sl;\n\t\t\tedge3 = getEdge( face.c, face.a, sourceEdges ).newEdge + sl;\n\n\t\t\t// create 4 faces.\n\n\t\t\tnewFace( newFaces, edge1, edge2, edge3 );\n\t\t\tnewFace( newFaces, face.a, edge1, edge3 );\n\t\t\tnewFace( newFaces, face.b, edge2, edge1 );\n\t\t\tnewFace( newFaces, face.c, edge3, edge2 );\n\n\t\t\t// create 4 new uv's\n\n\t\t\tif ( hasUvs ) {\n\n\t\t\t\tuv = oldUvs[ i ];\n\n\t\t\t\tx0 = uv[ 0 ];\n\t\t\t\tx1 = uv[ 1 ];\n\t\t\t\tx2 = uv[ 2 ];\n\n\t\t\t\tx3.set( midpoint( x0.x, x1.x ), midpoint( x0.y, x1.y ) );\n\t\t\t\tx4.set( midpoint( x1.x, x2.x ), midpoint( x1.y, x2.y ) );\n\t\t\t\tx5.set( midpoint( x0.x, x2.x ), midpoint( x0.y, x2.y ) );\n\n\t\t\t\tnewUv( newUVs, x3, x4, x5 );\n\t\t\t\tnewUv( newUVs, x0, x3, x5 );\n\n\t\t\t\tnewUv( newUVs, x1, x4, x3 );\n\t\t\t\tnewUv( newUVs, x2, x5, x4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Overwrite old arrays\n\t\tgeometry.vertices = newVertices;\n\t\tgeometry.faces = newFaces;\n\t\tif ( hasUvs ) geometry.faceVertexUvs[ 0 ] = newUVs;\n\n\t\t// console.log('done');\n\n\t};\n\n} )();\n"
			},
			{
				"name": "shader.js",
				"source": "//  shader.js\n    \n    var vertexShader = [\n    \n        \"attribute vec4 tangent;\",\n    \n        \"uniform float time;\",\n        \"uniform vec2 repeat;\",\n        \"uniform float useNormal;\",\n        \"uniform float useRim;\",\n    \n        \"varying vec2 vUv;\",\n        \"varying vec3 vTangent;\",\n        \"varying vec3 vBinormal;\",\n        \"varying vec3 vNormal;\",\n        \"varying vec3 vEye;\",\n        \"varying vec3 vU;\",\n        \"varying vec2 vN;\",\n    \n        \"void main() {\",\n    \n            \"vU = normalize( vec3( modelViewMatrix * vec4( position, 1.0 ) ) );\",\n    \n            \"if( useNormal == 0. ) {\",\n                \"vec3 n = normalize( normalMatrix * normal );\",\n                \"vec3 r = reflect( vU, n );\",\n                \"float m = 2.0 * sqrt( r.x * r.x + r.y * r.y + ( r.z + 1.0 ) * ( r.z+1.0 ) );\",\n                \"vN = vec2( r.x / m + 0.5,  r.y / m + 0.5 );\",\n            \"} else {\",\n                \"vN = vec2( 0. );\",\n            \"}\",\n    \n            \"vUv = repeat * uv;\",\n            \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \n            \"vNormal = normalize( normalMatrix * normal );\",\n            \"if( useNormal == 1. ) {\",\n                \"vTangent = normalize( normalMatrix * tangent.xyz );\",\n                \"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\",\n            \"} else {\",\n                \"vTangent = vec3( 0. );\",\n                \"vBinormal = vec3( 0. );\",\n            \"}\",\n    \n            \"if( useRim > 0. ) {\",\n                \"vEye = ( modelViewMatrix * vec4( position, 1.0 ) ).xyz;\",\n            \"} else {\",\n                \"vEye = vec3( 0. );\",\n            \"}\",\n        \"}\"\n    ].join(\" \");\n    \n    var fragmentShader = [\n    \n        \"uniform float time;\",\n        \"uniform float bump;\",\n        \"uniform sampler2D tNormal;\",\n        \"uniform sampler2D tMatCap;\",\n        \"uniform float noise;\",\n        \"uniform float useNormal;\",\n        \"uniform float useRim;\",\n        \"uniform float rimPower;\",\n        \"uniform float useScreen;\",\n        \"uniform float normalScale;\",\n        \"uniform float normalRepeat;\",\n    \n        \"varying vec2 vUv;\",\n        \"varying vec3 vTangent;\",\n        \"varying vec3 vBinormal;\",\n        \"varying vec3 vNormal;\",\n        \"varying vec3 vEye;\",\n        \"varying vec3 vU;\",\n        \"varying vec2 vN;\",\n    \n        \"float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}\",\n    \n        \"void main() {\",\n    \n            \"vec3 finalNormal = vNormal;\",\n            \"vec2 calculatedNormal = vN;\",\n    \n            \"if( useNormal == 1. ) {\",\n                \"vec3 normalTex = texture2D( tNormal, vUv * normalRepeat ).xyz * 2.0 - 1.0;\",\n                \"normalTex.xy *= normalScale;\",\n                \"normalTex.y *= -1.;\",\n                \"normalTex = normalize( normalTex );\",\n                \"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\",\n                \"finalNormal = tsb * normalTex;\",\n    \n                \"vec3 r = reflect( vU, normalize( finalNormal ) );\",\n                \"float m = 2.0 * sqrt( r.x * r.x + r.y * r.y + ( r.z + 1.0 ) * ( r.z+1.0 ) );\",\n                \"calculatedNormal = vec2( r.x / m + 0.5,  r.y / m + 0.5 );\",\n            \"}\",\n    \n            \"vec3 base = texture2D( tMatCap, calculatedNormal ).rgb;\",\n    \n            // rim lighting\n    \n            \"if( useRim > 0. ) {\",\n                \"float f = rimPower * abs( dot( vNormal, normalize( vEye ) ) );\",\n                \"f = useRim * ( 1. - smoothstep( 0.0, 1., f ) );\",\n                \"base += vec3( f );\",\n            \"}\",\n    \n            // screen blending\n    \n            \"if( useScreen == 1. ) {\",\n                \"base = vec3( 1. ) - ( vec3( 1. ) - base ) * ( vec3( 1. ) - base );\",\n            \"}\",\n    \n            // noise \n    \n            \"base += noise * ( .5 - random( vec3( 1. ), length( gl_FragCoord ) ) );\",\n    \n            \"gl_FragColor = vec4( base, 1. );\",\n        \"}\",\n    ].join(\"\");\n    \n    function ShaderMaterial(normalMap, matcapMap, callback){\n        return new Promise( function(resolve, reject){\n            var material = new THREE.ShaderMaterial( {\n                uniforms: { \n                    tNormal: { type: \"t\", value: normalMap },\n                    tMatCap: { type: \"t\", value: matcapMap },\n                    time: { type: \"f\", value: 0 },\n                    bump: { type: \"f\", value: 0 },\n                    noise: { type: \"f\", value: 0.04 },\n                    repeat: { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\n                    useNormal: { type: \"f\", value: 0 },\n                    useRim: { type: \"f\", value: 0 },\n                    rimPower: { type: \"f\", value: 0 },\n                    useScreen: { type: \"f\", value: 0 },\n                    normalScale: { type: \"f\", value: 1 },\n                    normalRepeat: { type: \"f\", value: 1 }\n                },\n                vertexShader: vertexShader,       //  document.getElementById( \"vertexShader\" ).textContent,\n                fragmentShader: fragmentShader,   //  document.getElementById( \"fragmentShader\" ).textContent,\n                shading: THREE.SmoothShading,\n                side: THREE.DoubleSide\n            });\n    \n            material.uniforms.tMatCap.value.wrapS = material.uniforms.tMatCap.value.wrapT = THREE.ClampToEdgeWrapping;\n            material.uniforms.tNormal.value.wrapS = material.uniforms.tNormal.value.wrapT = THREE.RepeatWrapping;\n    \n            material.uniforms.tMatCap.value.needsUpdate = true;\n            material.uniforms.tNormal.value.needsUpdate = true;\n    \n            if ( !!callback ) callback( material );\n    \n            resolve( material );\n        });\n    }\n\n"
			},
			{
				"name": "AW3D.js (v0.4)",
				"source": "//  AW3D.js (v0.4.0)\n\n\tAW3D = { VERSION: \"0.4.0 dev\" };\n\n//  Player Holder.\n    AW3D.PlayerHolder = function ( name ){\n        var holder = new THREE.Object3D();\n        holder.position.set( 0, 1, 0 );\n        holder.name = name || \"PLAYER HOLDER\";\n        return holder;\n    };\n\n//  Player Holder Helper.\n    AW3D.PlayerHolderHelper = function ( name ){\n        var helper = new THREE.BoxHelper();\n        helper.name = name || \"HOLDER HELPER\";\n        helper.visible = true;\n        return helper;\n    };\n\n//  Player Controller Direction pointer.\n    AW3D.DirectionPointer = function ( name ){\n        var geometry = new THREE.CylinderGeometry( 0, 1, 20, 12 );\n\t//  BE CAREFULL: is not \"mesh.rotation.y = -Math.PI\".\n        geometry.rotateX( Math.PI / 2 );  //  important!\n        var material = new THREE.MeshStandardMaterial({color:0x00ff00});\n        var pointer = new THREE.Mesh(geometry, material);\n        pointer.position.set(0, 15, 0);\n        pointer.name = name || \"PLAYER DIRECTION\";\n        pointer.visible = true;\n        return pointer;\n    };\n\n//  Player Sphere.\n    AW3D.PlayerSphere = function ( name ){\n        var sphere = new THREE.Mesh(\n            new THREE.SphereGeometry( 15, 8, 4 ),\n            new THREE.MeshBasicMaterial({ \n\t\t\t\tcolor: 0xff0000,  \n\t\t\t\twireframe: true,\n\t\t\t})\n        ); \n        sphere.position.y = 12;\n        sphere.name = name || \"PLAYER SPHERE\";\n        sphere.visible = true;\n        return sphere;\n    };\n\n//  Player pointer.\n    AW3D.PlayerPointer = function ( name ){\n        var geometry = new THREE.CylinderGeometry( 0, 1, 20, 12 );\n\t//  BE CAREFULL: is not \"mesh.rotation.y = -Math.PI\".\n        geometry.rotateX( Math.PI / 2 );  //  important!\n        var material = new THREE.MeshNormalMaterial();\n        var pointer = new THREE.Mesh(geometry, material);\n        pointer.position.set(0, 40, 0);\n        pointer.name = name || \"PLAYER POINTER\";\n        pointer.visible = true; // debugMode || false;\n        return pointer;\n    };\n\n\n//  OutfitManager.js\n\n    AW3D.OutfitManager = function(){\n\n        var self = this;\n\n\t//  requires \"signals.min.js\"\n        var Signal = signals.Signal;\n        this.added = new Signal();\n        this.removed = new Signal();\n        this.changed = new Signal();\n\n        this.eventTimeout = undefined;\n        this.direction = new THREE.Object3D();\n\n        this.gender = {\n            male    : false,\n            female  : false,\n            shemale : false,\n            trans   : false,\n        };\n\n        this.genitals = { \n            vagina   : false,\n            penis    : false,\n            attached : false,\n        };\n\n        this.layers = [\n            \"body\",\n            \"head\",\n            \"face\",\n            \"hairs\",\n            \"upper\", // chest.\n            \"lower\", // hips.\n            \"torso\", // (chest & hips).\n            \"arms\",\n            \"legs\",\n            \"hands\",\n            \"feet\",\n            \"genitals\", \n            \"skeleton\",\n        ];\n\n        this.slots = [\n            \"skeleton\",\n            \"body\",\n            \"hairs\",\n            \"eyes\",\n            \"glasses\",\n            \"hat\",\n            \"stockings\",\n            \"underwears\",\n            \"costume\",\n            \"tshirt\",\n            \"skirt\",\n            \"trousers\",\n            \"skirt\",\n            \"dress\",\n            \"shoes\",\n            \"coat\",\n            \"penis\", \n            \"vagina\",\n        ];\n\n        this.stickers = [\n            \"skin\",\n            \"makeup\",\n            \"tattoo\",\n            \"bodypaint\",\n            \"neck\",\n            \"chest\",\n            \"belly\",\n            \"upperlimb\",\n            \"arm\",\n            \"forearm\",\n            \"wrist\",\n            \"hand\",\n            \"lowerlimb\",\n            \"thigh\",\n            \"leg\",\n            \"foot\",\n            \"butt\",\n            \"back\",\n            \"scapula\",\n            \"lumbar\",\n        ];\n\n        this.attachments = [\n            \"helmet\",\n            \"face\",\n            \"mask\",\n            \"teeth\",\n            \"beard\",\n            \"eyelash\",\n            \"glasses\",\n            \"ears\",\n            \"belly\",\n            \"gun\",\n            \"wepon\",\n            \"knife\",\n            \"sword\",\n            \"bistol\",\n            \"watch\",\n            \"jewelry\",\n            \"earings\",\n            \"necklace\",\n            \"bracelet\",\n            \"bag\",\n            \"handbag\",\n            \"cape\",\n            \"coat\",\n            \"horn\",\n            \"tail\",\n            \"penis\", \n        ];\n\n        this.AnimationsHandler = [];\n\n    //  Outfit.AnimationsHandler is an simple array where local\n    //  player.outfit keeps the AW3D.AnimationHandler instances.\n\n        this.AnimationsHandler.reset = function(){\n            this.length = 0; // reset array.\n        };\n\n        this.AnimationsHandler.stop = function(){\n            this.forEach( function( anim ){\n                if (!!anim ) anim.stop();\n            });\n        };\n\n        this.AnimationsHandler.jump = function(){\n            this.forEach( function( anim ){\n                if (!!anim ) anim.jump();\n            });\n        };\n\n        this.AnimationsHandler.play = function(){\n            for (var i in arguments){\n                var name = arguments[i];\n                this.forEach( function( anim ){\n                    if (!!anim ) anim.play(name);\n                });\n            }\n        };\n\n        this.AnimationsHandler.weightOff = function(){\n            for (var i in arguments){\n                var name = arguments[i];\n                this.forEach( function( anim ){\n                    if (!!anim ) anim.weightOff(name);\n                });\n            }\n        };\n\n        this.AnimationsHandler.weightOn = function(){\n            for (var i in arguments){\n                var name = arguments[i];\n                this.forEach( function( anim ){\n                    if (!!anim ) anim.weightOn(name);\n                });\n            }\n        };\n\n        this.AnimationsHandler.fadeIn = function(){\n            for (var i in arguments){\n                var name = arguments[i];\n                this.forEach( function( anim ){\n                    if (!!anim ) anim.fadeIn(name);\n                });\n            }\n        };\n\n        this.AnimationsHandler.fadeOut = function(){\n            for (var i in arguments){\n                var name = arguments[i];\n                this.forEach( function( anim ){\n                    if (!!anim ) anim.fadeOut(name);\n                });\n            }\n        };\n\n        this.AnimationsHandler.refresh = function(){\n\n            this.stop();\n            this.fill(null);\n            this.reset();\n\n            var gender = self.getGender();\n\n            self.slots.forEach( function(name, i){\n\n                if ( !!self[ name ] ){\n    \n                    var handler = new AW3D.AnimationHandler( self[ name ], gender );\n\n                    self.AnimationsHandler.push( handler );\n                }\n            });\n    \n            this.play(\"idle\");\n        };\n\n    //  Outfit EventDispatcher.\n        Object.assign( this, THREE.EventDispatcher.prototype );  // important!\n\n    };\n\n\n    AW3D.OutfitManager.prototype = {\n\n        constructor: AW3D.OutfitManager,\n\n        refresh: function(){\n            this.AnimationsHandler.refresh();\n        },\n\n\n        get: function(){\n\n            var results = {};\n\n            var _get = ( arg ) => {\n\n                if ( typeof( arg ) == \"string\" ) {\n                    if ( !!this[arg] ) results[arg] =  this[arg];\n                }\n\n                if ( arg instanceof Array ) {\n                    arg.forEach( ( key ) => {\n                        _get( key );\n                    });\n                }\n            };\n\n            if ( arguments.length > 0 ){\n\n                for (var i in arguments){\n\n                    if ( !arguments[i] ) continue;\n\n                    _get( arguments[i] );\n\n                }\n\n            } else {\n\n                this.slots.forEach( (name) => { _get( name ); });\n\n            }\n\n            return results;\n\n        },\n\n        set: function(){\n        //  Set \"this.slot\" but not add to \"this.direction\".\n\n            for (var arg in arguments){\n\n                if (!arguments[arg]) continue;\n\n                var name = Object.keys(arguments[arg])[0];\n                var asset = Object.values(arguments[arg])[0];\n\n                if ( !name || name == null || !asset ) continue;\n                if ( !!this[ name ] ) this.remove( name );\n\n                this[ name ] = asset;\n\n            //  Create an animation handler for this outfit slot.\n                var handler = new AW3D.AnimationHandler( this[ name ], this.getGender() );\n\n            //  Add animation handler.\n                this.AnimationsHandler.push( handler );\n\n            }\n\n        //  Send \"change\" event only when last \n        //  add has been completed (delay:100ms).\n\n            var msec = 100;\n            clearTimeout( this.eventTimeout );\n            this.eventTimeout = setTimeout( () => {\n                this.dispatchEvent( {type:\"change\"} );\n                this.changed && this.changed.dispatch();\n            }, msec);\n\n            return this;\n        },\n\n        add: function(){\n\n            for (var arg in arguments) {\n\n                if (!arguments[arg]) continue;\n\n                var name = Object.keys(arguments[arg])[0];\n                var asset = Object.values(arguments[arg])[0];\n\n                if ( !name || name == null || !asset ) continue;\n                if ( this[ name ] ) this.remove( name );  // important!\n\n                this[ name ] = asset;\n\n            //  Create an animation handler for this outfit slot.\n                var handler = new AW3D.AnimationHandler( this[name], this.getGender() );\n\n                if ( this.AnimationsHandler.length ) {\n\n                //  Copy each action properties of first animation handler.\n                    var masterHandler = this.AnimationsHandler[0];\n\n                    for ( var action in handler.actions ) {\n\n                        if ( !action ) break;\n\n                        handler.actions[action].loop = masterHandler.actions[action].loop;\n                        handler.actions[action].weight = masterHandler.actions[action].weight;\n                        handler.actions[action].timeScale = masterHandler.actions[action].timeScale;\n                        handler.actions[action].currentTime = masterHandler.actions[action].currentTime;\n                        handler.actions[action].interpolationType = masterHandler.actions[action].interpolationType;\n\n                        if ( masterHandler.actions[action].isPlaying ) {\n                            handler.actions[action].play( masterHandler.actions[action].currentTime );\n                        }\n\n                    }\n\n                //  Add animation handler.\n                    this.AnimationsHandler.push( handler );\n\n                } else {\n\n                //  Add animation handler.\n                    this.AnimationsHandler.push( handler );\n                //  Play idle.\n                    this.AnimationsHandler.play(\"idle\");\n\n                }\n\n            //  Add outfit item to scene.\n                this.direction.add( this[ name ] );\n\n            }\n\n        //  this.AnimationsHandler.refresh(); \n\n            this.dispatchEvent( {type:\"add\"} );\n            this.added && this.added.dispatch();\n\n        //  Send \"change\" event only when last \n        //  add has been completed (delay:100ms).\n\n            var msec = 100;\n            clearTimeout( this.eventTimeout );\n            this.eventTimeout = setTimeout( () => {\n                this.dispatchEvent( {type:\"change\"} );\n                this.changed && this.changed.dispatch();\n            }, msec);\n\n            return this;\n        },\n\n        remove: function(){\n\n            if ( arguments.length == 0 ) return;\n\n            for (var arg in arguments){\n\n                if ( !arguments[arg] ) continue;\n                if ( !this.slots.includes( arguments[arg] ) ) continue;\n\n                var name = arguments[arg];\n\n            //  Remove from scene (does not throw error).\n                this.direction.remove( this[ name ] );\n\n            //  Dispose textures.\n\n                if ( this[ name ] ) {\n                    \n                    if (this[ name ].material && !this[ name ].material.materials) {\n\n                    //  Single material.\n\n                        Object.keys(this[ name ].material).filter( (key) => {\n                            return this[ name ].material[ key ] instanceof THREE.Texture;\n                        }).forEach( (key) => {\n                            this[ name ].material[ key ].dispose();\n                        //  DO NOT NULL/DELETE TEXTURE.  important!\n                        });\n\n                        this[ name ].material.dispose();\n\n                    } else if (this[ name ].material.materials && this[ name ].material.materials.length) {\n\n                    //  Multimaterial.\n\n                        this[ name ].material.materials.forEach(function(material){\n\n                            Object.keys(material).filter(function(key){\n                                return material[ key ] instanceof THREE.Texture;\n                            }).forEach(function(key){\n                                material[ key ].dispose();\n                            //  DO NOT NULL/DELETE TEXTURE. important!\n                            });\n\n                            material.dispose();\n\n                        });\n\n                    }\n\n                }\n\n            //  Dispose geometry.\n                if ( this[ name ] ) this[ name ].geometry.dispose();\n\n            //  Dispose bones texture. !important\n                if ( this[ name ] && this[ name ].skeleton  )\n                    this[ name ].skeleton.boneTexture.dispose();\n\n            //  Remove the animation handler.\n\n                if ( this.AnimationsHandler.length ) {\n\n                //  Find handler index.\n                    var index = this.AnimationsHandler.findIndex((handler) => {\n                        return handler.mesh == this[ name ];\n                    });\n\n                    //  Keep in mind \"splice()\" uses \"zero\" \n                    //  and \"negative\" indexes also. // danger!\n                    //  debugMode && console.log({\"index\": index});\n\n                    if ( index != undefined && index > -1 ) {\n\n                    //  Get and remove handler from AnimationsHandler.\n                        var handler = this.AnimationsHandler.splice(index, 1)[0];\n\n                    //  Stop handler animations.\n                        handler.stop();\n\n                    }\n\n                }\n\n            //  Delete slot.\n                delete this[ name ];\n\n            }\n\n        //  this.AnimationsHandler.refresh(); \n\n            this.dispatchEvent( {type:\"remove\"} );\n            this.removed && this.removed.dispatch();\n\n        //  Send \"change\" event only when last \n        //  remove has been completed (delay:100ms).\n\n            var msec = 100;\n            clearTimeout( this.eventTimeout );\n            this.eventTimeout = setTimeout( () => {\n                this.dispatchEvent( {type:\"change\"} );\n                this.changed && this.changed.dispatch();\n            }, msec);\n\n            return this;\n        },\n\n        removeAll: function() { \n\n            this.slots.forEach( ( name ) => {\n                if ( this[ name ] ) this.remove( name );\n            });\n\n            return this;\n\n        },\n\n        removeFromScene: function(){\n\n            if ( arguments.length == 0 ) {\n\n                this.slots.forEach( ( name ) => {\n                    this.remove( name );\n                });\n\n            } else {\n\n                for (var arg in arguments){\n                    this.remove( arguments[arg] );\n                }\n            }\n\n            return this;\n        },\n\n        removeTexture: function( outfit, map, index ){\n\n            //  outfit: outfit slot name (e.g \"body\", \"hair\", \"dress\", etc.)\n            //  map   : material map name (e.g. \"map\", \"bumpMap\", \"normalMap\", etc.)\n            //  index : material index of multimaterial (\"null\" for simple material).\n\n            if ( !this[ outfit ] ) return;\n            if ( !this[ outfit ].material ) return;\n\n            //  Material.\n\n            if ( index == null || isNaN(index) || typeof(index) != \"number\" ) {\n\n                if ( !this[ outfit ].material[ map ] ) return;\n\n                this[ outfit ].material[ map ].dispose();\n                this[ outfit ].material[ map ] = null;\n                this[ outfit ].material.needsUpdate = true;\n\n                return;\n            }\n\n            //  MultiMaterial.\n\n            if ( typeof(index) == \"number\" && index > -1 ) {\n\n                if ( !this[ outfit ].material.materials ) return;\n                if ( !this[ outfit ].material.materials[ index ] ) return;\n                if ( !this.body.material.materials[ index ][ map ] ) return;\n\n                this[ outfit ].material.materials[ index ][ map ].dispose();\n                this[ outfit ].material.materials[ index ][ map ] = null;\n                this[ outfit ].material.materials[ index ].needsUpdate = true;\n\n                return;\n            }\n        },\n\n        setGender: function( gender ){\n\n            var self = this;\n\n            Object.keys(this.gender).forEach( function( name ){\n                self.gender[ name ] = ( name == gender );\n            });\n\n        //  Outfit direction scale. (object3D)\n\n            switch ( this.getGender() ){\n\n                case \"male\":\n                    this.direction.scale.set(1, 1, 1);\n                    break;\n\n                case \"female\":\n                    this.direction.scale.set(0.95, 0.95, 0.95);\n                    break;\n\n                default:\n                    this.direction.scale.set(1, 1, 1);\n            }\n\n            this.AnimationsHandler.refresh();\n\n            return this;\n        },\n\n        getGender: function(){\n\n            var self = this;\n\n            if (arguments.length > 0){\n\n                return self.gender[ arguments[0] ];\n\n            } else {\n\n                return Object.keys(this.gender).find( function( name ){\n                    return self.gender[ name ];\n                });\n\n            }\n        },\n\n        resetGender: function(){\n\n            var self = this;\n\n            Object.keys(this.gender).forEach( function( name ){\n                self.gender[ name ] = false;\n            });\n\n            this.direction.scale.set(1, 1, 1);\n            this.AnimationsHandler.refresh();\n\n            return this;\n        },\n\n        getPose: function( name ){\n\n            var name = name || \"body\";\n            if ( !this[ name ] ) return;\n            if ( !this.slots.includes( name ) ) return;\n\n            var pose = [];\n\n            for (var i in this[ name ].skeleton.bones) {\n                var key = {}; // {\"pos\":[], \"rot\":[], \"scl\":[]};\n                key.pos = this[ name ].skeleton.bones[i].position.toArray();\n                key.rot = this[ name ].skeleton.bones[i].quaternion.toArray();\n                key.scl = this[ name ].skeleton.bones[i].scale.toArray();\n                pose.push(key);\n            }\n\n            return pose;\n        },\n\n\n        toJSON: function(){\n\n            var data = {};\n\n            if ( arguments.length == 0 ) {\n\n                for (var i = 0; i < this.slots.length; i++) {\n\n                    var name = this.slots[i];\n\n                    if ( !name ) continue;\n                    if ( !this[ name ] ) continue;\n                    if ( !this.slots.includes( name ) ) continue;\n\n                    data[ name ] = {};\n                    data[ name ].name      = name;\n                    data[ name ].visible   = this[ name ].visible;\n                    data[ name ].scale     = this[ name ].scale.toArray();\n                    data[ name ].geometry  = this[ name ].geometry.sourceFile;\n                    data[ name ].material  = materialtoJSON( this[ name ].material );\n\n                }\n\n            } else {\n\n                for (var i = 0; i < arguments.length; i++){\n\n                    var name = arguments[i];\n\n                    if ( !name ) continue;\n                    if ( !this[ name ] ) continue;\n                    if ( !this.slots.includes( name ) ) continue;\n\n                    data[ name ] = {};\n                    data[ name ].name      = name;\n                    data[ name ].visible   = this[ name ].visible;\n                    data[ name ].scale     = this[ name ].scale.toArray();\n                    data[ name ].geometry  = this[ name ].geometry.sourceFile;\n                    data[ name ].material = materialtoJSON( this[ name ].material );\n\n                }\n\n            }\n\n            if ( this.getGender() ) \n                data.gender = this.getGender();\n\n            var data = JSON.stringify( data );\n\n            if ( data === \"{}\" ) \n                return null;\n            else \n                return JSON.parse( data );\n\n        },\n\n    //  fromJSON (v2.1).\n\n        fromJSON: function( json ){\n\n\t\t//  Make a copy of json. important!\n\n            if ( typeof(json) == \"object\" ) {\n\n                try {\n\n                    var json = JSON.stringify( json ); // string copy of json.\n\n                } catch(err) { throw err; }\n\n            }\n\n\t\t//  requires \"validation.js\".\n\n            if ( typeof(json) == \"string\" ) {\n\n                if ( !validator.isJSON( json ) ) {\n                    throw \"Validation Error: json not valid\";\n                }\n\n            } else {\n\n\t\t\t\tthrow \"Type Error: json is not string type.\";\n\n\t\t\t}\n\n\t\t\t\n\t\t\tvar json = JSON.parse( json ); // (now is a json copy).\n\n\n            var self = this;\n\n        //  Set gender first.\n\n            this.removeAll();          // important!\n            var gender = json.gender;  // important!\n            this.setGender( gender );  // important!\n\n        //  Clear gender of json.\n            delete json.gender; // (is a copy of json).\n\n        //  ORDER DOES MATTER for transparency:\n        //   Order in localPlayer.outfit.direction.children array DOES MATTER.\n        //  So we must deliver the outfit.direction.children array with the following order:\n        //  [skeleton, body, eyes, hairs, stockings, underwears, tshirt, trousers, costume, dress, shoes, coat]\n\n            var orderMap = [];\n\n            (function(){\n                if (json.skeleton) orderMap.push(\"skeleton\");\n                if (json.body) orderMap.push(\"body\");\n                if (json.eyes) orderMap.push(\"eyes\");\n                if (json.glasses) orderMap.push(\"glasses\");\n                if (json.hairs) orderMap.push(\"hairs\");\n                if (json.hat) orderMap.push(\"hat\");\n                if (json.stockings) orderMap.push(\"stockings\");\n                if (json.underwears) orderMap.push(\"underwears\");\n                if (json.costume) orderMap.push(\"costume\");\n                if (json.tshirt) orderMap.push(\"tshirt\");\n                if (json.trousers) orderMap.push(\"trousers\");\n                if (json.skirt) orderMap.push(\"skirt\");\n                if (json.dress) orderMap.push(\"dress\");\n                if (json.shoes) orderMap.push(\"shoes\");\n                if (json.coat) orderMap.push(\"coat\");\n            })();\n\n        //  debugMode && console.log({\"orderMap\": orderMap});\n\n            var outfit = {};\n\t\t\tvar promises = [];\n\n            for (var i = 0; i < orderMap.length; i++){\n\n\t\t\t\tpromises.push(\n\t\t\t\t\tnew Promise(function(resolve, reject){\n\n\t\t\t\t\t\tvar object = {};\n\t\t\t\t\t\tvar sortIndex = i;\n\t\t\t\t\t\tvar key = orderMap[i];\n\n\t\t\t\t\t\tobject.name      = json[ key ].name;\n\t\t\t\t\t\tobject.visible   = json[ key ].visible;\n\t\t\t\t\t\tobject.material  = json[ key ].material;\n\t\t\t\t\t\tobject.geometry  = json[ key ].geometry;  // (url).\n\n\t\t\t\t\t//  Scale.\n\t\t\t\t\t\tvar vector = new THREE.Vector3();\n\t\t\t\t\t\tobject.scale = vector.fromArray( json[ key ].scale );\n\n\t\t\t\t\t//  Material.\n\t\t\t\t\t\tvar material = materialfromJSON( object.material );\n\n\t\t\t\t\t//  Geometry: cache first.\n\t\t\t\t\t\tcaches.match( object.geometry ).then(function(response){\n\n\t\t\t\t\t\t\tif ( !response ) \n\t\t\t\t\t\t\t\tthrow \"geometry not found! Trying to fetch geometry...\";\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn response;\n\n\t\t\t\t\t\t}).catch(function(err){\n\n\t\t\t\t\t\t\treturn caches.open(\"geometries\").then(function(cache){\n\t\t\t\t\t\t\t\treturn cache.add( object.geometry ).then(function(){\n\t\t\t\t\t\t\t\t\treturn cache.match( object.geometry ).then(function(response){\n\t\t\t\t\t\t\t\t\t\treturn response;\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t}).then(function(response){\n\n\t\t\t\t\t\t\tif (!response) throw \"None response returned!\";\n\n\t\t\t\t\t\t\treturn response.json();\n\n\t\t\t\t\t\t}).then(function( gmtjson ){\n\n\t\t\t\t\t\t\tif ( !gmtjson ) throw \"None json returned fromJSON!\";\n\n\t\t\t\t\t\t\tvar loader = new THREE.JSONLoader();\n\t\t\t\t\t\t\tvar geometry = loader.parse( gmtjson ).geometry;\n\n\t\t\t\t\t\t\tgeometry.name = gmtjson.name;\n\t\t\t\t\t\t\tgeometry.computeFaceNormals();\n\t\t\t\t\t\t\tgeometry.computeVertexNormals();\n\t\t\t\t\t\t\tgeometry.computeBoundingBox();\n\t\t\t\t\t\t\tgeometry.computeBoundingSphere();\n\t\t\t\t\t\t\tgeometry.sourceFile = object.geometry;  // important!\n\n\t\t\t\t\t\t\tvar skinned = new THREE.SkinnedMesh( geometry, material );\n\n\t\t\t\t\t\t\tskinned.renderDepth = 1;\n\t\t\t\t\t\t\tskinned.frustumCulled = false;\n\t\t\t\t\t\t\tskinned.position.set( 0, 0, 0 );\n\t\t\t\t\t\t\tskinned.rotation.set( 0, 0, 0 );\n\t\t\t\t\t\t\tskinned.scale.copy( object.scale );\n\t\t\t\t\t\t\tskinned.castShadow = true;\n\t\t\t\t\t\t\tskinned.name = object.name;\n\t\t\t\t\t\t\tskinned.sortIndex = sortIndex;\n\n\t\t\t\t\t\t\tvar obj = {};\n\t\t\t\t\t\t\tobj[ key ] = skinned;\n\t\t\t\t\t\t\tresolve( obj );\n\n\t\t\t\t\t\t\toutfit[ key ] = skinned;\n\n\t\t\t\t\t\t}).catch(function(err){\n\t\t\t\t\t\t\tresolve( null );\n\t\t\t\t\t\t\tconsole.error(err);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t}) // end of promise,\n\t\t\t\t); // end push.\n\t\t\t}// end for.\n\n        //  debugMode && console.log(promises);\n\n\t\t\treturn Promise.all(promises).then(function(results){\n\n\t\t\t//  cleanup.\n\t\t\t\tvar results = results.filter(Boolean); // important!\n\n\t\t\t//  add outfit.\n\t\t\t\twhile (results.length) {\n\t\t\t\t\tself.add( results.shift() );\n\t\t\t\t}\n\n\t\t\t}).then(function(){\n\t\t\t\treturn outfit;\n\t\t\t});\n\n\t\t},\n\n\n\t//  Outfit DNA is an object that contains the outfit data that needed to\n\t//  create the player oufit anywhere remotly. It is player outfit assets\n\t//  in transfered structure ( aka like .toJSON() ).\n\t//\n\t//  .toDNA(); .fromDNA(dna); Usage:\n\t//      dna = localPlayer.outfit.toDNA();\n\t//      player = new Player();\n\t//      player.outfit = new AW3D.Outfit(player);\n\t//      player.outfit.fromDNA( dna );\n\n\t//\t.toDNA, .fromDNA (v2).\n\t//\trequires \"rawinflate.js, rawdeflate.js, and validator.js\"\n\n        toDNA: function(){\n\n            return encode( JSON.stringify( this.toJSON() ) );\n\n            function encode( string ) {\n                if ( !!window.RawDeflate ) {\n                    return window.btoa( RawDeflate.deflate( string ) );\n                } else {\n                    return string;\n                }\n            }\n\n        },\n\n        fromDNA: function( dna ){\n\n            //  Validation.\n\n            if ( typeof(dna) == \"string\" ) {\n\n                if ( validator.isBase64( dna ) ) {\n\n                    return new Promise( (resolve, reject) => {\n                        var json = JSON.parse( decode( dna ) );\n                        resolve( this.fromJSON(json) );\n                    }).catch( function(err){ \n                        console.error(err);\n                        throw err; \n                    });\n\n                } else if ( validator.isJSON( dna ) ) {\n\n                    return new Promise( (resolve, reject) => {\n                        var json = JSON.parse( dna );\n                        resolve( this.fromJSON(json) );\n                    }).catch( function(err){ \n                        console.error(err);\n                        throw err; \n                    });\n\n                } else {\n\n                    return new Promise( (resolve, reject) => {\n                        var err = \"DNA is not valid.\";\n                        console.error( \"Error: \" + err );\n                        reject( \"Validation Error: \" + err );\n                        //  throw Error( err );\n                    });\n\n                }\n\n            } else {\n\n                return new Promise( (resolve, reject) => {\n                    var err = \"Unsupported DNA type: \" + typeof(dna);\n                    console.error( \"Error: \" + err );\n                    reject( \"Validation Error: \" + err );\n                    //  throw Error( err );\n                });\n\n            }\n\n            function decode( string ) {\n                if ( !!window.RawDeflate ) {\n                    return RawDeflate.inflate( window.atob( string ) );\n                } else {\n                    return string;\n                }\n            }\n\n        },\n\n\n\t};\n\n\n//  AW3D AnimationHandler.js\n\n//  Reset THREE.AnimationHandler.animations array.\n    THREE.AnimationHandler.animations.length = 0;\n    AnimationManager = THREE.AnimationHandler;\n\n    AW3D.AnimationHandler = function ( mesh, gender ) {\n\n        this.mesh = mesh;\n        this.gender = gender; // important!\n        this.actions = {};\n\n    //  This create the animations of skinned mesh. \n        this.reloadActions(); // important!\n\n    };\n\n\n    AW3D.AnimationHandler.prototype = {\n\n        constructor: AW3D.AnimationHandler,\n\n        findAction: function(action){\n        //  returns new array with resutls.\n            return THREE.AnimationHandler.animations.filter( function(animation){\n                return (animation == action); // boolean.\n            }); \n        },\n\n        findByUuid: function( name ){\n        //  returns new array with resutls.\n            return THREE.AnimationHandler.animations.filter( function(animation){\n                return (animation.uuid == this.actions[ name ].uuid); // boolean.\n            });\n        },\n\n        findByName: function( name ){\n        //  returns new array with resutls.\n            return THREE.AnimationHandler.animations.filter( function(animation){\n                return (animation.data.name == name); // boolean.\n            });\n        },\n\n        getCurrentAction: function(){\n        //  returns current playing action name.\n            for (var name in this.actions) {\n                if ( !name ) return;\n                var action = this.actions[ name ];\n                if ( action.isPlaying ) {\n                    return name;\n                }\n            }\n        },\n\n    //  To stop an animation, find the animation in\n    //  THREE.AnimationHandler.animations and stop it from there.\n\n        stop: function stop(){\n            var self = this;\n            Object.keys( self.actions ).forEach(function(name, i){\n                var action = self.actions[name];\n                self.findAction(action).forEach(function(animation){\n                    animation.stop();\n                });\n            });\n        },\n\n    //  To delete an action, stop the animation in \n    //  THREE.AnimationHandler.animations and then delete it from this.actions.\n\n        delete: function( name ){\n            var action = this.actions[ name ];\n            this.findAction( action ).forEach(function(animation){\n                animation.stop();\n            });\n            delete this.actions[ name ];\n        },\n\n        reset: function reset(){\n            for (var i in arguments){\n                var name = arguments[i];\n                this.actions[ name ].weight = 1;\n                this.actions[ name ].timeScale = 1;\n                this.actions[ name ].currentTime = 0;\n            }\n        },\n\n        resetAll: function(){\n            var self = this;\n            Object.keys( self.actions ).forEach(function(name, i){\n                self.reset( name );\n            });\n        },\n\n        deleteAll: function(){\n            var self = this;\n            Object.keys( self.actions ).forEach(function(name, i){\n                self.delete[ name ]\n            });\n        },\n\n        play: function play(){\n            for (var i in arguments){\n                var name = arguments[i];\n                if ( !this.actions[ name ] ) return;\n                this.actions[ name ].play(0);\n            }\n        },\n\n    //  To pause an animation, find the animation \n    //  in THREE.AnimationHandler.animations and set timeScale to 0.\n    \n        pause: function pause(){\n            for (var i in arguments){\n                var name = arguments[i];\n                var action = this.actions[ name ];\n                this.findAction( action ).forEach(function(animation){\n                    animation.timeScale = 0;\n                });\n            }\n        },\n\n    //  To unpause an animation, find the animation \n    //  in THREE.AnimationHandler.animations and set timeScale to 1.\n\n        continue: function(){\n            for (var i in arguments){\n                var name = arguments[i];\n                var action = this.actions[ name ];\n                this.findAction( action ).forEach(function(animation){\n                    animation.timeScale = 1;\n                });\n            }\n        },\n\n        weightOff: function(){\n            for (var i in arguments){\n                var name = arguments[i];\n                var action = this.actions[ name ];\n                this.findAction( action ).forEach(function(animation){\n                    animation.weight = 0;\n                });\n            }\n        },\n\n        weightOn: function(){\n            for (var i in arguments){\n                var name = arguments[i];\n                var action = this.actions[ name ];\n                this.findAction( action ).forEach(function(animation){\n                    animation.weight = 1;\n                });\n            }\n        },\n\n        fadeIn: function(){\n            var fades = [];\n            for (var i in arguments){\n                var name = arguments[i];\n                var animation = this.actions[ name ];\n                fades.push(function fade(){\n                    var requestId = requestAnimationFrame( fade );\n                    animation.timeScale = 1; // !important\n                    animation.weight += ( 0.05 * (1 - animation.weight) );\n                    animation.play(animation.currentTime, animation.weight);\n                    debugMode && console.log( \"fadeIn: \", round(animation.weight, 3) );\n                    if ( round(animation.weight, 3) > 0.9 ){\n                        cancelAnimationFrame( requestId );\n                        animation.weight = 1;\n                        animation.timeScale = 1;\n                        animation.play(animation.currentTime, 1);\n                    }\n                });\n            }\n\n        //  Call all functions in fades.\n            while (fades.length){ \n                fades.shift().call(); \n            }\n        },\n\n        fadeOut: function(){\n            var fades = [];\n            for (var i in arguments){\n                var name = arguments[i];\n                var action = this.actions[ name ];\n                this.findAction( action ).forEach(function(animation){\n                    fades.push(function fade(){\n                        var requestId = requestAnimationFrame( fade );\n                        animation.timeScale = 1; // !important\n                        animation.weight -= ( 0.05 * animation.weight );\n                        animation.play(animation.currentTime, animation.weight);\n                        debugMode && console.log( \"fadeOut:\", round(animation.weight, 3) );\n                        if ( round(animation.weight, 3) < 0.1 ){\n                            cancelAnimationFrame( requestId );\n                            animation.stop();\n                            animation.weight = 1;\n                            animation.timeScale = 1;\n                        }\n                    });\n                });\n            }\n\n        //  Call all functions in fades.\n            while (fades.length){ \n                fades.shift().call(); \n            }\n        },\n\n        idle: function idle(){\n            this.actions.idle.play(0);\n        },\n\n        jump: function jump(){\n            this.actions.jump.play(0);\n        },\n\n        run: function run(){\n            this.actions.run.play(0);\n        },\n\n        walk: function walk(){\n            this.actions.walk.play(0);\n        },\n\n    //  ------------------------------------------------------  //\n    //  This create the animations of skinned mesh. important!  //\n    //  ------------------------------------------------------  //\n\n        loadAction: function(){\n\n            for ( var i in arguments ) {\n\n                var name = arguments[i];\n\n                var data;\n\n                switch (this.gender) {\n\n                    case \"male\":\n                        data = MaleAnimations[ name ];\n                    break;\n\n                    case \"female\":\n                        data = FemaleAnimations[ name ];\n                    break;\n\n                    default:\n                        data = Animations[ name ];\n                    break;\n                }\n            \n                var action = new THREE.Animation( this.mesh, data );\n                action.uuid = THREE.Math.generateUUID();\n                action.weight = 1;\n                action.timeScale = 1;\n                action.currentTime = 0;\n                this.actions[ name ] = action;\n            }\n\n        },\n\n        reloadActions: function(){\n\n            var self = this;\n\n            this.stop();\n            this.deleteAll();\n            this.actions = {};\n\n            if (this.actions.jump) this.actions.jump.loop = false;\n\n            if (MaleAnimations && this.gender && this.gender == \"male\") {\n                Object.keys( MaleAnimations ).forEach(function(name, i){\n                    self.loadAction( name );\n                });\n\n                return;\n            }\n            \n            if (FemaleAnimations && this.gender && this.gender == \"female\") {\n                Object.keys( FemaleAnimations ).forEach(function(name, i){\n                    self.loadAction( name );\n                });\n\n                return;\n            }\n\n            if ( Animations && !this.gender ) {\n                Object.keys( Animations ).forEach(function(name, i){\n                    self.loadAction( name );\n                });\n\n                return;\n            }\n\n            if ( this.gender && this.gender != \"male\" && this.gender != \"female\" ){\n                console.warn( \"AW3D.AnimationHandler: reloadActions(\" \n\t\t\t\t\t+ this.gender + \"): Gender exists but is not male or female.\"\n                );\n\n                return;\n            }\n\n        },\n\n\t};\n\n\n//  MATERIAL TO JSON.\n\n//  materialtoJson.js (v1.6)\n//  Return a promise with the \n//  material json object resolved.\n\n    function materialtoJSON( material ){\n\n    //  MULTIMATERIAL.\n\n        if ( material.type == \"MultiMaterial\" || material.materials ) {\n\n        //  multimaterial to json.\n\n            var multjson = {\n\n                _id: \"\",\n                type: material.type,\n                uuid: material.uuid || THREE.Math.generateUUID(),\n\n            };\n\n\n        //  materials to json.\n\n            multjson.materials = [];\n\n            for ( var i = 0; i < material.materials.length; i++ ){\n\n                multjson.materials.push( materialtoJSON( material.materials[i] ) );\n\n            }\n\n\n            debugMode && console.log( \"multimaterial to json:\", multjson );\n\n            return multjson;\n\n        }\n\n\n    //  MATERIAL.\n\n        var json = {};\n\n        for ( var name in material ){\n\n            if ( material[ name ] == undefined ) continue;         // important!\n            if ( material[ name ] instanceof Function ) continue;  // important!\n            if ( typeof(material[name]) === \"function\" ) continue; // important!\n\n            switch( name ){\n\n                case \"defines\":\n                case \"program\":\n                case \"_listeners\":\n                case \"needsUpdate\":\n                case \"_needsUpdate\":\n                case \"__webglShader\":\n                break;\n\n\n            //  name, _id, uuid.\n\n                case \"name\":\n                    json.name = material.name;\n                break;\n\n                case \"_id\":\n                    json._id = material._id || ObjectId();\n                break;\n\n                case \"uuid\":\n                    json.uuid = material.uuid || THREE.Math.generateUUID();\n                break;\n\n\n            //  texture to json.\n\n                case \"map\":\n                case \"bumpMap\":\n                case \"alphaMap\":\n                case \"normalMap\":\n                case \"emissiveMap\":\n                case \"displacementMap\":\n                case \"metalnessMap\":\n                case \"roughnessMap\":\n                case \"specularMap\":\n                case \"lightMap\":\n                case \"aoMap\":\n\n                    if ( !(material[ name ] instanceof THREE.Texture) ) {\n                        throw name + \" is not instance of THREE.Texture\";\n                    }\n\n                    json[ name ] = texturetoJSON( material[ name ] );\n\n                break;\n\n\n            //  three color to hex.\n\n                case \"color\":\n                case \"emissive\":\n                case \"specular\":\n\n                    if ( !(material[ name ] instanceof THREE.Color) ) {\n                        throw name + \" is not instance of THREE.Color\";\n                    }\n\n                    json[ name ] = material[ name ].getHex();\n\n                break;\n\n\n            //  vector2 to array.\n\n                case \"normalScale\":\n\n                    if ( !(material[ name ] instanceof THREE.Vector2) ) {\n                        throw name + \" is not instance of THREE.Vector2\";\n                    }\n\n                    json[ name ] = material[ name ].toArray();\n\n                break;\n\n\n\n                case \"envMap\":\n                    //  TODO: cube texture.\n                break;\n\n\n                default:\n                    json[ name ] = material[ name ];\n                break;\n\n            }\n\n        }\n\n        return json;\n    }\n\n\n//  TEXTURE TO JSON.\n//  Return a promise resolved \n//  with the texture json object.\n\n    function texturetoJSON( texture ){\n\n        var json = {};\n\n        for (var name in texture ){\n\n            if ( texture[ name ] == undefined ) continue;\n            if ( texture[ name ] instanceof Function ) continue;\n            if ( typeof(texture[name]) === \"function\" ) continue;\n\n            switch (name){\n\n                case \"_listeners\":\n                break;\n\n\n            //  uuid.\n\n                case \"uuid\":\n                    json[ name ] = texture[ name ] || THREE.Math.generateUUID();\n                break;\n\n\n            //  vector2 to array.\n\n                case \"offset\":\n                case \"repeat\":\n                    json[ name ] = texture[ name ].toArray();\n                break;\n\n\n            //  image to json.\n\n                case \"image\":\n                    json[ name ] = texture.sourceFile || getDataURL( texture[ name ] ); // important!\n                break;\n\n\n                default:\n                    json[ name ] = texture[ name ];\n                break;\n\n            }\n\n        }\n\n        return json;\n    }\n\n\n//  IMAGE TO JSON.\n//  Return an image object.\n\n    function imagetoJSON( image ){\n\n        return {\n            uuid: THREE.Math.generateUUID(),\n            src: image.src || getDataURL( image ),\n        };\n\n    }\n\n\n//  TEXTURE IMAGE TO JSON.\n//  Return an image object.\n\n    function textureImagetoJSON( texture ){\n\n        return {\n            uuid: THREE.Math.generateUUID(),\n            src: texture.sourceFile || texture.image.src || getDataURL( texture.image )\n        };\n\n    }\n\n\n//  MATERIAL FROM JSON.\n//  materialfromJson.js (v1.6)\n//  Return a promise with the material resolved.\n\n    function materialfromJSON( json ){\n\n   //  MULTIMATERIAL.\n\n       if ( json.type == \"MultiMaterial\" ) {\n\n\n           var materials = [];\n\n           for ( var i = 0; i < json.materials.length; i++ ){\n\n               materials.push( materialfromJSON( json.materials[i] ) );\n\n           }\n\n\n       //  Create multimaterial.\n\n           var multimaterial = new THREE.MeshFaceMaterial(materials);\n\n           multimaterial.uuid = json.uuid || THREE.Math.generateUUID();\n\n           return multimaterial;\n\n        }\n\n\n    //  MATERIAL.\n\n        var options = {};\n\n        for (var name in json){\n\n            if ( json[ name ] == undefined ) continue; // important!\n\n\n            switch (name){\n\n                case \"_id\":\n                case \"meta\":\n                break;\n\n\n            //  uuid.\n\n                case \"uuid\":\n                    options.uuid = json.uuid || THREE.Math.generateUUID();\n                break;\n\n\n            //  texture from json.\n\n                case \"alphaMap\":\n                case \"aoMap\":\n                case \"bumpMap\":\n                case \"displacementMap\":\n                case \"emissiveMap\":\n                case \"lightMap\":\n                case \"map\":\n                case \"metalnessMap\":\n                case \"normalMap\":\n                case \"roughnessMap\":\n                case \"specularMap\":\n\n                        options[ name ] = texturefromJSON( json[ name ] );\n\n                break;\n\n\n            //  three color to hex.\n\n                case \"color\":\n                case \"emissive\":\n                case \"specular\":\n\n                    options[ name ] = new THREE.Color();\n                    options[ name ].setHex( json[ name ] );\n\n                break;\n\n\n            //  vector2 from array.\n\n                case \"normalScale\":\n\n                    options[ name ] = new THREE.Vector2();\n                    options[ name ].fromArray( json[ name ] );\n\n                break;\n\n\n                case \"envMap\":\n                    //  TODO: cube texture.\n                break;\n\n\n                default:\n                    options[ name ] = json[ name ];\n                break;\n\n            }\n\n        }\n\n        return new THREE[ options.type ](options);\n    }\n\n\n//  TEXTURE FROM JSON (v1.6)\n//  Return a promise with the texture resolved.\n\n    function texturefromJSON( json ){\n\n        var texture = new THREE.Texture();\n\n        for ( var name in json ){\n\n            switch (name){\n\n                case \"meta\":\n                case \"image\":\n                break;\n\n            //  array to vector2.\n\n                case \"offset\":\n                case \"repeat\":\n\n                    if ( json[ name ].length != 2) break;\n\n                    texture[ name ] = new THREE.Vector2();\n                    texture[ name ].fromArray( json[ name ] );\n\n                break;\n\n\n            //  wrapS & wrapT.\n\n                case \"wrap\":\n\n                    if ( json[ name ].length != 2) break;\n                    if ( !( json[ name ] instanceof Array ) ) break;\n\n                    texture.wrapS = json[ name ][0];\n                    texture.wrapT = json[ name ][1];\n\n                break;\n\n            //  image from texture json with\"FileReader.readAsDataURL(blob)\".\n\n                //  Check whether a match for the request is found in   \n                //  the CacheStorage using CacheStorage.match(). If so, serve that.\n\n                //  If not, open the \"textures\" cache using open(), \n                //  put the default network request in the cache using Cache.put() \n                //  and return a clone of the default network request using return response.clone().\n\n                //  Clone is needed because put() consumes the response body.\n                //  If this fails (e.g., because the network is down), return a fallback response.\n\n                //  Pros:\n\n                    //  Easy to use.\n                    //  Small, compact, safe code.\n                    //  Texture.image.src is string.\n                    //  Texture.image.src is dataURL.\n                    //  Texture.image.src can reused.\n                    //  Texture.image.src is always valid.\n                    //  Texture.image.src can be send everywhere.\n                    //  Texture.image.src can converted to canvas.\n                    //  Texture.image (canvas) size always power of 2.\n                    //  Texture.image.src can saved in storage objects.\n                    //  Texture.image.src can converted vice versa to blob.\n\n                //  Cons:\n\n                    //  Larger size (~33%)\n\t\t\t\t\t//  Take more time than URL.createObjectURL(blob);\n\n            //  sourceFile.\n            //  case \"sourceFile\":\n            //      texture.sourceFile = json[ name ]; // important!\n            //  break;\n\n            //  case \"image\": (N/A).\n                case \"sourceFile\":\n\n                    texture.sourceFile = json.sourceFile;\n\n                //  SourceFile first.\n                    var url = json.sourceFile || json.image.src || json.image || \"//i.imgur.com/ODeftia.jpg\";\n\n                //  URL.\n\n                    if ( validator && validator.isURL( url ) ) {\n\n                    //  Cache first.\n                        caches.match( url ).then(function(response){\n\n                            if ( !response ) \n                                throw \"Texture not found!\";\n                            else\n                                return response;\n\n                        }).catch(function(err){\n\n                        //  We use cors origin mode to avoid\n                        //  texture tainted canvases, images.\n\n                            return fetch( url, {\n                                mode: \"cors\",  // important!\n                                method: \"GET\",\n                            });\n\n                        }).then(function(response){\n\n                            return caches.open(\"textures\").then(function(cache){\n\n\t\t\t\t\t\t\t//  Clone is needed because put() consumes the response body.\n\t\t\t\t\t\t\t//  See: \"https://developer.mozilla.org/en-US/docs/Web/API/Cache/put\"\n\n\t\t\t\t\t\t\t\tvar clone = response.clone();\n\t\t\t\t\t\t\t\treturn cache.put( url, clone ).then(function(){\n\t\t\t\t\t\t\t\t\treturn response.blob();  //  important!\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t});\n\n                        }).then(function(blob){\n\n                            var img = new Image();\n                            img.crossOrigin = \"anonymous\";  //  important!\n\n                            img.onload = function(){\n                                var canvas = makePowerOfTwo( img, true );\n                                texture.image = canvas;\n                                texture.needsUpdate = true;\n\t\t\t\t\t\t\t\timg.onload = null; // optional!\n                            };\n\n                        //  Get dataURL from blob.\n\n                            var reader = new FileReader();\n                            reader.onload = function() {\n                                img.src = reader.result;\n                            };\n\n                            reader.readAsDataURL(blob);\n\n                        });\n                        \n                        break;\n                    } \n\n                //  DataURL.\n\n                    if ( validator && validator.isDataURI( url ) ) {\n                        var img = new Image();\n                        img.crossOrigin = \"anonymous\";\n                        img.onload = function(){\n                            var canvas = makePowerOfTwo( img, true );\n                            texture.image = canvas;\n                            texture.needsUpdate = true;\n\t\t\t\t\t\t\timg.onload = null; // optional!\n                        }; \n\t\t\t\t\t\timg.src = url;  break;\n                    } \n\n                break;\n\n                default:\n                    texture[ name ] = json[ name ];\n                break;\n\n            }\n\n        }\n\n        return texture;\n    }\n\n\n//  IMAGE FROM JSON (v1.6)\n//  Return a promise with the image resolved.\n\n    function imagefromJSON( json, onLoadEnd ){\n\n        var url = json.src;\n\n    //  Cache first.\n        caches.match( url ).then(function(response){\n\n            if ( !response ) \n                throw response;\n            else\n                return response;\n\n        }).catch(function(err){\n\n            //  We use cors origin mode to avoid\n            //  texture tainted canvases, images.\n\n            return fetch( url, {\n                mode: \"cors\",  // important!\n                method: \"GET\",\n            });\n\n    //  TODO: REPLACE async/await FOR BACKWARD COMPETALITY.\n        }).then(function(response){\n\n            return caches.open(\"textures\").then(function(cache){\n\n\t\t\t//  Clone is needed because put() consumes the response body.\n\t\t\t//  See: \"https://developer.mozilla.org/en-US/docs/Web/API/Cache/put\"\n\n\t\t\t\tvar clone = response.clone();\n\t\t\t\treturn cache.put( url, clone ).then(function(){\n\t\t\t\t\treturn response.blob(); //  important!\n\t\t\t\t});\n\n\t\t\t});\n\n        }).then(function(blob){\n\n            var img = new Image();\n            img.crossOrigin = \"anonymous\";  //  important!\n            img.onload = onLoadEnd;\n\n        //  Get dataURL from blob.\n\n            return new Promise(function(resolve, reject){\n\n                var reader = new FileReader();\n                reader.onload = function() {\n                    img.src = reader.result;\n                    resolve( img );\n                };\n\n                reader.readAsDataURL(blob);\n\n            });\n\n        });\n\n    }\n\n\n//  blobToDataUrl.js\n//  https://gist.github.com/tantaman/6921973\n\n    function convertToBase64(blob, callback) {\n\n        var reader = new FileReader();\n\n        reader.onload = function(e) {\n            callback(reader.result);\n        };\n\n        reader.readAsDataURL(blob);\n    }\n\n\n//  dataUrlToBlob.js\n//  https://gist.github.com/tantaman/6921973\n\n    function dataURLToBlob(dataURL) {\n\n        var BASE64_MARKER = \";base64,\";\n\n        if (dataURL.indexOf(BASE64_MARKER) == -1) {\n            var parts = dataURL.split(\",\");\n            var contentType = parts[0].split(\":\")[1];\n            var raw = parts[1];\n\n            return new Blob([raw], {type: contentType});\n        }\n\n        var parts = dataURL.split(BASE64_MARKER);\n        var contentType = parts[0].split(\":\")[1];\n        var raw = window.atob(parts[1]);\n        var rawLength = raw.length;\n\n        var uInt8Array = new Uint8Array(rawLength);\n\n        for (var i = 0; i < rawLength; ++i) {\n            uInt8Array[i] = raw.charCodeAt(i);\n        }\n\n        return new Blob([uInt8Array], {type: contentType});\n    }\n\n\n//  makePowerOfTwo.js\n\n    function makePowerOfTwo( image, natural ) {\n\n        var canvas = document.createElement( \"canvas\" );\n\n        if ( natural ){\n            canvas.width = THREE.Math.nearestPowerOfTwo( image.naturalWidth );\n            canvas.height = THREE.Math.nearestPowerOfTwo( image.naturalHeight );\n        } else {\n            canvas.width = THREE.Math.nearestPowerOfTwo( image.width );\n            canvas.height = THREE.Math.nearestPowerOfTwo( image.height );\n        }\n\n        var context = canvas.getContext( \"2d\" );\n        context.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n    //  debugMode && console.warn( \"outfitLoader:makePowerOfTwo(img):\", \n    //  \"Image resized to:\", canvas.width, \"x\", canvas.height );\n\n        return canvas;\n    }\n\n\n//  getDataURL.js\n\n    function getDataURL( image ) {\n\n        var canvas;\n\n        if ( image.toDataURL !== undefined ) {\n\n            canvas = image;\n\n        } else {\n\n            canvas = document.createElementNS( \"http://www.w3.org/1999/xhtml\", \"canvas\" );\n            canvas.width = image.width;\n            canvas.height = image.height;\n\n            canvas.getContext( \"2d\" ).drawImage( image, 0, 0, image.width, image.height );\n\n        }\n\n        if ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n            return canvas.toDataURL( \"image/jpeg\", 0.6 );\n\n        } else {\n\n            return canvas.toDataURL( \"image/png\" );\n\n        }\n\n    }\n\n\n//  deepCopy.js\n\n    function deepCopy(obj) {\n        if (Object.prototype.toString.call(obj) === \"[object Array]\") {\n            var out = [], i = 0, len = obj.length;\n            for ( ; i < len; i++ ) {\n                out[i] = arguments.callee(obj[i]);\n            }\n            return out;\n        }\n        if (typeof obj === \"object\") {\n            var out = {}, i;\n            for ( i in obj ) {\n                out[i] = arguments.callee(obj[i]);\n            }\n            return out;\n        }\n        return obj;\n    }\n\n\n//  round.js  source: \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\"\n\n    function round(number, precision) {\n        var shift = function (number, precision, reverseShift) {\n            if (reverseShift) {\n                precision = -precision;\n            }  \n            numArray = (\"\" + number).split(\"e\");\n            return +(numArray[0] + \"e\" + (numArray[1] ? (+numArray[1] + precision) : precision));\n        };\n        return shift(Math.round(shift(number, precision, false)), precision, true);\n    }\n\n"
			},
			{
				"name": "world.js",
				"source": "//  MW WORLD.\n\nworld = new MW.World();\n\n//  OCTREE.\n\n//  Make a octree object, which will be the \n//  container of rigid objects such as terrain ect.\n\nvar partition = 2;\n\nvar min = new THREE.Vector3( -1000, -1000, -1000 );\nvar max = new THREE.Vector3(  1000,  1000,  1000 );\n\noctree = new MW.Octree( min, max, partition ); // important!\n\nworld.add( octree );\n\n//  GROUND.\n\nground = new THREE.Mesh(\n\tnew THREE.PlaneGeometry( 2500, 2500, 1, 1 ),\n\tnew THREE.MeshLambertMaterial({ \n\t\tcolor:0x829ec4,\n\t\twireframe:false,\n\t})\n);\n\nground.rotation.x = THREE.Math.degToRad( -90 );\n\n//  If want the ground as collision surface\n//  only, do not add the ground in the scene.\n\n//\tscene.add( ground );\n//\tground.visible = false;\n//\tground.receiveShadow = true;\n\n//  Add the ground to WALKMESH world octree object.\n//  MESHWALK use octree system to detect collision objects.\n\noctree.importThreeMesh( ground ); // important!\n\n//\tRuntime.\n\nvar clock = new THREE.Clock(); // important!\n\nfunction update(){\n\n\tvar dt = clock.getDelta(); // important!\n\tvar time = clock.getElapsedTime(); // optional!\n\n\tworld.step( dt ); // important!\n\n\tTHREE.AnimationHandler.update( dt ); // important!\n}\n\n"
			},
			{
				"name": "localPlayerController.js",
				"source": "//  PlayerController.js\n\nvar Player = function(radius){\n\n\tthis.holder = AW3D.PlayerHolder(); // important!\n\tscene.add( this.holder );\n\tthis.holder.visible = true;\n\n\tthis.holderHelper = AW3D.PlayerHolderHelper();\n\tscene.add( this.holderHelper );\n\n\tthis.sphere = AW3D.PlayerSphere();\n\tthis.sphere.position.y = 12;\n\tthis.holder.add( this.sphere ); \n\n\tvar player = this; // important!\n\n\tthis.outfit = new AW3D.OutfitManager(); // important!\n\n\tthis.outfit.update = function() {\n\n\t//  Update avatar rotation y.\n\t\tvar direction = player.controller.direction - Math.PI;\n\n\t//  \"this\" is the \"localPlayer.outfit\".\n\t\tthis.direction.rotation.y = direction;\n\n\t//  Update avatar position.\n\t\tvar x = player.controller.center.x;\n\t\tvar y = player.controller.center.y - player.controller.radius;\n\t\tvar z = player.controller.center.z;\n\n\t//  \"this\" is the \"localPlayer.outfit\".\n\t\tthis.direction.position.set( x, y, z );\n\t};\n\n\tvar radius = radius || 3;\n\tthis.controller = new MW.CharacterController( this.holder, radius );\n\tthis.controller.isWalking = false;\n\n\tthis.controller.getdata = function( action ){\n\n\t\tvar data = {};\n\t\tdata.playerid = socket.id;\n\t\tdata.radius = this.radius;\n\t\tdata.isGrounded = this.isGrounded;\n\t\tdata.isOnSlope = this.isOnSlope;\n\t\tdata.isIdling  = this.isIdling;\n\t\tdata.isJumping = this.isJumping;\n\t\tdata.isRunning = this.isRunning;\n\t\tdata.isWalking = this.isWalking;\n\t\tdata.direction = this.direction;\n\t\tdata.movementSpeed = this.movementSpeed;\n\t\tdata.jumpStartTime = this.jumpStartTime;\n\t\tdata.position = this.center.toArray();\n\t\tif (!!action) data.action = action;\n\n\t\treturn data;\n\t};\n\n\tfunction onStartJumping(){\n\t\tplayer.outfit.AnimationsHandler.weightOff(\"idle\", \"walk\", \"run\");\n\t};\n\n\tfunction onEndJumping(){\n\t\tplayer.outfit.AnimationsHandler.weightOn(\"idle\", \"walk\", \"run\");\n\n\t\tif ( player.controller.isRunning && player.controller.isWalking ) {\n\n\t\t\tplayer.outfit.AnimationsHandler.stop();\n\t\t\tplayer.controller.movementSpeed = 28;\n\t\t\tplayer.outfit.AnimationsHandler.play(\"walk\");\n\t\t\tplayer.controller.dispatchEvent({type:\"startRunning\"});\n\n\t\t} else if ( player.controller.isRunning && !player.controller.isWalking ) {\n\n\t\t\tplayer.outfit.AnimationsHandler.stop();\n\t\t\tplayer.controller.movementSpeed = 45;\n\t\t\tplayer.outfit.AnimationsHandler.play(\"run\");\n\t\t\tplayer.controller.dispatchEvent({type:\"startRunning\"});\n\n\t\t} else {\n\n\t\t\tplayer.outfit.AnimationsHandler.stop();\n\t\t\tplayer.controller.movementSpeed = 0;\n\t\t\tplayer.outfit.AnimationsHandler.play(\"idle\");\n\t\t\tplayer.controller.dispatchEvent({type:\"startIdling\"});\n\n\t\t}\n\t}\n\n\tthis.controller.addEventListener(\"endJumping\",   onEndJumping);\n\tthis.controller.addEventListener(\"startJumping\", onStartJumping);\n\n//  Add controller to world.\n\tworld.add( this.controller ); // important!\n\n\tdebugMode && console.log( \n\t\t\"world.characterPool length:\", world.characterPool.length, \n\t\t\"index:\", world.characterPool.indexOf( this.controller )\n\t);\n\n//  Add outfit to scene.\n\tscene.add(this.outfit.direction); // important!\n\n};\n\nPlayer.prototype = {\n\n//  Collect position, direction, nickname, and gender.\n\n\tgetdata: function( socket ){\n\t\tif ( !socket ) return;\n\t\tvar data = {};\n\t\tdata.playerid  = socket.id;\n\t\tdata.nickname  = this.nickname;\n\t\tdata.gender    = this.outfit.getGender();\n\t\tdata.direction = this.outfit.direction.rotation.y;\n\t\tdata.position  = this.outfit.direction.position.toArray();\n\t\tdata.dna       = this.outfit.toDNA();\n\t\tdebugMode && console.log(\"player data:\", data);\n\t\treturn data;\n\t},\n\n//  Remote player set data.\n\n\tsetdata: function( data ){\n\t\tif ( !data.playerid || data.playerid != this.playerid ) return;\n\n\t\tthis.playerid = data.playerid;\n\t\tthis.nickname = data.nickname;\n\t\tthis.outfit.setGender( data.gender );\n\t\tthis.outfit.direction.rotation.y = data.direction;\n\t\tthis.outfit.direction.position.fromArray(data.position);\n\n\t\tif (data.action != undefined) {\n\t\t\tthis.outfit.AnimationsHandler.stop();\n\t\t\tthis.outfit.AnimationsHandler.play( data.action );\n\t\t}\n\t},\n\n//  Create player outfit from dna data.\n\n\tfromDNA: function( dna ){\n\t\tvar frontAngle = Math.PI - cameraControls.getFrontAngle(); // face front.\n\t\tthis.controller.direction = frontAngle;\n\t\tthis.outfit.fromDNA( dna );\n\t\tscene.add(this.outfit.direction);\n\t\tthis.outfit.update();\n\t},\n\n//  Start remote player action.\n\tstartAction: function( running, walking, idling, speed, name, eventType ){\n\n\t\tthis.outfit.AnimationsHandler.stop();        \n\t\tthis.controller.isRunning = running;\n\t\tthis.controller.isWalking = walking;\n\t\tthis.controller.isIdling  = idling;\n\t\tthis.controller.movementSpeed = speed;\n\t\tthis.outfit.AnimationsHandler.play( name );\n\t\tthis.controller.dispatchEvent({type: eventType});\n\n\t},\n\n//  Get local player action data.\n\tgetActionData: function ( name ){\n\t\treturn {\n\t\t\tplayerid : socket.id,\n\t\t\tdirection: this.outfit.direction.rotation.y,\n\t\t\tposition : this.outfit.direction.position.toArray(),\n\t\t\taction   : name,\n\t\t};\n\t},\n\n};\n\nfunction init(){\n\n\tlocalPlayer = new Player(); // important!\n\tlocalPlayer.sphere.visible = false;\n\tdebugMode && console.log(\"localPlayer:\", localPlayer);\n\n//  cameraControl.js\n\n\tcameraControls = new MW.TPSCameraControl(camera, localPlayer.holder, {\n\t\tel: renderer.domElement,               // html renderer element.\n\t\toffset: new THREE.Vector3( 0, 15, 0 ), // camera eye height.\n\t\tradius: 40,                            // default: 37 // (distance of the character to the camera).\n\t\tminRadius: 6,                          // default: 10 // (can take and negative values, yes!!!).\n\t\tmaxRadius: 1500,                       // default: 64, runtime: 40.\n\t\trigidObjects: [],                      // collition objects for the camera.\n\t});\n\n\tcameraControls.getforward = function(){ \n\t\treturn -this.theta \n\t};\n\n\tcameraControls.setVerticalOffset = function(offset){ \n\t\tthis.offset.y = offset; \n\t};\n\n\t(cameraControls.frontAngleUpdate = function(){\n\t\trequestAnimationFrame( cameraControls.frontAngleUpdate );\n\t\tcameraControls.forward = -cameraControls.theta;\n\t})();\n\n/*\n\tcameraControls.addEventListener(\"updated\", function(){\n\t\tdefaultCameraLight.position.copy( cameraControls.camera.position );\n\t});\n*/\n\n//  KeyInputControls.js\n\n\tkeyInputControls = new MW.KeyInputControl();\n\n\tkeyInputControls.On = function(){\n\t\tif ( !keyInputControls.isOff ) return;\n\t\t$(keyInputControls).on( \"movekeyon\", onMoveKeyOn );\n\t\t$(keyInputControls).on( \"movekeyoff\", onMoveKeyOff );\n\t\t$(keyInputControls).on( \"jumpkeypress\", onJumpInput );\n\t\t$(keyInputControls).on( \"movekeychange\", onMoveKeyChange );\n\t\tkeyInputControls.isOff = false;\n\t\tdebugMode && console.log( \"keyInputControls are ON.\" );\n\t};\n\n\tkeyInputControls.Off = function(){\n\t\tif ( keyInputControls.isOff ) return;\n\t\t$(keyInputControls).off( \"movekeyon\", onMoveKeyOn );\n\t\t$(keyInputControls).off( \"movekeyoff\", onMoveKeyOff );\n\t\t$(keyInputControls).off( \"jumpkeypress\", onJumpInput );\n\t\t$(keyInputControls).off( \"movekeychange\", onMoveKeyChange );\n\t\tkeyInputControls.isOff = true;\n\t\tdebugMode && console.log( \"keyInputControls are OFF.\" );\n\t};\n\n\tkeyInputControls.update = function(){\n\n\t\tif ( keyInputControls.isOff ) return;\n\n\t\tif ( keyInputControls.isMoveKeyHolded \n\t\t\t|| localPlayer.controller.isJumping \n\t\t\t|| !localPlayer.controller.isGrounded \n\t\t\t|| localPlayer.controller.isOnSlope ){\n\n\t\t\tthis.dispatchEvent({type:\"update\"});\n\t\t}\n\t};\n\n//\tActivate keyInputControls by setting to \"off\".\n\tkeyInputControls.Off(); // important!\n//\tkeyInputControls.inRun = true;\n\n\tfunction onMoveKeyOn() { \n\t\tdebugMode && console.log(\"move key on\");\n\n\t\tif (  localPlayer.controller.isJumping \n\t\t\t|| !localPlayer.controller.isGrounded \n\t\t\t||  localPlayer.controller.isOnSlope ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlocalPlayer.controller.direction = (2 * Math.PI) - cameraControls.getFrontAngle() + this.frontAngle;\n\n\t\tlocalPlayer.outfit.AnimationsHandler.stop();\n\t\tlocalPlayer.controller.isRunning = true; \n\t\tlocalPlayer.controller.isWalking = true;\n\t\tlocalPlayer.controller.movementSpeed = 28;\n\t\tlocalPlayer.outfit.AnimationsHandler.play(\"walk\");\n\n\t}\n\n\tfunction onMoveKeyChange() {\n\t\tdebugMode && console.log(\"move key changed\");\n\t\tlocalPlayer.controller.direction = (2 * Math.PI) - cameraControls.getFrontAngle() + this.frontAngle;\n\t}\n\n\tfunction onMoveKeyOff() {\n\t\tdebugMode && console.log(\"move key off\");\n\n\t\tif (  localPlayer.controller.isJumping \n\t\t\t|| !localPlayer.controller.isGrounded \n\t\t\t||  localPlayer.controller.isOnSlope ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar finalDirection = (2 * Math.PI) - cameraControls.getFrontAngle() + this.frontAngle;\n\n\t\tlocalPlayer.controller.direction = finalDirection;\n\t\tlocalPlayer.outfit.AnimationsHandler.stop();\n\t\tlocalPlayer.controller.isRunning = false;\n\t\tlocalPlayer.controller.isWalking = false;\n\t\tlocalPlayer.controller.isIdling  = true;\n\t\tlocalPlayer.controller.movementSpeed = 0;\n\t\tlocalPlayer.outfit.AnimationsHandler.play(\"idle\");\n\t\tlocalPlayer.controller.dispatchEvent({type:\"startIdling\"});\n\n\t}\n\n\tfunction onJumpInput() {\n\t\tdebugMode && console.log(\"jump key on\");\n\n\t\tif (  localPlayer.controller.isJumping \n\t\t\t|| !localPlayer.controller.isGrounded \n\t\t\t||  localPlayer.controller.isOnSlope ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlocalPlayer.controller.jump();\n\t\tlocalPlayer.outfit.AnimationsHandler.jump();\n\n\t}\n\n//  JoystickControls.js (requires \"jquery.js\")\n\n\t$(document.head).append(\n\t\t\"<style class='joystick-controls'> \\n.gameinput-button__inner { display:table-cell; vertical-align: middle; } \\n\"\n\t\t+ \".gameinput-joystick { border:solid 0px white; border-radius:50%; position:absolute; bottom:30px; user-select:none; \"\n\t\t+ \"touch-action:none; -ms-touch-action:none; -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; } \\n\"\n\t\t+ \".gameinput-frame { position:absolute; top:0; left:0; pointer-events:none; opacity:0.5; } \\n\"\n\t\t+ \".gameinput-button { cursor:pointer; text-align:center; position:absolute; display:table; \\n\"\n\t\t+ \"box-sizing:border-box; border:1px solid #333; border-radius:50%; background:rgba( 255, 255, 255, .5 ); user-select:none; \"\n\t\t+ \"touch-action:none; -ms-touch-action:none; -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; } \\n\"\n\t\t+ \"#joystick1 { bottom:50px; right:40px; width:120px; height:120px;z-index:1; } \\n\"\n\t\t+ \"#joystick2 { bottom:50px; left:40px; width:120px; height:120px; z-index:1;} \\n\"\n\t\t+ \"#jumpButton { right:105px; bottom:240px; z-index:1; } \\n\"\n\t\t+ \"@media ( max-width: 768px ) { \\n#joystick1 { bottom:0px; right:0px; } \\n#joystick2 { bottom:0px; left:0px; } \\n\"\n\t\t+ \"#jumpButton { bottom:190px; right:65px; } \\n.gameinput-joystick { bottom:0px;} \\n} \\n\"\n\t\t+ \".gameinput-joystick__button { position:absolute; width:72px; height:72px; left:85px; top:85px; cursor:pointer; \"\n\t\t+ \"box-sizing:border-box; border-radius:50%; border:1px solid #333; background:rgba( 255, 255, 255, .5 ); } \\n\"\n\t\t+ \"</style>\"\n\t);\n\n\t$(document.body).append(\n\t\t'<div class=\"joystick-controls\" id=\"joystick-controls-1\">' \n\t\t+ '</div><div class=\"joystick-controls\" id=\"joystick-controls-2\"></div>'\n\t);\n\n\tvar joystick1Selector  = \"#joystick1\";\n\tvar joystick2Selector  = \"#joystick2\";\n\tvar jumpButtonSelector = \"#jumpButton\";\n\n\tvar joystickControlsSelector  = \".joystick-controls\";\n\tvar joystickControls1Selector = \"#joystick-controls-1\";\n\tvar joystickControls2Selector = \"#joystick-controls-2\";\n\n\tvar buttonSvgSrc = '<svg width=\"48\" height=\"48\" viewBox=\"0 0 64 64\"><path fill=\"#fff\" d=\"M44.5,54.5c-0.3-5.1-2.4-9.4-5.7-13.2C41,36,40.9,30,38.5,24.7c-1.2-2.7-3.9-4.4-6.9-3.3c-0.2,0.1-0.4,0.1-0.5,0.2c-3-4.3-6.6-8.3-10.1-11.8c-2.6-2.6-6.4,1.7-3.8,4.3c3.9,3.9,8.1,8.5,11,13.7c0,0.1,0.1,0.3,0.2,0.4c1.5,3.2,1.9,6.4,0.2,9.6c-0.3,0.5-0.4,1-0.5,1.5c-1.1,1.5-2.3,3-3.6,4.4c-0.8-2.3-1.4-4.7-1.6-7.1c-0.5-4.6-7.7-4.1-7.2,0.5c0.5,4.9,2.1,9.6,3.9,14.2c0.8,1.9,3.6,3.4,5.4,1.8c2.8-2.4,5.3-4.9,7.5-7.8c0.2,0.1,0.5,0.1,0.7,0.1c0.1,0.3,0.3,0.5,0.5,0.7c1.7,1.8,2.8,3.9,3.3,6.3c-2.2,0.8-4.6,1.4-7,1.4c-4.6,0.1-4.1,7.2,0.5,7.2c4-0.1,7.9-1.3,11.6-3C43.6,57.5,44.6,56.2,44.5,54.5z M34.2,8.9c0.7,0.1,1.6-0.1,2.3,0.3c1.5,0.8,2.6,2.1,3.2,3.6c0.2-2.2,0.5-4.3,0.8-6.5c0.5-3.7-5.1-4.7-5.7-1.1C34.6,6.3,34.3,7.8,34.2,8.9z\"/><circle fill=\"#fff\" cx=\"33.8\" cy=\"15.2\" r=\"4.9\"/></svg>';\n\n\tjoystick1  = new virtualInput.Joystick( $( joystickControls1Selector ), 94, { id: \"joystick1\" } );\n\tjoystick2  = new virtualInput.Joystick( $( joystickControls2Selector ), 94, { id: \"joystick2\" } );\n\tjumpButton = new virtualInput.Button( $( joystickControls1Selector ),   58, { id: \"jumpButton\", label: \"<b>JUMP</b>\" } ); // buttonSvgSrc\n\n\tjoystick1.addEventListener( \"active\", function () { \n\n\t\tif (  localPlayer.controller.isJumping || !localPlayer.controller.isGrounded ||  localPlayer.controller.isOnSlope ) return;\n\n\t\tlocalPlayer.controller.direction = (3 * Math.PI/2) - cameraControls.getFrontAngle() + this.angle; // important!\n\n\t\tif ( localPlayer.controller.isRunning && !localPlayer.controller.isWalking ) {\n\n\t\t\tlocalPlayer.outfit.AnimationsHandler.stop();\n\t\t\tlocalPlayer.controller.movementSpeed = 45;\n\t\t\tlocalPlayer.outfit.AnimationsHandler.play(\"run\");\n\n\t\t} else {\n\n\t\t\tlocalPlayer.outfit.AnimationsHandler.stop();\n\t\t\tlocalPlayer.controller.isRunning = true; \n\t\t\tlocalPlayer.controller.isWalking = false;  // !!!danger: \"false\" cause bug in production server ??? //\n\t\t\tlocalPlayer.controller.movementSpeed = 28;\n\t\t\tlocalPlayer.outfit.AnimationsHandler.play(\"walk\");\n\n\t\t}\n\t});\n\n\tjoystick1.addEventListener( \"disactive\", function () { \n\n\t\tif (  localPlayer.controller.isJumping || !localPlayer.controller.isGrounded ||  localPlayer.controller.isOnSlope ) return;\n\n\t\tlocalPlayer.outfit.AnimationsHandler.stop();\n\t\tlocalPlayer.controller.isRunning = false;\n\t\tlocalPlayer.controller.isWalking = false;\n\t\tlocalPlayer.controller.movementSpeed = 0;\n\t\tlocalPlayer.outfit.AnimationsHandler.play(\"idle\");\n\t\tlocalPlayer.controller.dispatchEvent({type:\"startIdling\"});\n\n\t});\n\n\tjoystick1.update = function(){\n\n\t\tif ( this.isActive ) {\n\n\t\t\tlocalPlayer.controller.direction = (3 * Math.PI/2) - cameraControls.getFrontAngle() + this.angle;\n\n\t\t\tthis.dispatchEvent({type:\"update\"}); // important!\n\n\t\t}\n\t};\n\n\tjoystick2.update = function(){\n\n\t\tif ( this.isActive ) {\n\n\t\t\tcameraControls.setLatLon(\n\t\t\t\tcameraControls.lat + this.position.y * 0.5, // deg.\n\t\t\t\tcameraControls.lon - this.position.x        // deg.\n\t\t\t);\n\n\t\t\tthis.dispatchEvent({type:\"update\"}); // important!\n\t\t}\n\t}\n\n\tjumpButton.addEventListener( \"press\", function () { \n\n\t\tif (  localPlayer.controller.isJumping || !localPlayer.controller.isGrounded || localPlayer.controller.isOnSlope ) return;\n\n\t\tlocalPlayer.controller.jump();\n\t\tlocalPlayer.outfit.AnimationsHandler.jump();\n\n\t});\n\n\n\n\twatch(cameraControls, [\"lat\", \"lon\"], function(){\n\t\tdefaultCameraLight.position.copy( camera.position );\n\t});\n\n\n\twatch(keyInputControls, \"frontAngle\", function(){\n\t\tdefaultCameraLight.position.copy( camera.position );\n\t});\n\n\n\n//\tkeyInputControls.On(); // important!\n\tconsole.log( \"application inited.\" );\n\n}\n\nfunction start(){\n\n\tkeyInputControls.On();\n\tconsole.log( \"application started.\" );\n}\n\nfunction stop(){\n\n\tkeyInputControls.Off();\n\t$(\".joystick-controls\").remove();\n\tconsole.log( \"application stopped.\" );\n}\n\n//\tRuntime.\n\nfunction update(){\n\n\tcameraControls.update();\n\tkeyInputControls.update();\n\tlocalPlayer.outfit.update();\n\tjoystick1.update();\n\tjoystick2.update();\n\n\n}\n"
			}],
		"05902F26-E7A6-4875-8D13-70E2EF94E04E": [
			{
				"name": "groundHelper.js",
				"source": "//\tgroundHelper.js\n\ndebugMode && console.log(this);\n\nvar helper = this;\nvar fontPath = \"/three/fonts/helvetiker_regular.typeface.json\";\n\ngroundHelper = groundHelper(1000, 10);  \naxisCustomHelper = customAxisHelper(5200);\naxisOriginHelper = originAxisHelper(1200);\n\nfunction init(){\n\thelper.add(groundHelper, axisOriginHelper);\n}\n\nfunction groundHelper(xz, step){\n\tif (!xz) xz = 1000;\n\tif (!step) step = 10;\n\tvar grid = new THREE.GridHelper( xz, step, 0x444444, 0x444444 );\n\tgrid.name = \"GRID\"\n\tgrid.position.y = 0;\n//\thelper.add( grid );\n\treturn grid;\n}\n\nfunction customAxisHelper( distance ){\n\tvar group = new THREE.Group();\n//\thelper.add(group);\n\n//  Lines.\n\tvar geometryAxisXpos = new THREE.Geometry();\n\tvar geometryAxisXneg = new THREE.Geometry();\n\tvar geometryAxisYpos = new THREE.Geometry();\n\tvar geometryAxisYneg = new THREE.Geometry();\n\tvar geometryAxisZpos = new THREE.Geometry();\n\tvar geometryAxisZneg = new THREE.Geometry();\n\n\tvar materialAxisXpos = new THREE.LineBasicMaterial( {color: 0xff0000} );\n\tvar materialAxisXneg = new THREE.LineBasicMaterial( {color: 0xff0000} );\n\tvar materialAxisYpos = new THREE.LineBasicMaterial( {color: 0x00ff00} );\n\tvar materialAxisYneg = new THREE.LineBasicMaterial( {color: 0x00ff00} );\n\tvar materialAxisZpos = new THREE.LineBasicMaterial( {color: 0x0000ff} );\n\tvar materialAxisZneg = new THREE.LineBasicMaterial( {color: 0x0000ff} );\n\n\tgeometryAxisXpos.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( distance, 0, 0 ) );\n\tgeometryAxisXneg.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3(-distance, 0, 0 ) );\n\tgeometryAxisYpos.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, distance, 0 ) );\n\tgeometryAxisYneg.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0,-distance, 0 ) );\n\tgeometryAxisZpos.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, distance ) );\n\tgeometryAxisZneg.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0,-distance ) );\n\n\tvar lineAxisXpos = new THREE.Line( geometryAxisXpos, materialAxisXpos );\n\tvar lineAxisXneg = new THREE.Line( geometryAxisXneg, materialAxisXneg );\n\tvar lineAxisYpos = new THREE.Line( geometryAxisYpos, materialAxisYpos );\n\tvar lineAxisYneg = new THREE.Line( geometryAxisYneg, materialAxisYneg );\n\tvar lineAxisZpos = new THREE.Line( geometryAxisZpos, materialAxisZpos );\n\tvar lineAxisZneg = new THREE.Line( geometryAxisZneg, materialAxisZneg );\n\n\tgroup.add( lineAxisXpos );\n\tgroup.add( lineAxisXneg );\n//  group.add( lineAxisYpos );\n//  group.add( lineAxisYneg );\n\tgroup.add( lineAxisZpos );\n\tgroup.add( lineAxisZneg );\n\tgroup.name = \"AXES\";\n\n\treturn group;\n}\n\nfunction originAxisHelper( distance ){\n\tvar group = new THREE.Group();\n\tvar loader = new THREE.FontLoader();\n\tloader.load( fontPath, function ( response ) {\n\t\tvar font = response;\n\t\t//\thelper.add(group);\n\n\t\t//  Font Material\n\t\tvar materialFace = new THREE.MeshBasicMaterial( { color: 0xffffff } );\n\t\tvar materialSide = new THREE.MeshBasicMaterial( { color: 0x888888 } );\n\t\tvar materialArray = [ materialFace, materialSide ];\n\t\tvar material = new THREE.MeshFaceMaterial(materialArray);\n\n\t\t//  Text Styles.\n\t\th0 = { size: 40, height: 2,   curveSegments: 10, font: font, weight: \"normal\", style: \"normal\", bevelThickness: 1, bevelSize: 2, bevelEnabled: false, material: 0, extrudeMaterial: 1 }\n\t\th1 = { size: 20, height: 1,   curveSegments: 10, font: font, weight: \"normal\", style: \"normal\", bevelThickness: 1, bevelSize: 2, bevelEnabled: false, material: 0, extrudeMaterial: 1 }\n\t\th2 = { size: 10, height: 1,   curveSegments: 10, font: font, weight: \"normal\", style: \"normal\", bevelThickness: 1, bevelSize: 2, bevelEnabled: false, material: 0, extrudeMaterial: 1 }\n\t\th3 = { size: 5,  height: 0.5, curveSegments: 10, font: font, weight: \"normal\", style: \"normal\", bevelThickness: 1, bevelSize: 2, bevelEnabled: false, material: 0, extrudeMaterial: 1 }\n\n\t\t//  Origins Group.\n\t\tgroup.add( new Text3D( \"+x\", h1, [2, 2, 5], [ distance, 20, 0], [0, -Math.PI * 0.5, 0]) );\n\t\tgroup.add( new Text3D( \"-x\", h1, [2, 2, 5], [-distance, 20, 0], [0,  Math.PI * 0.5, 0]) ); \n\t\tgroup.add( new Text3D( \"+z\", h1, [2, 2, 5], [0, 20,  distance], [0, -Math.PI,       0]) ); \n\t\tgroup.add( new Text3D( \"-z\", h1, [2, 2, 5], [0, 20, -distance], [0,              0, 0]) ); \n\t\tgroup.add( new Text3D( \"+y\", h1, [2, 2, 5], [0,   distance, 0], [ Math.PI * 0.5, 0, 0]) ); \n\t\tgroup.add( new Text3D( \"-y\", h1, [2, 2, 5], [0,  -distance, 0], [-Math.PI * 0.5, 0, 0]) ); \n\t\tgroup.name = \"ORIGINS\";\n\n\t\t//  return group;\n\n\t\tfunction Text3D(text, style, scale, position, rotation){\n\t\t\tvar geometry = new THREE.TextGeometry( text, style );\n\t\t\tvar mesh = new THREE.Mesh(geometry, material );\n\t\t\tgeometry.computeBoundingBox();\n\t\t\tvar width = geometry.boundingBox.max.x - geometry.boundingBox.min.x;\n\t\t\tmesh.scale.fromArray( scale ); \n\t\t\tmesh.geometry.center();\n\t\t\tmesh.position.fromArray( position );\n\t\t\tmesh.rotation.fromArray( rotation );\n\t\t\treturn mesh;\n\t\t}\n\n\t});\n\n\treturn group;\n}\n\n"
			}],
		"A19C133A-E409-4607-B7BD-0E2698549750": [
			{
				"name": "basic-animations.js",
				"source": "//\tbasic-animation.js\n\nAnimations = {}; // object.\n\nvar loader = new THREE.XHRLoader();\nloader.setResponseType( \"json\" );\nloader.load(\"/AW3D_db/animations.json\", function(results){\n\n\t//  returns an array of objects!\n\n\tdebugMode && console.log(\"animations:\", results);\n\n\tvar json = results.find(function(item){\n\t\treturn item._id == \"basic\";\n\t});\n\n\tdebugMode && console.log(\"basic:\", json);\n\n\tfor (var name in json){\n\t\tif ( name != \"_id\" ) Animations[name] = json[name];\n\t}\n\n});"
			},
			{
				"name": "male-animations.js",
				"source": "//\tmale-animation.js\n\nMaleAnimations = {}; // object.\n\nvar loader = new THREE.XHRLoader();\nloader.setResponseType( \"json\" );\nloader.load(\"/AW3D_db/animations.json\", function(results){\n\n\t//  returns an array of objects!\n\n\tvar json = results.find(function(item){\n\t\treturn item._id == \"male\";\n\t});\n\n\tdebugMode && console.log(\"male:\", json);\n\n\tfor (var name in json){\n\t\tif ( name != \"_id\" ) MaleAnimations[name] = json[name];\n\t}\n\n});"
			},
			{
				"name": "female-animations.js",
				"source": "//\tmale-animation.js\n\nFemaleAnimations = {}; // object.\n\nvar loader = new THREE.XHRLoader();\nloader.setResponseType( \"json\" );\nloader.load(\"/AW3D_db/animations.json\", function(results){\n\n\t//  returns an array of objects!\n\n\tvar json = results.find(function(item){\n\t\treturn item._id == \"female\";\n\t});\n\n\tdebugMode && console.log(\"female:\", json);\n\n\tfor (var name in json){\n\t\tif ( name != \"_id\" ) FemaleAnimations[name] = json[name];\n\t}\n\n});"
			}],
		"6AD93A00-35BA-4603-8634-129EA23AF066": [
			{
				"name": "skeleton-mesh-loader.js",
				"source": "skeleton = {}; // important!\n\nvar loader = new THREE.XHRLoader();\nvar url = \"/skinned/skeleton/skeleton.json\";\nloader.setResponseType( \"json\" );\nloader.load(url, function(json){\n\n\tdebugMode && console.log(\"skeleton:\", json);\n\n\tvar loader = new THREE.JSONLoader();\n\tvar object = loader.parse( json );\n\n\tdebugMode && console.log(\"object:\", object);\n\n\tvar geometry = object.geometry;\n\tgeometry.sourceFile = url;  // important!\n\tgeometry.name = json.name + \".geometry\";\n\tgeometry.computeFaceNormals();\n\tgeometry.computeVertexNormals();\n\tgeometry.computeBoundingBox();\n\tgeometry.computeBoundingSphere();\n\n\tvar material = new THREE.MeshLambertMaterial({\n\t\tside: 0,\n\t\topacity: 1,\n\t\tshading: 2,\n\t\temissive: 0,\n\t\tskinning: true,\n\t\tcolor: 16777215,\n\t\ttransparent: false,\n\t\tname: \"HF_SkeletonMaterial\",\n\t});\n\n\tvar skinned = new THREE.SkinnedMesh( geometry, material );\n\n\tskinned.renderDepth = 1;\n\tskinned.frustumCulled = false;\n\tskinned.position.set( 0, 0, 0 );\n\tskinned.rotation.set( 0, 0, 0 );\n\tskinned.scale.set( 1,1,1 );\n\tskinned.castShadow = true;\n\tskinned.name = json.name;\n\n\tskeleton = skinned; // important!\n\tlocalPlayer.outfit.add({\"skeleton\":skeleton});\n\n});\n\n/*\nfunction init(){\n//\tAdd to scene. (debugging)\n\tvar data = {\n\t\tgeometry: \"/skinned/skeleton/skeleton.json\",\n\t\tmaterial: {\n\t\t\tcolor: 16777215,\n\t\t\temissive: 0,\n\t\t\tname: \"HF_SkeletonMaterial\",\n\t\t\topacity: 1,\n\t\t\tshading: 2,\n\t\t\tside: 0,\n\t\t\tskinning: true,\n\t\t\ttransparent: false,\n\t\t\ttype: \"MeshLambertMaterial\",\n\t\t},\n\t\tname: \"body\",\n\t\tscale: [1, 1, 1],\n\t\tvisible: true,\n\t};\n\n\tlocalPlayer.outfit.fromJSON({\"skeleton\":data});\n}\n*/"
			}],
		"3854A5B6-1389-4A5F-887D-950B553DAD02": [
			{
				"name": "octree-helpers.js",
				"source": "//  Octree helpers.js\n\nvar octreehelper = this;\n\noctreeMeshHelpers = [];\noctreeEdgesHelpers = [];\n\n//  Add octree edges helpers.\noctreeHelpers( octree );\n\nfunction octreeHelpers( octree ){\n\tvar nodeIndex = octree.nodes.length - 1;\n\tvar node = octree.nodes[ nodeIndex ][0];\n\tvar x = node.max.x - node.min.x;\n\tvar y = node.max.y - node.min.y;\n\tvar z = node.max.z - node.min.z;\n\tvar geometry = new THREE.BoxGeometry(x, y, z);\n\tvar material = new THREE.MeshBasicMaterial({visible:false});\n\n\toctree.nodes[ nodeIndex ].forEach(function(node){\n\n\t\tvar x = node.max.x - node.min.x;\n\t\tvar y = node.max.y - node.min.y;\n\t\tvar z = node.max.z - node.min.z;\n\n\t\tvar mesh = new THREE.Mesh(geometry, material);\n\t\tvar helper = new THREE.EdgesHelper( mesh, 0xffff00 );\n\n\t\tmesh.position.set(\n\t\t\tnode.min.x + (x/2),\n\t\t\tnode.min.y + (y/2),\n\t\t\tnode.min.z + (z/2)\n\t\t);\n\n\t\toctreehelper.add( mesh, helper );\n\n\t\toctreeMeshHelpers.push(mesh);\n\t\toctreeEdgesHelpers.push(helper);\n\t});\n}\n\nfunction octreeNodeHelper( node ){\n\n\tvar x = node.max.x - node.min.x;\n\tvar y = node.max.y - node.min.y;\n\tvar z = node.max.z - node.min.z;\n\n\tvar geometry = new THREE.BoxGeometry(x, y, z);\n\tvar material = new THREE.MeshBasicMaterial({visible:false});\n\tvar mesh = new THREE.Mesh(geometry, material);\n\n\tmesh.position.set(\n\t\tnode.min.x + (x/2),\n\t\tnode.min.y + (y/2),\n\t\tnode.min.z + (z/2)\n\t);\n\n\toctreehelper.add( mesh );\n\toctreeMeshHelpers.push(mesh);\n\n\tvar helper = new THREE.EdgesHelper( mesh, 0xffff00 );\n\n\thelper.name = \"octree helper\";\n\toctreehelper.add( helper );\n\toctreeEdgesHelpers.push(helper);\n}\n\n/*\n//  Remove octree mesh helpers.\n    setTimeout(function(){\n        octreeMeshHelpers.forEach( function( item, i ){\n            octreehelper.remove( octreeMeshHelpers[i] );\n            var geometry = octreeMeshHelpers[i].geometry;\n            var material = octreeMeshHelpers[i].material;\n            geometry.dispose();\n            material.dispose();\n        });\n        console.log( \"octree mesh helpers has been removed.\" );\n    }, 5000);\n*/\n"
			}],
		"AF01D9C1-165B-477E-9DB6-3F8CC5BA7E3C": [
			{
				"name": "camera-light.js",
				"source": "defaultCameraLight = this;\n"
			}]
	},
	"camera": {
		"metadata": {
			"version": 4.4,
			"type": "Object",
			"generator": "Object3D.toJSON"
		},
		"object": {
			"uuid": "2ED07C67-F604-4A17-8487-BA0706AB6536",
			"type": "PerspectiveCamera",
			"name": "Camera",
			"matrix": [0.7667859792709351,2.2366607177470854e-10,-0.6419028043746948,0,-0.026682686060667038,0.9991356730461121,-0.03187384456396103,0,0.6413480043411255,0.04156810790300369,0.7661232352256775,0,57.883541107177734,16.780786514282227,69.53287506103516,1],
			"fov": 50,
			"zoom": 1,
			"near": 0.1,
			"far": 10000,
			"focus": 10,
			"aspect": 1.9261025029797378,
			"filmGauge": 35,
			"filmOffset": 0
		}
	},
	"scene": {
		"metadata": {
			"version": 4.4,
			"type": "Object",
			"generator": "Object3D.toJSON"
		},
		"object": {
			"uuid": "BCC3A53B-07C6-4FC3-B308-8F4A3E94469D",
			"type": "Scene",
			"name": "Scene",
			"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
			"children": [
				{
					"uuid": "AF01D9C1-165B-477E-9DB6-3F8CC5BA7E3C",
					"type": "DirectionalLight",
					"name": "Default Camera Light",
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,57.883541107177734,16.780786514282227,69.53287506103516,1],
					"color": 16777215,
					"intensity": 0.5
				},
				{
					"uuid": "9434477B-B3D8-4832-8154-CC8A8AD68FFC",
					"type": "Group",
					"name": "Lights",
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
					"children": [
						{
							"uuid": "11880467-1961-4E81-8D71-66BC39DFA18E",
							"type": "DirectionalLight",
							"name": "DirectionalLight 1",
							"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,50,50,1],
							"color": 16777215,
							"intensity": 0.5
						},
						{
							"uuid": "1F367C36-34FA-41A0-B723-1CB1D350E369",
							"type": "DirectionalLight",
							"name": "DirectionalLight 2",
							"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,-35,55,-35,1],
							"color": 16777215,
							"intensity": 0.5
						},
						{
							"uuid": "51FC0AE7-DB3F-49CF-8C6A-AFE849A0C554",
							"type": "DirectionalLight",
							"name": "DirectionalLight 3",
							"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,35,55,-35,1],
							"color": 16777215,
							"intensity": 0.5
						}]
				},
				{
					"uuid": "05902F26-E7A6-4875-8D13-70E2EF94E04E",
					"type": "Group",
					"name": "Ground Helper",
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
				},
				{
					"uuid": "3854A5B6-1389-4A5F-887D-950B553DAD02",
					"type": "Group",
					"name": "Octree Helpers",
					"visible": false,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
				},
				{
					"uuid": "A19C133A-E409-4607-B7BD-0E2698549750",
					"type": "Group",
					"name": "Animations Loader",
					"visible": false,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
				},
				{
					"uuid": "6AD93A00-35BA-4603-8634-129EA23AF066",
					"type": "Group",
					"name": "Skinned Meshes Loader",
					"visible": false,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
				}]
		}
	}
}